
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
 8000200:	b672      	cpsid	i
 8000202:	4825      	ldr	r0, [pc, #148]	; (8000298 <endfiniloop+0x4>)
 8000204:	f380 8809 	msr	PSP, r0
 8000208:	4824      	ldr	r0, [pc, #144]	; (800029c <endfiniloop+0x8>)
 800020a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800020e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8000212:	6008      	str	r0, [r1, #0]
 8000214:	2002      	movs	r0, #2
 8000216:	f380 8814 	msr	CONTROL, r0
 800021a:	f3bf 8f6f 	isb	sy
 800021e:	f000 ff3f 	bl	80010a0 <__core_init>
 8000222:	f003 ffb5 	bl	8004190 <__early_init>
 8000226:	481e      	ldr	r0, [pc, #120]	; (80002a0 <endfiniloop+0xc>)
 8000228:	491e      	ldr	r1, [pc, #120]	; (80002a4 <endfiniloop+0x10>)
 800022a:	4a1f      	ldr	r2, [pc, #124]	; (80002a8 <endfiniloop+0x14>)

0800022c <msloop>:
 800022c:	4291      	cmp	r1, r2
 800022e:	bf3c      	itt	cc
 8000230:	f841 0b04 	strcc.w	r0, [r1], #4
 8000234:	e7fa      	bcc.n	800022c <msloop>
 8000236:	491d      	ldr	r1, [pc, #116]	; (80002ac <endfiniloop+0x18>)
 8000238:	4a17      	ldr	r2, [pc, #92]	; (8000298 <endfiniloop+0x4>)

0800023a <psloop>:
 800023a:	4291      	cmp	r1, r2
 800023c:	bf3c      	itt	cc
 800023e:	f841 0b04 	strcc.w	r0, [r1], #4
 8000242:	e7fa      	bcc.n	800023a <psloop>
 8000244:	491a      	ldr	r1, [pc, #104]	; (80002b0 <endfiniloop+0x1c>)
 8000246:	4a1b      	ldr	r2, [pc, #108]	; (80002b4 <endfiniloop+0x20>)
 8000248:	4b1b      	ldr	r3, [pc, #108]	; (80002b8 <endfiniloop+0x24>)

0800024a <dloop>:
 800024a:	429a      	cmp	r2, r3
 800024c:	bf3e      	ittt	cc
 800024e:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000252:	f842 0b04 	strcc.w	r0, [r2], #4
 8000256:	e7f8      	bcc.n	800024a <dloop>
 8000258:	2000      	movs	r0, #0
 800025a:	4918      	ldr	r1, [pc, #96]	; (80002bc <endfiniloop+0x28>)
 800025c:	4a18      	ldr	r2, [pc, #96]	; (80002c0 <endfiniloop+0x2c>)

0800025e <bloop>:
 800025e:	4291      	cmp	r1, r2
 8000260:	bf3c      	itt	cc
 8000262:	f841 0b04 	strcc.w	r0, [r1], #4
 8000266:	e7fa      	bcc.n	800025e <bloop>
 8000268:	f000 ff32 	bl	80010d0 <__init_ram_areas>
 800026c:	f000 ff20 	bl	80010b0 <__late_init>
 8000270:	4c14      	ldr	r4, [pc, #80]	; (80002c4 <endfiniloop+0x30>)
 8000272:	4d15      	ldr	r5, [pc, #84]	; (80002c8 <endfiniloop+0x34>)

08000274 <initloop>:
 8000274:	42ac      	cmp	r4, r5
 8000276:	da03      	bge.n	8000280 <endinitloop>
 8000278:	f854 1b04 	ldr.w	r1, [r4], #4
 800027c:	4788      	blx	r1
 800027e:	e7f9      	b.n	8000274 <initloop>

08000280 <endinitloop>:
 8000280:	f004 f92e 	bl	80044e0 <main>
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x38>)
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x3c>)

08000288 <finiloop>:
 8000288:	42ac      	cmp	r4, r5
 800028a:	da03      	bge.n	8000294 <endfiniloop>
 800028c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000290:	4788      	blx	r1
 8000292:	e7f9      	b.n	8000288 <finiloop>

08000294 <endfiniloop>:
 8000294:	f000 bf14 	b.w	80010c0 <__default_exit>
 8000298:	20000800 	.word	0x20000800
 800029c:	08000000 	.word	0x08000000
 80002a0:	55555555 	.word	0x55555555
 80002a4:	20000000 	.word	0x20000000
 80002a8:	20000400 	.word	0x20000400
 80002ac:	20000400 	.word	0x20000400
 80002b0:	08005874 	.word	0x08005874
 80002b4:	20000800 	.word	0x20000800
 80002b8:	2000087c 	.word	0x2000087c
 80002bc:	20000880 	.word	0x20000880
 80002c0:	200018a4 	.word	0x200018a4
 80002c4:	08000200 	.word	0x08000200
 80002c8:	08000200 	.word	0x08000200
 80002cc:	08000200 	.word	0x08000200
 80002d0:	08000200 	.word	0x08000200
	...

080002e0 <_port_switch>:
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002e8:	68c3      	ldr	r3, [r0, #12]
 80002ea:	469d      	mov	sp, r3
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
 80002f0:	2300      	movs	r3, #0
 80002f2:	f383 8811 	msr	BASEPRI, r3
 80002f6:	4628      	mov	r0, r5
 80002f8:	47a0      	blx	r4
 80002fa:	2000      	movs	r0, #0
 80002fc:	f001 fb68 	bl	80019d0 <chThdExit>

08000300 <_port_switch_from_isr>:
 8000300:	f001 fa46 	bl	8001790 <chSchDoReschedule>

08000304 <_port_exit_from_isr>:
 8000304:	df00      	svc	0
 8000306:	e7fe      	b.n	8000306 <_port_exit_from_isr+0x2>
	...

08000310 <__aeabi_drsub>:
 8000310:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000314:	e002      	b.n	800031c <__adddf3>
 8000316:	bf00      	nop

08000318 <__aeabi_dsub>:
 8000318:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800031c <__adddf3>:
 800031c:	b530      	push	{r4, r5, lr}
 800031e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000322:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000326:	ea94 0f05 	teq	r4, r5
 800032a:	bf08      	it	eq
 800032c:	ea90 0f02 	teqeq	r0, r2
 8000330:	bf1f      	itttt	ne
 8000332:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000336:	ea55 0c02 	orrsne.w	ip, r5, r2
 800033a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800033e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000342:	f000 80e2 	beq.w	800050a <__adddf3+0x1ee>
 8000346:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800034a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800034e:	bfb8      	it	lt
 8000350:	426d      	neglt	r5, r5
 8000352:	dd0c      	ble.n	800036e <__adddf3+0x52>
 8000354:	442c      	add	r4, r5
 8000356:	ea80 0202 	eor.w	r2, r0, r2
 800035a:	ea81 0303 	eor.w	r3, r1, r3
 800035e:	ea82 0000 	eor.w	r0, r2, r0
 8000362:	ea83 0101 	eor.w	r1, r3, r1
 8000366:	ea80 0202 	eor.w	r2, r0, r2
 800036a:	ea81 0303 	eor.w	r3, r1, r3
 800036e:	2d36      	cmp	r5, #54	; 0x36
 8000370:	bf88      	it	hi
 8000372:	bd30      	pophi	{r4, r5, pc}
 8000374:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000378:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800037c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000380:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000384:	d002      	beq.n	800038c <__adddf3+0x70>
 8000386:	4240      	negs	r0, r0
 8000388:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800038c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000390:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000394:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000398:	d002      	beq.n	80003a0 <__adddf3+0x84>
 800039a:	4252      	negs	r2, r2
 800039c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80003a0:	ea94 0f05 	teq	r4, r5
 80003a4:	f000 80a7 	beq.w	80004f6 <__adddf3+0x1da>
 80003a8:	f1a4 0401 	sub.w	r4, r4, #1
 80003ac:	f1d5 0e20 	rsbs	lr, r5, #32
 80003b0:	db0d      	blt.n	80003ce <__adddf3+0xb2>
 80003b2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80003b6:	fa22 f205 	lsr.w	r2, r2, r5
 80003ba:	1880      	adds	r0, r0, r2
 80003bc:	f141 0100 	adc.w	r1, r1, #0
 80003c0:	fa03 f20e 	lsl.w	r2, r3, lr
 80003c4:	1880      	adds	r0, r0, r2
 80003c6:	fa43 f305 	asr.w	r3, r3, r5
 80003ca:	4159      	adcs	r1, r3
 80003cc:	e00e      	b.n	80003ec <__adddf3+0xd0>
 80003ce:	f1a5 0520 	sub.w	r5, r5, #32
 80003d2:	f10e 0e20 	add.w	lr, lr, #32
 80003d6:	2a01      	cmp	r2, #1
 80003d8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003dc:	bf28      	it	cs
 80003de:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003e2:	fa43 f305 	asr.w	r3, r3, r5
 80003e6:	18c0      	adds	r0, r0, r3
 80003e8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003ec:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003f0:	d507      	bpl.n	8000402 <__adddf3+0xe6>
 80003f2:	f04f 0e00 	mov.w	lr, #0
 80003f6:	f1dc 0c00 	rsbs	ip, ip, #0
 80003fa:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003fe:	eb6e 0101 	sbc.w	r1, lr, r1
 8000402:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000406:	d31b      	bcc.n	8000440 <__adddf3+0x124>
 8000408:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800040c:	d30c      	bcc.n	8000428 <__adddf3+0x10c>
 800040e:	0849      	lsrs	r1, r1, #1
 8000410:	ea5f 0030 	movs.w	r0, r0, rrx
 8000414:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000418:	f104 0401 	add.w	r4, r4, #1
 800041c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000420:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000424:	f080 809a 	bcs.w	800055c <__adddf3+0x240>
 8000428:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800042c:	bf08      	it	eq
 800042e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000432:	f150 0000 	adcs.w	r0, r0, #0
 8000436:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800043a:	ea41 0105 	orr.w	r1, r1, r5
 800043e:	bd30      	pop	{r4, r5, pc}
 8000440:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000444:	4140      	adcs	r0, r0
 8000446:	eb41 0101 	adc.w	r1, r1, r1
 800044a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800044e:	f1a4 0401 	sub.w	r4, r4, #1
 8000452:	d1e9      	bne.n	8000428 <__adddf3+0x10c>
 8000454:	f091 0f00 	teq	r1, #0
 8000458:	bf04      	itt	eq
 800045a:	4601      	moveq	r1, r0
 800045c:	2000      	moveq	r0, #0
 800045e:	fab1 f381 	clz	r3, r1
 8000462:	bf08      	it	eq
 8000464:	3320      	addeq	r3, #32
 8000466:	f1a3 030b 	sub.w	r3, r3, #11
 800046a:	f1b3 0220 	subs.w	r2, r3, #32
 800046e:	da0c      	bge.n	800048a <__adddf3+0x16e>
 8000470:	320c      	adds	r2, #12
 8000472:	dd08      	ble.n	8000486 <__adddf3+0x16a>
 8000474:	f102 0c14 	add.w	ip, r2, #20
 8000478:	f1c2 020c 	rsb	r2, r2, #12
 800047c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000480:	fa21 f102 	lsr.w	r1, r1, r2
 8000484:	e00c      	b.n	80004a0 <__adddf3+0x184>
 8000486:	f102 0214 	add.w	r2, r2, #20
 800048a:	bfd8      	it	le
 800048c:	f1c2 0c20 	rsble	ip, r2, #32
 8000490:	fa01 f102 	lsl.w	r1, r1, r2
 8000494:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000498:	bfdc      	itt	le
 800049a:	ea41 010c 	orrle.w	r1, r1, ip
 800049e:	4090      	lslle	r0, r2
 80004a0:	1ae4      	subs	r4, r4, r3
 80004a2:	bfa2      	ittt	ge
 80004a4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80004a8:	4329      	orrge	r1, r5
 80004aa:	bd30      	popge	{r4, r5, pc}
 80004ac:	ea6f 0404 	mvn.w	r4, r4
 80004b0:	3c1f      	subs	r4, #31
 80004b2:	da1c      	bge.n	80004ee <__adddf3+0x1d2>
 80004b4:	340c      	adds	r4, #12
 80004b6:	dc0e      	bgt.n	80004d6 <__adddf3+0x1ba>
 80004b8:	f104 0414 	add.w	r4, r4, #20
 80004bc:	f1c4 0220 	rsb	r2, r4, #32
 80004c0:	fa20 f004 	lsr.w	r0, r0, r4
 80004c4:	fa01 f302 	lsl.w	r3, r1, r2
 80004c8:	ea40 0003 	orr.w	r0, r0, r3
 80004cc:	fa21 f304 	lsr.w	r3, r1, r4
 80004d0:	ea45 0103 	orr.w	r1, r5, r3
 80004d4:	bd30      	pop	{r4, r5, pc}
 80004d6:	f1c4 040c 	rsb	r4, r4, #12
 80004da:	f1c4 0220 	rsb	r2, r4, #32
 80004de:	fa20 f002 	lsr.w	r0, r0, r2
 80004e2:	fa01 f304 	lsl.w	r3, r1, r4
 80004e6:	ea40 0003 	orr.w	r0, r0, r3
 80004ea:	4629      	mov	r1, r5
 80004ec:	bd30      	pop	{r4, r5, pc}
 80004ee:	fa21 f004 	lsr.w	r0, r1, r4
 80004f2:	4629      	mov	r1, r5
 80004f4:	bd30      	pop	{r4, r5, pc}
 80004f6:	f094 0f00 	teq	r4, #0
 80004fa:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004fe:	bf06      	itte	eq
 8000500:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000504:	3401      	addeq	r4, #1
 8000506:	3d01      	subne	r5, #1
 8000508:	e74e      	b.n	80003a8 <__adddf3+0x8c>
 800050a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800050e:	bf18      	it	ne
 8000510:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000514:	d029      	beq.n	800056a <__adddf3+0x24e>
 8000516:	ea94 0f05 	teq	r4, r5
 800051a:	bf08      	it	eq
 800051c:	ea90 0f02 	teqeq	r0, r2
 8000520:	d005      	beq.n	800052e <__adddf3+0x212>
 8000522:	ea54 0c00 	orrs.w	ip, r4, r0
 8000526:	bf04      	itt	eq
 8000528:	4619      	moveq	r1, r3
 800052a:	4610      	moveq	r0, r2
 800052c:	bd30      	pop	{r4, r5, pc}
 800052e:	ea91 0f03 	teq	r1, r3
 8000532:	bf1e      	ittt	ne
 8000534:	2100      	movne	r1, #0
 8000536:	2000      	movne	r0, #0
 8000538:	bd30      	popne	{r4, r5, pc}
 800053a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800053e:	d105      	bne.n	800054c <__adddf3+0x230>
 8000540:	0040      	lsls	r0, r0, #1
 8000542:	4149      	adcs	r1, r1
 8000544:	bf28      	it	cs
 8000546:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800054a:	bd30      	pop	{r4, r5, pc}
 800054c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000550:	bf3c      	itt	cc
 8000552:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000556:	bd30      	popcc	{r4, r5, pc}
 8000558:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800055c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000560:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000564:	f04f 0000 	mov.w	r0, #0
 8000568:	bd30      	pop	{r4, r5, pc}
 800056a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800056e:	bf1a      	itte	ne
 8000570:	4619      	movne	r1, r3
 8000572:	4610      	movne	r0, r2
 8000574:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000578:	bf1c      	itt	ne
 800057a:	460b      	movne	r3, r1
 800057c:	4602      	movne	r2, r0
 800057e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000582:	bf06      	itte	eq
 8000584:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000588:	ea91 0f03 	teqeq	r1, r3
 800058c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000590:	bd30      	pop	{r4, r5, pc}
 8000592:	bf00      	nop

08000594 <__aeabi_ui2d>:
 8000594:	f090 0f00 	teq	r0, #0
 8000598:	bf04      	itt	eq
 800059a:	2100      	moveq	r1, #0
 800059c:	4770      	bxeq	lr
 800059e:	b530      	push	{r4, r5, lr}
 80005a0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005a4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005a8:	f04f 0500 	mov.w	r5, #0
 80005ac:	f04f 0100 	mov.w	r1, #0
 80005b0:	e750      	b.n	8000454 <__adddf3+0x138>
 80005b2:	bf00      	nop

080005b4 <__aeabi_i2d>:
 80005b4:	f090 0f00 	teq	r0, #0
 80005b8:	bf04      	itt	eq
 80005ba:	2100      	moveq	r1, #0
 80005bc:	4770      	bxeq	lr
 80005be:	b530      	push	{r4, r5, lr}
 80005c0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005c4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005c8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80005cc:	bf48      	it	mi
 80005ce:	4240      	negmi	r0, r0
 80005d0:	f04f 0100 	mov.w	r1, #0
 80005d4:	e73e      	b.n	8000454 <__adddf3+0x138>
 80005d6:	bf00      	nop

080005d8 <__aeabi_f2d>:
 80005d8:	0042      	lsls	r2, r0, #1
 80005da:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005de:	ea4f 0131 	mov.w	r1, r1, rrx
 80005e2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005e6:	bf1f      	itttt	ne
 80005e8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005ec:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005f0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005f4:	4770      	bxne	lr
 80005f6:	f092 0f00 	teq	r2, #0
 80005fa:	bf14      	ite	ne
 80005fc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000600:	4770      	bxeq	lr
 8000602:	b530      	push	{r4, r5, lr}
 8000604:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000608:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800060c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000610:	e720      	b.n	8000454 <__adddf3+0x138>
 8000612:	bf00      	nop

08000614 <__aeabi_ul2d>:
 8000614:	ea50 0201 	orrs.w	r2, r0, r1
 8000618:	bf08      	it	eq
 800061a:	4770      	bxeq	lr
 800061c:	b530      	push	{r4, r5, lr}
 800061e:	f04f 0500 	mov.w	r5, #0
 8000622:	e00a      	b.n	800063a <__aeabi_l2d+0x16>

08000624 <__aeabi_l2d>:
 8000624:	ea50 0201 	orrs.w	r2, r0, r1
 8000628:	bf08      	it	eq
 800062a:	4770      	bxeq	lr
 800062c:	b530      	push	{r4, r5, lr}
 800062e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000632:	d502      	bpl.n	800063a <__aeabi_l2d+0x16>
 8000634:	4240      	negs	r0, r0
 8000636:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800063a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800063e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000642:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000646:	f43f aedc 	beq.w	8000402 <__adddf3+0xe6>
 800064a:	f04f 0203 	mov.w	r2, #3
 800064e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000652:	bf18      	it	ne
 8000654:	3203      	addne	r2, #3
 8000656:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800065a:	bf18      	it	ne
 800065c:	3203      	addne	r2, #3
 800065e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000662:	f1c2 0320 	rsb	r3, r2, #32
 8000666:	fa00 fc03 	lsl.w	ip, r0, r3
 800066a:	fa20 f002 	lsr.w	r0, r0, r2
 800066e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000672:	ea40 000e 	orr.w	r0, r0, lr
 8000676:	fa21 f102 	lsr.w	r1, r1, r2
 800067a:	4414      	add	r4, r2
 800067c:	e6c1      	b.n	8000402 <__adddf3+0xe6>
 800067e:	bf00      	nop

08000680 <__aeabi_dmul>:
 8000680:	b570      	push	{r4, r5, r6, lr}
 8000682:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000686:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800068a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800068e:	bf1d      	ittte	ne
 8000690:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000694:	ea94 0f0c 	teqne	r4, ip
 8000698:	ea95 0f0c 	teqne	r5, ip
 800069c:	f000 f8de 	bleq	800085c <__aeabi_dmul+0x1dc>
 80006a0:	442c      	add	r4, r5
 80006a2:	ea81 0603 	eor.w	r6, r1, r3
 80006a6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80006aa:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80006ae:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80006b2:	bf18      	it	ne
 80006b4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80006b8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006bc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80006c0:	d038      	beq.n	8000734 <__aeabi_dmul+0xb4>
 80006c2:	fba0 ce02 	umull	ip, lr, r0, r2
 80006c6:	f04f 0500 	mov.w	r5, #0
 80006ca:	fbe1 e502 	umlal	lr, r5, r1, r2
 80006ce:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80006d2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80006d6:	f04f 0600 	mov.w	r6, #0
 80006da:	fbe1 5603 	umlal	r5, r6, r1, r3
 80006de:	f09c 0f00 	teq	ip, #0
 80006e2:	bf18      	it	ne
 80006e4:	f04e 0e01 	orrne.w	lr, lr, #1
 80006e8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006ec:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006f0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006f4:	d204      	bcs.n	8000700 <__aeabi_dmul+0x80>
 80006f6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006fa:	416d      	adcs	r5, r5
 80006fc:	eb46 0606 	adc.w	r6, r6, r6
 8000700:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000704:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000708:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800070c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000710:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000714:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000718:	bf88      	it	hi
 800071a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800071e:	d81e      	bhi.n	800075e <__aeabi_dmul+0xde>
 8000720:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000724:	bf08      	it	eq
 8000726:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800072a:	f150 0000 	adcs.w	r0, r0, #0
 800072e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000732:	bd70      	pop	{r4, r5, r6, pc}
 8000734:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000738:	ea46 0101 	orr.w	r1, r6, r1
 800073c:	ea40 0002 	orr.w	r0, r0, r2
 8000740:	ea81 0103 	eor.w	r1, r1, r3
 8000744:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000748:	bfc2      	ittt	gt
 800074a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800074e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000752:	bd70      	popgt	{r4, r5, r6, pc}
 8000754:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000758:	f04f 0e00 	mov.w	lr, #0
 800075c:	3c01      	subs	r4, #1
 800075e:	f300 80ab 	bgt.w	80008b8 <__aeabi_dmul+0x238>
 8000762:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000766:	bfde      	ittt	le
 8000768:	2000      	movle	r0, #0
 800076a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800076e:	bd70      	pople	{r4, r5, r6, pc}
 8000770:	f1c4 0400 	rsb	r4, r4, #0
 8000774:	3c20      	subs	r4, #32
 8000776:	da35      	bge.n	80007e4 <__aeabi_dmul+0x164>
 8000778:	340c      	adds	r4, #12
 800077a:	dc1b      	bgt.n	80007b4 <__aeabi_dmul+0x134>
 800077c:	f104 0414 	add.w	r4, r4, #20
 8000780:	f1c4 0520 	rsb	r5, r4, #32
 8000784:	fa00 f305 	lsl.w	r3, r0, r5
 8000788:	fa20 f004 	lsr.w	r0, r0, r4
 800078c:	fa01 f205 	lsl.w	r2, r1, r5
 8000790:	ea40 0002 	orr.w	r0, r0, r2
 8000794:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000798:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800079c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80007a0:	fa21 f604 	lsr.w	r6, r1, r4
 80007a4:	eb42 0106 	adc.w	r1, r2, r6
 80007a8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007ac:	bf08      	it	eq
 80007ae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007b2:	bd70      	pop	{r4, r5, r6, pc}
 80007b4:	f1c4 040c 	rsb	r4, r4, #12
 80007b8:	f1c4 0520 	rsb	r5, r4, #32
 80007bc:	fa00 f304 	lsl.w	r3, r0, r4
 80007c0:	fa20 f005 	lsr.w	r0, r0, r5
 80007c4:	fa01 f204 	lsl.w	r2, r1, r4
 80007c8:	ea40 0002 	orr.w	r0, r0, r2
 80007cc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007d0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80007d4:	f141 0100 	adc.w	r1, r1, #0
 80007d8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007dc:	bf08      	it	eq
 80007de:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007e2:	bd70      	pop	{r4, r5, r6, pc}
 80007e4:	f1c4 0520 	rsb	r5, r4, #32
 80007e8:	fa00 f205 	lsl.w	r2, r0, r5
 80007ec:	ea4e 0e02 	orr.w	lr, lr, r2
 80007f0:	fa20 f304 	lsr.w	r3, r0, r4
 80007f4:	fa01 f205 	lsl.w	r2, r1, r5
 80007f8:	ea43 0302 	orr.w	r3, r3, r2
 80007fc:	fa21 f004 	lsr.w	r0, r1, r4
 8000800:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000804:	fa21 f204 	lsr.w	r2, r1, r4
 8000808:	ea20 0002 	bic.w	r0, r0, r2
 800080c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000810:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000814:	bf08      	it	eq
 8000816:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800081a:	bd70      	pop	{r4, r5, r6, pc}
 800081c:	f094 0f00 	teq	r4, #0
 8000820:	d10f      	bne.n	8000842 <__aeabi_dmul+0x1c2>
 8000822:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000826:	0040      	lsls	r0, r0, #1
 8000828:	eb41 0101 	adc.w	r1, r1, r1
 800082c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000830:	bf08      	it	eq
 8000832:	3c01      	subeq	r4, #1
 8000834:	d0f7      	beq.n	8000826 <__aeabi_dmul+0x1a6>
 8000836:	ea41 0106 	orr.w	r1, r1, r6
 800083a:	f095 0f00 	teq	r5, #0
 800083e:	bf18      	it	ne
 8000840:	4770      	bxne	lr
 8000842:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000846:	0052      	lsls	r2, r2, #1
 8000848:	eb43 0303 	adc.w	r3, r3, r3
 800084c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000850:	bf08      	it	eq
 8000852:	3d01      	subeq	r5, #1
 8000854:	d0f7      	beq.n	8000846 <__aeabi_dmul+0x1c6>
 8000856:	ea43 0306 	orr.w	r3, r3, r6
 800085a:	4770      	bx	lr
 800085c:	ea94 0f0c 	teq	r4, ip
 8000860:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000864:	bf18      	it	ne
 8000866:	ea95 0f0c 	teqne	r5, ip
 800086a:	d00c      	beq.n	8000886 <__aeabi_dmul+0x206>
 800086c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000870:	bf18      	it	ne
 8000872:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000876:	d1d1      	bne.n	800081c <__aeabi_dmul+0x19c>
 8000878:	ea81 0103 	eor.w	r1, r1, r3
 800087c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000880:	f04f 0000 	mov.w	r0, #0
 8000884:	bd70      	pop	{r4, r5, r6, pc}
 8000886:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800088a:	bf06      	itte	eq
 800088c:	4610      	moveq	r0, r2
 800088e:	4619      	moveq	r1, r3
 8000890:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000894:	d019      	beq.n	80008ca <__aeabi_dmul+0x24a>
 8000896:	ea94 0f0c 	teq	r4, ip
 800089a:	d102      	bne.n	80008a2 <__aeabi_dmul+0x222>
 800089c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80008a0:	d113      	bne.n	80008ca <__aeabi_dmul+0x24a>
 80008a2:	ea95 0f0c 	teq	r5, ip
 80008a6:	d105      	bne.n	80008b4 <__aeabi_dmul+0x234>
 80008a8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80008ac:	bf1c      	itt	ne
 80008ae:	4610      	movne	r0, r2
 80008b0:	4619      	movne	r1, r3
 80008b2:	d10a      	bne.n	80008ca <__aeabi_dmul+0x24a>
 80008b4:	ea81 0103 	eor.w	r1, r1, r3
 80008b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80008bc:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80008c0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80008c4:	f04f 0000 	mov.w	r0, #0
 80008c8:	bd70      	pop	{r4, r5, r6, pc}
 80008ca:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80008ce:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80008d2:	bd70      	pop	{r4, r5, r6, pc}

080008d4 <__aeabi_ddiv>:
 80008d4:	b570      	push	{r4, r5, r6, lr}
 80008d6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80008da:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80008de:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80008e2:	bf1d      	ittte	ne
 80008e4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008e8:	ea94 0f0c 	teqne	r4, ip
 80008ec:	ea95 0f0c 	teqne	r5, ip
 80008f0:	f000 f8a7 	bleq	8000a42 <__aeabi_ddiv+0x16e>
 80008f4:	eba4 0405 	sub.w	r4, r4, r5
 80008f8:	ea81 0e03 	eor.w	lr, r1, r3
 80008fc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000900:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000904:	f000 8088 	beq.w	8000a18 <__aeabi_ddiv+0x144>
 8000908:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800090c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000910:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000914:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000918:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800091c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000920:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000924:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000928:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800092c:	429d      	cmp	r5, r3
 800092e:	bf08      	it	eq
 8000930:	4296      	cmpeq	r6, r2
 8000932:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000936:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800093a:	d202      	bcs.n	8000942 <__aeabi_ddiv+0x6e>
 800093c:	085b      	lsrs	r3, r3, #1
 800093e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000942:	1ab6      	subs	r6, r6, r2
 8000944:	eb65 0503 	sbc.w	r5, r5, r3
 8000948:	085b      	lsrs	r3, r3, #1
 800094a:	ea4f 0232 	mov.w	r2, r2, rrx
 800094e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000952:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000956:	ebb6 0e02 	subs.w	lr, r6, r2
 800095a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800095e:	bf22      	ittt	cs
 8000960:	1ab6      	subcs	r6, r6, r2
 8000962:	4675      	movcs	r5, lr
 8000964:	ea40 000c 	orrcs.w	r0, r0, ip
 8000968:	085b      	lsrs	r3, r3, #1
 800096a:	ea4f 0232 	mov.w	r2, r2, rrx
 800096e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000972:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000976:	bf22      	ittt	cs
 8000978:	1ab6      	subcs	r6, r6, r2
 800097a:	4675      	movcs	r5, lr
 800097c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000980:	085b      	lsrs	r3, r3, #1
 8000982:	ea4f 0232 	mov.w	r2, r2, rrx
 8000986:	ebb6 0e02 	subs.w	lr, r6, r2
 800098a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800098e:	bf22      	ittt	cs
 8000990:	1ab6      	subcs	r6, r6, r2
 8000992:	4675      	movcs	r5, lr
 8000994:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000998:	085b      	lsrs	r3, r3, #1
 800099a:	ea4f 0232 	mov.w	r2, r2, rrx
 800099e:	ebb6 0e02 	subs.w	lr, r6, r2
 80009a2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80009a6:	bf22      	ittt	cs
 80009a8:	1ab6      	subcs	r6, r6, r2
 80009aa:	4675      	movcs	r5, lr
 80009ac:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80009b0:	ea55 0e06 	orrs.w	lr, r5, r6
 80009b4:	d018      	beq.n	80009e8 <__aeabi_ddiv+0x114>
 80009b6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80009ba:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80009be:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80009c2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80009c6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80009ca:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80009ce:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80009d2:	d1c0      	bne.n	8000956 <__aeabi_ddiv+0x82>
 80009d4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009d8:	d10b      	bne.n	80009f2 <__aeabi_ddiv+0x11e>
 80009da:	ea41 0100 	orr.w	r1, r1, r0
 80009de:	f04f 0000 	mov.w	r0, #0
 80009e2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80009e6:	e7b6      	b.n	8000956 <__aeabi_ddiv+0x82>
 80009e8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009ec:	bf04      	itt	eq
 80009ee:	4301      	orreq	r1, r0
 80009f0:	2000      	moveq	r0, #0
 80009f2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009f6:	bf88      	it	hi
 80009f8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009fc:	f63f aeaf 	bhi.w	800075e <__aeabi_dmul+0xde>
 8000a00:	ebb5 0c03 	subs.w	ip, r5, r3
 8000a04:	bf04      	itt	eq
 8000a06:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000a0a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000a0e:	f150 0000 	adcs.w	r0, r0, #0
 8000a12:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000a16:	bd70      	pop	{r4, r5, r6, pc}
 8000a18:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000a1c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000a20:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000a24:	bfc2      	ittt	gt
 8000a26:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000a2a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000a2e:	bd70      	popgt	{r4, r5, r6, pc}
 8000a30:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a34:	f04f 0e00 	mov.w	lr, #0
 8000a38:	3c01      	subs	r4, #1
 8000a3a:	e690      	b.n	800075e <__aeabi_dmul+0xde>
 8000a3c:	ea45 0e06 	orr.w	lr, r5, r6
 8000a40:	e68d      	b.n	800075e <__aeabi_dmul+0xde>
 8000a42:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a46:	ea94 0f0c 	teq	r4, ip
 8000a4a:	bf08      	it	eq
 8000a4c:	ea95 0f0c 	teqeq	r5, ip
 8000a50:	f43f af3b 	beq.w	80008ca <__aeabi_dmul+0x24a>
 8000a54:	ea94 0f0c 	teq	r4, ip
 8000a58:	d10a      	bne.n	8000a70 <__aeabi_ddiv+0x19c>
 8000a5a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a5e:	f47f af34 	bne.w	80008ca <__aeabi_dmul+0x24a>
 8000a62:	ea95 0f0c 	teq	r5, ip
 8000a66:	f47f af25 	bne.w	80008b4 <__aeabi_dmul+0x234>
 8000a6a:	4610      	mov	r0, r2
 8000a6c:	4619      	mov	r1, r3
 8000a6e:	e72c      	b.n	80008ca <__aeabi_dmul+0x24a>
 8000a70:	ea95 0f0c 	teq	r5, ip
 8000a74:	d106      	bne.n	8000a84 <__aeabi_ddiv+0x1b0>
 8000a76:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a7a:	f43f aefd 	beq.w	8000878 <__aeabi_dmul+0x1f8>
 8000a7e:	4610      	mov	r0, r2
 8000a80:	4619      	mov	r1, r3
 8000a82:	e722      	b.n	80008ca <__aeabi_dmul+0x24a>
 8000a84:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a88:	bf18      	it	ne
 8000a8a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a8e:	f47f aec5 	bne.w	800081c <__aeabi_dmul+0x19c>
 8000a92:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a96:	f47f af0d 	bne.w	80008b4 <__aeabi_dmul+0x234>
 8000a9a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a9e:	f47f aeeb 	bne.w	8000878 <__aeabi_dmul+0x1f8>
 8000aa2:	e712      	b.n	80008ca <__aeabi_dmul+0x24a>
	...

08000ab0 <__aeabi_d2uiz>:
 8000ab0:	004a      	lsls	r2, r1, #1
 8000ab2:	d211      	bcs.n	8000ad8 <__aeabi_d2uiz+0x28>
 8000ab4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000ab8:	d211      	bcs.n	8000ade <__aeabi_d2uiz+0x2e>
 8000aba:	d50d      	bpl.n	8000ad8 <__aeabi_d2uiz+0x28>
 8000abc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000ac0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000ac4:	d40e      	bmi.n	8000ae4 <__aeabi_d2uiz+0x34>
 8000ac6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000aca:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000ace:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000ad2:	fa23 f002 	lsr.w	r0, r3, r2
 8000ad6:	4770      	bx	lr
 8000ad8:	f04f 0000 	mov.w	r0, #0
 8000adc:	4770      	bx	lr
 8000ade:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000ae2:	d102      	bne.n	8000aea <__aeabi_d2uiz+0x3a>
 8000ae4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000ae8:	4770      	bx	lr
 8000aea:	f04f 0000 	mov.w	r0, #0
 8000aee:	4770      	bx	lr

08000af0 <__aeabi_d2f>:
 8000af0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000af4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000af8:	bf24      	itt	cs
 8000afa:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000afe:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000b02:	d90d      	bls.n	8000b20 <__aeabi_d2f+0x30>
 8000b04:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000b08:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000b0c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000b10:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000b14:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000b18:	bf08      	it	eq
 8000b1a:	f020 0001 	biceq.w	r0, r0, #1
 8000b1e:	4770      	bx	lr
 8000b20:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000b24:	d121      	bne.n	8000b6a <__aeabi_d2f+0x7a>
 8000b26:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000b2a:	bfbc      	itt	lt
 8000b2c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000b30:	4770      	bxlt	lr
 8000b32:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b36:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000b3a:	f1c2 0218 	rsb	r2, r2, #24
 8000b3e:	f1c2 0c20 	rsb	ip, r2, #32
 8000b42:	fa10 f30c 	lsls.w	r3, r0, ip
 8000b46:	fa20 f002 	lsr.w	r0, r0, r2
 8000b4a:	bf18      	it	ne
 8000b4c:	f040 0001 	orrne.w	r0, r0, #1
 8000b50:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b54:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000b58:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000b5c:	ea40 000c 	orr.w	r0, r0, ip
 8000b60:	fa23 f302 	lsr.w	r3, r3, r2
 8000b64:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000b68:	e7cc      	b.n	8000b04 <__aeabi_d2f+0x14>
 8000b6a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b6e:	d107      	bne.n	8000b80 <__aeabi_d2f+0x90>
 8000b70:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b74:	bf1e      	ittt	ne
 8000b76:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000b7a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000b7e:	4770      	bxne	lr
 8000b80:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000b84:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000b88:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b8c:	4770      	bx	lr
 8000b8e:	bf00      	nop

08000b90 <__aeabi_frsub>:
 8000b90:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000b94:	e002      	b.n	8000b9c <__addsf3>
 8000b96:	bf00      	nop

08000b98 <__aeabi_fsub>:
 8000b98:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000b9c <__addsf3>:
 8000b9c:	0042      	lsls	r2, r0, #1
 8000b9e:	bf1f      	itttt	ne
 8000ba0:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000ba4:	ea92 0f03 	teqne	r2, r3
 8000ba8:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000bac:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000bb0:	d06a      	beq.n	8000c88 <__addsf3+0xec>
 8000bb2:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000bb6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000bba:	bfc1      	itttt	gt
 8000bbc:	18d2      	addgt	r2, r2, r3
 8000bbe:	4041      	eorgt	r1, r0
 8000bc0:	4048      	eorgt	r0, r1
 8000bc2:	4041      	eorgt	r1, r0
 8000bc4:	bfb8      	it	lt
 8000bc6:	425b      	neglt	r3, r3
 8000bc8:	2b19      	cmp	r3, #25
 8000bca:	bf88      	it	hi
 8000bcc:	4770      	bxhi	lr
 8000bce:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000bd2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000bd6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000bda:	bf18      	it	ne
 8000bdc:	4240      	negne	r0, r0
 8000bde:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000be2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000be6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000bea:	bf18      	it	ne
 8000bec:	4249      	negne	r1, r1
 8000bee:	ea92 0f03 	teq	r2, r3
 8000bf2:	d03f      	beq.n	8000c74 <__addsf3+0xd8>
 8000bf4:	f1a2 0201 	sub.w	r2, r2, #1
 8000bf8:	fa41 fc03 	asr.w	ip, r1, r3
 8000bfc:	eb10 000c 	adds.w	r0, r0, ip
 8000c00:	f1c3 0320 	rsb	r3, r3, #32
 8000c04:	fa01 f103 	lsl.w	r1, r1, r3
 8000c08:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000c0c:	d502      	bpl.n	8000c14 <__addsf3+0x78>
 8000c0e:	4249      	negs	r1, r1
 8000c10:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000c14:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000c18:	d313      	bcc.n	8000c42 <__addsf3+0xa6>
 8000c1a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000c1e:	d306      	bcc.n	8000c2e <__addsf3+0x92>
 8000c20:	0840      	lsrs	r0, r0, #1
 8000c22:	ea4f 0131 	mov.w	r1, r1, rrx
 8000c26:	f102 0201 	add.w	r2, r2, #1
 8000c2a:	2afe      	cmp	r2, #254	; 0xfe
 8000c2c:	d251      	bcs.n	8000cd2 <__addsf3+0x136>
 8000c2e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000c32:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000c36:	bf08      	it	eq
 8000c38:	f020 0001 	biceq.w	r0, r0, #1
 8000c3c:	ea40 0003 	orr.w	r0, r0, r3
 8000c40:	4770      	bx	lr
 8000c42:	0049      	lsls	r1, r1, #1
 8000c44:	eb40 0000 	adc.w	r0, r0, r0
 8000c48:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8000c4c:	f1a2 0201 	sub.w	r2, r2, #1
 8000c50:	d1ed      	bne.n	8000c2e <__addsf3+0x92>
 8000c52:	fab0 fc80 	clz	ip, r0
 8000c56:	f1ac 0c08 	sub.w	ip, ip, #8
 8000c5a:	ebb2 020c 	subs.w	r2, r2, ip
 8000c5e:	fa00 f00c 	lsl.w	r0, r0, ip
 8000c62:	bfaa      	itet	ge
 8000c64:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000c68:	4252      	neglt	r2, r2
 8000c6a:	4318      	orrge	r0, r3
 8000c6c:	bfbc      	itt	lt
 8000c6e:	40d0      	lsrlt	r0, r2
 8000c70:	4318      	orrlt	r0, r3
 8000c72:	4770      	bx	lr
 8000c74:	f092 0f00 	teq	r2, #0
 8000c78:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000c7c:	bf06      	itte	eq
 8000c7e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000c82:	3201      	addeq	r2, #1
 8000c84:	3b01      	subne	r3, #1
 8000c86:	e7b5      	b.n	8000bf4 <__addsf3+0x58>
 8000c88:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000c8c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000c90:	bf18      	it	ne
 8000c92:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000c96:	d021      	beq.n	8000cdc <__addsf3+0x140>
 8000c98:	ea92 0f03 	teq	r2, r3
 8000c9c:	d004      	beq.n	8000ca8 <__addsf3+0x10c>
 8000c9e:	f092 0f00 	teq	r2, #0
 8000ca2:	bf08      	it	eq
 8000ca4:	4608      	moveq	r0, r1
 8000ca6:	4770      	bx	lr
 8000ca8:	ea90 0f01 	teq	r0, r1
 8000cac:	bf1c      	itt	ne
 8000cae:	2000      	movne	r0, #0
 8000cb0:	4770      	bxne	lr
 8000cb2:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000cb6:	d104      	bne.n	8000cc2 <__addsf3+0x126>
 8000cb8:	0040      	lsls	r0, r0, #1
 8000cba:	bf28      	it	cs
 8000cbc:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000cc0:	4770      	bx	lr
 8000cc2:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000cc6:	bf3c      	itt	cc
 8000cc8:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000ccc:	4770      	bxcc	lr
 8000cce:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000cd2:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000cd6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000cda:	4770      	bx	lr
 8000cdc:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000ce0:	bf16      	itet	ne
 8000ce2:	4608      	movne	r0, r1
 8000ce4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000ce8:	4601      	movne	r1, r0
 8000cea:	0242      	lsls	r2, r0, #9
 8000cec:	bf06      	itte	eq
 8000cee:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000cf2:	ea90 0f01 	teqeq	r0, r1
 8000cf6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000cfa:	4770      	bx	lr

08000cfc <__aeabi_ui2f>:
 8000cfc:	f04f 0300 	mov.w	r3, #0
 8000d00:	e004      	b.n	8000d0c <__aeabi_i2f+0x8>
 8000d02:	bf00      	nop

08000d04 <__aeabi_i2f>:
 8000d04:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000d08:	bf48      	it	mi
 8000d0a:	4240      	negmi	r0, r0
 8000d0c:	ea5f 0c00 	movs.w	ip, r0
 8000d10:	bf08      	it	eq
 8000d12:	4770      	bxeq	lr
 8000d14:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000d18:	4601      	mov	r1, r0
 8000d1a:	f04f 0000 	mov.w	r0, #0
 8000d1e:	e01c      	b.n	8000d5a <__aeabi_l2f+0x2a>

08000d20 <__aeabi_ul2f>:
 8000d20:	ea50 0201 	orrs.w	r2, r0, r1
 8000d24:	bf08      	it	eq
 8000d26:	4770      	bxeq	lr
 8000d28:	f04f 0300 	mov.w	r3, #0
 8000d2c:	e00a      	b.n	8000d44 <__aeabi_l2f+0x14>
 8000d2e:	bf00      	nop

08000d30 <__aeabi_l2f>:
 8000d30:	ea50 0201 	orrs.w	r2, r0, r1
 8000d34:	bf08      	it	eq
 8000d36:	4770      	bxeq	lr
 8000d38:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000d3c:	d502      	bpl.n	8000d44 <__aeabi_l2f+0x14>
 8000d3e:	4240      	negs	r0, r0
 8000d40:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000d44:	ea5f 0c01 	movs.w	ip, r1
 8000d48:	bf02      	ittt	eq
 8000d4a:	4684      	moveq	ip, r0
 8000d4c:	4601      	moveq	r1, r0
 8000d4e:	2000      	moveq	r0, #0
 8000d50:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000d54:	bf08      	it	eq
 8000d56:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000d5a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000d5e:	fabc f28c 	clz	r2, ip
 8000d62:	3a08      	subs	r2, #8
 8000d64:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000d68:	db10      	blt.n	8000d8c <__aeabi_l2f+0x5c>
 8000d6a:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d6e:	4463      	add	r3, ip
 8000d70:	fa00 fc02 	lsl.w	ip, r0, r2
 8000d74:	f1c2 0220 	rsb	r2, r2, #32
 8000d78:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000d7c:	fa20 f202 	lsr.w	r2, r0, r2
 8000d80:	eb43 0002 	adc.w	r0, r3, r2
 8000d84:	bf08      	it	eq
 8000d86:	f020 0001 	biceq.w	r0, r0, #1
 8000d8a:	4770      	bx	lr
 8000d8c:	f102 0220 	add.w	r2, r2, #32
 8000d90:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d94:	f1c2 0220 	rsb	r2, r2, #32
 8000d98:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000d9c:	fa21 f202 	lsr.w	r2, r1, r2
 8000da0:	eb43 0002 	adc.w	r0, r3, r2
 8000da4:	bf08      	it	eq
 8000da6:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000daa:	4770      	bx	lr
 8000dac:	0000      	movs	r0, r0
	...

08000db0 <__aeabi_fmul>:
 8000db0:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000db4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000db8:	bf1e      	ittt	ne
 8000dba:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000dbe:	ea92 0f0c 	teqne	r2, ip
 8000dc2:	ea93 0f0c 	teqne	r3, ip
 8000dc6:	d06f      	beq.n	8000ea8 <__aeabi_fmul+0xf8>
 8000dc8:	441a      	add	r2, r3
 8000dca:	ea80 0c01 	eor.w	ip, r0, r1
 8000dce:	0240      	lsls	r0, r0, #9
 8000dd0:	bf18      	it	ne
 8000dd2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000dd6:	d01e      	beq.n	8000e16 <__aeabi_fmul+0x66>
 8000dd8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000ddc:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000de0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000de4:	fba0 3101 	umull	r3, r1, r0, r1
 8000de8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000dec:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000df0:	bf3e      	ittt	cc
 8000df2:	0049      	lslcc	r1, r1, #1
 8000df4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000df8:	005b      	lslcc	r3, r3, #1
 8000dfa:	ea40 0001 	orr.w	r0, r0, r1
 8000dfe:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000e02:	2afd      	cmp	r2, #253	; 0xfd
 8000e04:	d81d      	bhi.n	8000e42 <__aeabi_fmul+0x92>
 8000e06:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000e0a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000e0e:	bf08      	it	eq
 8000e10:	f020 0001 	biceq.w	r0, r0, #1
 8000e14:	4770      	bx	lr
 8000e16:	f090 0f00 	teq	r0, #0
 8000e1a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000e1e:	bf08      	it	eq
 8000e20:	0249      	lsleq	r1, r1, #9
 8000e22:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000e26:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000e2a:	3a7f      	subs	r2, #127	; 0x7f
 8000e2c:	bfc2      	ittt	gt
 8000e2e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000e32:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000e36:	4770      	bxgt	lr
 8000e38:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000e3c:	f04f 0300 	mov.w	r3, #0
 8000e40:	3a01      	subs	r2, #1
 8000e42:	dc5d      	bgt.n	8000f00 <__aeabi_fmul+0x150>
 8000e44:	f112 0f19 	cmn.w	r2, #25
 8000e48:	bfdc      	itt	le
 8000e4a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000e4e:	4770      	bxle	lr
 8000e50:	f1c2 0200 	rsb	r2, r2, #0
 8000e54:	0041      	lsls	r1, r0, #1
 8000e56:	fa21 f102 	lsr.w	r1, r1, r2
 8000e5a:	f1c2 0220 	rsb	r2, r2, #32
 8000e5e:	fa00 fc02 	lsl.w	ip, r0, r2
 8000e62:	ea5f 0031 	movs.w	r0, r1, rrx
 8000e66:	f140 0000 	adc.w	r0, r0, #0
 8000e6a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000e6e:	bf08      	it	eq
 8000e70:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000e74:	4770      	bx	lr
 8000e76:	f092 0f00 	teq	r2, #0
 8000e7a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000e7e:	bf02      	ittt	eq
 8000e80:	0040      	lsleq	r0, r0, #1
 8000e82:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000e86:	3a01      	subeq	r2, #1
 8000e88:	d0f9      	beq.n	8000e7e <__aeabi_fmul+0xce>
 8000e8a:	ea40 000c 	orr.w	r0, r0, ip
 8000e8e:	f093 0f00 	teq	r3, #0
 8000e92:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000e96:	bf02      	ittt	eq
 8000e98:	0049      	lsleq	r1, r1, #1
 8000e9a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000e9e:	3b01      	subeq	r3, #1
 8000ea0:	d0f9      	beq.n	8000e96 <__aeabi_fmul+0xe6>
 8000ea2:	ea41 010c 	orr.w	r1, r1, ip
 8000ea6:	e78f      	b.n	8000dc8 <__aeabi_fmul+0x18>
 8000ea8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000eac:	ea92 0f0c 	teq	r2, ip
 8000eb0:	bf18      	it	ne
 8000eb2:	ea93 0f0c 	teqne	r3, ip
 8000eb6:	d00a      	beq.n	8000ece <__aeabi_fmul+0x11e>
 8000eb8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000ebc:	bf18      	it	ne
 8000ebe:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000ec2:	d1d8      	bne.n	8000e76 <__aeabi_fmul+0xc6>
 8000ec4:	ea80 0001 	eor.w	r0, r0, r1
 8000ec8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000ecc:	4770      	bx	lr
 8000ece:	f090 0f00 	teq	r0, #0
 8000ed2:	bf17      	itett	ne
 8000ed4:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000ed8:	4608      	moveq	r0, r1
 8000eda:	f091 0f00 	teqne	r1, #0
 8000ede:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000ee2:	d014      	beq.n	8000f0e <__aeabi_fmul+0x15e>
 8000ee4:	ea92 0f0c 	teq	r2, ip
 8000ee8:	d101      	bne.n	8000eee <__aeabi_fmul+0x13e>
 8000eea:	0242      	lsls	r2, r0, #9
 8000eec:	d10f      	bne.n	8000f0e <__aeabi_fmul+0x15e>
 8000eee:	ea93 0f0c 	teq	r3, ip
 8000ef2:	d103      	bne.n	8000efc <__aeabi_fmul+0x14c>
 8000ef4:	024b      	lsls	r3, r1, #9
 8000ef6:	bf18      	it	ne
 8000ef8:	4608      	movne	r0, r1
 8000efa:	d108      	bne.n	8000f0e <__aeabi_fmul+0x15e>
 8000efc:	ea80 0001 	eor.w	r0, r0, r1
 8000f00:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000f04:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f08:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f0c:	4770      	bx	lr
 8000f0e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f12:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000f16:	4770      	bx	lr

08000f18 <__aeabi_fdiv>:
 8000f18:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000f1c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000f20:	bf1e      	ittt	ne
 8000f22:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000f26:	ea92 0f0c 	teqne	r2, ip
 8000f2a:	ea93 0f0c 	teqne	r3, ip
 8000f2e:	d069      	beq.n	8001004 <__aeabi_fdiv+0xec>
 8000f30:	eba2 0203 	sub.w	r2, r2, r3
 8000f34:	ea80 0c01 	eor.w	ip, r0, r1
 8000f38:	0249      	lsls	r1, r1, #9
 8000f3a:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000f3e:	d037      	beq.n	8000fb0 <__aeabi_fdiv+0x98>
 8000f40:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000f44:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000f48:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000f4c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000f50:	428b      	cmp	r3, r1
 8000f52:	bf38      	it	cc
 8000f54:	005b      	lslcc	r3, r3, #1
 8000f56:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000f5a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000f5e:	428b      	cmp	r3, r1
 8000f60:	bf24      	itt	cs
 8000f62:	1a5b      	subcs	r3, r3, r1
 8000f64:	ea40 000c 	orrcs.w	r0, r0, ip
 8000f68:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000f6c:	bf24      	itt	cs
 8000f6e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000f72:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000f76:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000f7a:	bf24      	itt	cs
 8000f7c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000f80:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000f84:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000f88:	bf24      	itt	cs
 8000f8a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000f8e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000f92:	011b      	lsls	r3, r3, #4
 8000f94:	bf18      	it	ne
 8000f96:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000f9a:	d1e0      	bne.n	8000f5e <__aeabi_fdiv+0x46>
 8000f9c:	2afd      	cmp	r2, #253	; 0xfd
 8000f9e:	f63f af50 	bhi.w	8000e42 <__aeabi_fmul+0x92>
 8000fa2:	428b      	cmp	r3, r1
 8000fa4:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000fa8:	bf08      	it	eq
 8000faa:	f020 0001 	biceq.w	r0, r0, #1
 8000fae:	4770      	bx	lr
 8000fb0:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000fb4:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000fb8:	327f      	adds	r2, #127	; 0x7f
 8000fba:	bfc2      	ittt	gt
 8000fbc:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000fc0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000fc4:	4770      	bxgt	lr
 8000fc6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000fca:	f04f 0300 	mov.w	r3, #0
 8000fce:	3a01      	subs	r2, #1
 8000fd0:	e737      	b.n	8000e42 <__aeabi_fmul+0x92>
 8000fd2:	f092 0f00 	teq	r2, #0
 8000fd6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000fda:	bf02      	ittt	eq
 8000fdc:	0040      	lsleq	r0, r0, #1
 8000fde:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000fe2:	3a01      	subeq	r2, #1
 8000fe4:	d0f9      	beq.n	8000fda <__aeabi_fdiv+0xc2>
 8000fe6:	ea40 000c 	orr.w	r0, r0, ip
 8000fea:	f093 0f00 	teq	r3, #0
 8000fee:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000ff2:	bf02      	ittt	eq
 8000ff4:	0049      	lsleq	r1, r1, #1
 8000ff6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000ffa:	3b01      	subeq	r3, #1
 8000ffc:	d0f9      	beq.n	8000ff2 <__aeabi_fdiv+0xda>
 8000ffe:	ea41 010c 	orr.w	r1, r1, ip
 8001002:	e795      	b.n	8000f30 <__aeabi_fdiv+0x18>
 8001004:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8001008:	ea92 0f0c 	teq	r2, ip
 800100c:	d108      	bne.n	8001020 <__aeabi_fdiv+0x108>
 800100e:	0242      	lsls	r2, r0, #9
 8001010:	f47f af7d 	bne.w	8000f0e <__aeabi_fmul+0x15e>
 8001014:	ea93 0f0c 	teq	r3, ip
 8001018:	f47f af70 	bne.w	8000efc <__aeabi_fmul+0x14c>
 800101c:	4608      	mov	r0, r1
 800101e:	e776      	b.n	8000f0e <__aeabi_fmul+0x15e>
 8001020:	ea93 0f0c 	teq	r3, ip
 8001024:	d104      	bne.n	8001030 <__aeabi_fdiv+0x118>
 8001026:	024b      	lsls	r3, r1, #9
 8001028:	f43f af4c 	beq.w	8000ec4 <__aeabi_fmul+0x114>
 800102c:	4608      	mov	r0, r1
 800102e:	e76e      	b.n	8000f0e <__aeabi_fmul+0x15e>
 8001030:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8001034:	bf18      	it	ne
 8001036:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800103a:	d1ca      	bne.n	8000fd2 <__aeabi_fdiv+0xba>
 800103c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8001040:	f47f af5c 	bne.w	8000efc <__aeabi_fmul+0x14c>
 8001044:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8001048:	f47f af3c 	bne.w	8000ec4 <__aeabi_fmul+0x114>
 800104c:	e75f      	b.n	8000f0e <__aeabi_fmul+0x15e>
 800104e:	bf00      	nop

08001050 <__aeabi_f2iz>:
 8001050:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8001054:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8001058:	d30f      	bcc.n	800107a <__aeabi_f2iz+0x2a>
 800105a:	f04f 039e 	mov.w	r3, #158	; 0x9e
 800105e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8001062:	d90d      	bls.n	8001080 <__aeabi_f2iz+0x30>
 8001064:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8001068:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800106c:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8001070:	fa23 f002 	lsr.w	r0, r3, r2
 8001074:	bf18      	it	ne
 8001076:	4240      	negne	r0, r0
 8001078:	4770      	bx	lr
 800107a:	f04f 0000 	mov.w	r0, #0
 800107e:	4770      	bx	lr
 8001080:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8001084:	d101      	bne.n	800108a <__aeabi_f2iz+0x3a>
 8001086:	0242      	lsls	r2, r0, #9
 8001088:	d105      	bne.n	8001096 <__aeabi_f2iz+0x46>
 800108a:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 800108e:	bf08      	it	eq
 8001090:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8001094:	4770      	bx	lr
 8001096:	f04f 0000 	mov.w	r0, #0
 800109a:	4770      	bx	lr
 800109c:	0000      	movs	r0, r0
	...

080010a0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80010a0:	4770      	bx	lr
 80010a2:	bf00      	nop
 80010a4:	f3af 8000 	nop.w
 80010a8:	f3af 8000 	nop.w
 80010ac:	f3af 8000 	nop.w

080010b0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80010b0:	4770      	bx	lr
 80010b2:	bf00      	nop
 80010b4:	f3af 8000 	nop.w
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80010c0:	e7fe      	b.n	80010c0 <__default_exit>
 80010c2:	bf00      	nop
 80010c4:	f3af 8000 	nop.w
 80010c8:	f3af 8000 	nop.w
 80010cc:	f3af 8000 	nop.w

080010d0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80010d0:	b4f0      	push	{r4, r5, r6, r7}
 80010d2:	4e13      	ldr	r6, [pc, #76]	; (8001120 <__init_ram_areas+0x50>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80010d4:	2500      	movs	r5, #0
 80010d6:	f106 0770 	add.w	r7, r6, #112	; 0x70
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 80010da:	f1a6 0110 	sub.w	r1, r6, #16
 80010de:	c91a      	ldmia	r1, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80010e0:	42a3      	cmp	r3, r4
 80010e2:	d20d      	bcs.n	8001100 <__init_ram_areas+0x30>
 80010e4:	3904      	subs	r1, #4
 80010e6:	461a      	mov	r2, r3
      *p = *tp;
 80010e8:	f851 0f04 	ldr.w	r0, [r1, #4]!
 80010ec:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80010f0:	42a2      	cmp	r2, r4
 80010f2:	d3f9      	bcc.n	80010e8 <__init_ram_areas+0x18>
 80010f4:	43da      	mvns	r2, r3
 80010f6:	4414      	add	r4, r2
 80010f8:	f024 0403 	bic.w	r4, r4, #3
 80010fc:	3404      	adds	r4, #4
 80010fe:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001100:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8001104:	4293      	cmp	r3, r2
 8001106:	d203      	bcs.n	8001110 <__init_ram_areas+0x40>
      *p = 0;
 8001108:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800110c:	4293      	cmp	r3, r2
 800110e:	d3fb      	bcc.n	8001108 <__init_ram_areas+0x38>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001110:	42be      	cmp	r6, r7
 8001112:	f106 0310 	add.w	r3, r6, #16
 8001116:	d201      	bcs.n	800111c <__init_ram_areas+0x4c>
 8001118:	461e      	mov	r6, r3
 800111a:	e7de      	b.n	80010da <__init_ram_areas+0xa>
#endif
}
 800111c:	bcf0      	pop	{r4, r5, r6, r7}
 800111e:	4770      	bx	lr
 8001120:	08005394 	.word	0x08005394
 8001124:	f3af 8000 	nop.w
 8001128:	f3af 8000 	nop.w
 800112c:	f3af 8000 	nop.w

08001130 <_unhandled_exception>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001130:	e7fe      	b.n	8001130 <_unhandled_exception>
 8001132:	bf00      	nop
 8001134:	f3af 8000 	nop.w
 8001138:	f3af 8000 	nop.w
 800113c:	f3af 8000 	nop.w

08001140 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001140:	e7fe      	b.n	8001140 <_idle_thread>
 8001142:	bf00      	nop
 8001144:	f3af 8000 	nop.w
 8001148:	f3af 8000 	nop.w
 800114c:	f3af 8000 	nop.w

08001150 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001150:	b570      	push	{r4, r5, r6, lr}
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001152:	4d25      	ldr	r5, [pc, #148]	; (80011e8 <chSysInit+0x98>)
 *
 * @special
 */
void chSysInit(void) {

  _scheduler_init();
 8001154:	f000 fa2c 	bl	80015b0 <_scheduler_init>
  _vt_init();
 8001158:	f000 f95a 	bl	8001410 <_vt_init>
  _trace_init();
 800115c:	f000 f8d8 	bl	8001310 <_trace_init>
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
  ch.dbg.lock_cnt = (cnt_t)0;
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8001160:	f000 fc9e 	bl	8001aa0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8001164:	f000 fcc4 	bl	8001af0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8001168:	f000 fd02 	bl	8001b70 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800116c:	f245 412c 	movw	r1, #21548	; 0x542c
 8001170:	4628      	mov	r0, r5
 8001172:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001176:	2280      	movs	r2, #128	; 0x80
 8001178:	f000 fb32 	bl	80017e0 <_thread_init>
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800117c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8001180:	f2ce 0300 	movt	r3, #57344	; 0xe000
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8001184:	2201      	movs	r2, #1
 8001186:	f880 2020 	strb.w	r2, [r0, #32]
 800118a:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800118c:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 8001190:	f44f 7240 	mov.w	r2, #768	; 0x300
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001194:	400c      	ands	r4, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001196:	f6a5 0538 	subw	r5, r5, #2104	; 0x838
  reg_value  =  (reg_value                                   |
 800119a:	f2c0 52fa 	movt	r2, #1530	; 0x5fa

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800119e:	f64e 51f0 	movw	r1, #60912	; 0xedf0
 80011a2:	4322      	orrs	r2, r4
 80011a4:	f2ce 0100 	movt	r1, #57344	; 0xe000
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 80011a8:	2600      	movs	r6, #0
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80011aa:	61a8      	str	r0, [r5, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 80011ac:	61c6      	str	r6, [r0, #28]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80011ae:	60da      	str	r2, [r3, #12]
 80011b0:	68c8      	ldr	r0, [r1, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80011b2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80011b6:	f2ce 0200 	movt	r2, #57344	; 0xe000

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80011ba:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
 80011be:	60c8      	str	r0, [r1, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80011c0:	6814      	ldr	r4, [r2, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80011c2:	2010      	movs	r0, #16
 80011c4:	f044 0401 	orr.w	r4, r4, #1
 80011c8:	2120      	movs	r1, #32
 80011ca:	6014      	str	r4, [r2, #0]
 80011cc:	77d8      	strb	r0, [r3, #31]
 80011ce:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80011d2:	f386 8811 	msr	BASEPRI, r6
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011d6:	b662      	cpsie	i
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 80011d8:	f245 400c 	movw	r0, #21516	; 0x540c
 80011dc:	f6c0 0000 	movt	r0, #2048	; 0x800
  }
#endif
}
 80011e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 80011e4:	f000 bb6c 	b.w	80018c0 <chThdCreate>
 80011e8:	20001190 	.word	0x20001190
 80011ec:	f3af 8000 	nop.w

080011f0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 80011f0:	b508      	push	{r3, lr}
 80011f2:	4604      	mov	r4, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011f4:	b672      	cpsid	i

  /* Halt hook code, usually empty.*/
  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Logging the event.*/
  _trace_halt(reason);
 80011f6:	f000 f8f3 	bl	80013e0 <_trace_halt>

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80011fa:	f640 1358 	movw	r3, #2392	; 0x958
 80011fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001202:	62dc      	str	r4, [r3, #44]	; 0x2c
 8001204:	e7fe      	b.n	8001204 <chSysHalt+0x14>
 8001206:	bf00      	nop
 8001208:	f3af 8000 	nop.w
 800120c:	f3af 8000 	nop.w

08001210 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001210:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8001214:	f640 1558 	movw	r5, #2392	; 0x958
 8001218:	f2c2 0500 	movt	r5, #8192	; 0x2000
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800121c:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 8001220:	69ec      	ldr	r4, [r5, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8001222:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8001224:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8001228:	68a2      	ldr	r2, [r4, #8]
 800122a:	1a58      	subs	r0, r3, r1
 800122c:	4290      	cmp	r0, r2
 800122e:	f105 091c 	add.w	r9, r5, #28
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8001232:	bf24      	itt	cs
 8001234:	2600      	movcs	r6, #0
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001236:	2720      	movcs	r7, #32

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8001238:	d318      	bcc.n	800126c <chSysTimerHandlerI+0x5c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800123a:	6823      	ldr	r3, [r4, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 800123c:	f8d4 a00c 	ldr.w	sl, [r4, #12]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8001240:	440a      	add	r2, r1
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001242:	454b      	cmp	r3, r9
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8001244:	62aa      	str	r2, [r5, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001246:	f8c3 9004 	str.w	r9, [r3, #4]
    ch.vtlist.next = vtp->next;
 800124a:	61eb      	str	r3, [r5, #28]
    fn = vtp->func;
    vtp->func = NULL;
 800124c:	60e6      	str	r6, [r4, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800124e:	d019      	beq.n	8001284 <chSysTimerHandlerI+0x74>
 8001250:	f386 8811 	msr	BASEPRI, r6
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8001254:	6920      	ldr	r0, [r4, #16]
 8001256:	47d0      	blx	sl
 8001258:	f387 8811 	msr	BASEPRI, r7
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 800125c:	69ec      	ldr	r4, [r5, #28]
 800125e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8001262:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8001264:	68a2      	ldr	r2, [r4, #8]
 8001266:	1a58      	subs	r0, r3, r1
 8001268:	4282      	cmp	r2, r0
 800126a:	d9e6      	bls.n	800123a <chSysTimerHandlerI+0x2a>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800126c:	454c      	cmp	r4, r9
 800126e:	d00c      	beq.n	800128a <chSysTimerHandlerI+0x7a>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8001270:	440a      	add	r2, r1
 8001272:	1ad0      	subs	r0, r2, r3
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001274:	2801      	cmp	r0, #1
 8001276:	bf98      	it	ls
 8001278:	2002      	movls	r0, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800127a:	4418      	add	r0, r3
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800127c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001280:	f000 bcfe 	b.w	8001c80 <stSetAlarm>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8001284:	f000 fcf4 	bl	8001c70 <stStopAlarm>
 8001288:	e7e2      	b.n	8001250 <chSysTimerHandlerI+0x40>
 800128a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800128e:	bf00      	nop

08001290 <chSysGetStatusAndLockX>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8001290:	f3ef 8011 	mrs	r0, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8001294:	b920      	cbnz	r0, 80012a0 <chSysGetStatusAndLockX+0x10>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001296:	f3ef 8305 	mrs	r3, IPSR
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800129a:	2320      	movs	r3, #32
 800129c:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 80012a0:	4770      	bx	lr
 80012a2:	bf00      	nop
 80012a4:	f3af 8000 	nop.w
 80012a8:	f3af 8000 	nop.w
 80012ac:	f3af 8000 	nop.w

080012b0 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80012b0:	b510      	push	{r4, lr}

  if (port_irq_enabled(sts)) {
 80012b2:	b960      	cbnz	r0, 80012ce <chSysRestoreStatusX+0x1e>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80012b4:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80012b8:	f3c4 0408 	ubfx	r4, r4, #0, #9
    if (port_is_isr_context()) {
 80012bc:	b11c      	cbz	r4, 80012c6 <chSysRestoreStatusX+0x16>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80012be:	2300      	movs	r3, #0
 80012c0:	f383 8811 	msr	BASEPRI, r3
 80012c4:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 80012c6:	f000 fa53 	bl	8001770 <chSchRescheduleS>
 80012ca:	f384 8811 	msr	BASEPRI, r4
 80012ce:	bd10      	pop	{r4, pc}

080012d0 <trace_next>:
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80012d0:	f640 1358 	movw	r3, #2392	; 0x958
 80012d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012d8:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80012dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80012de:	6a48      	ldr	r0, [r1, #36]	; 0x24
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 80012e0:	6811      	ldr	r1, [r2, #0]
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80012e2:	6050      	str	r0, [r2, #4]
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80012e4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80012e8:	f2ce 0000 	movt	r0, #57344	; 0xe000
 80012ec:	6840      	ldr	r0, [r0, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 80012ee:	f360 211f 	bfi	r1, r0, #8, #24
 80012f2:	f842 1b10 	str.w	r1, [r2], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 80012f6:	f603 0138 	addw	r1, r3, #2104	; 0x838
 80012fa:	428a      	cmp	r2, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 80012fc:	bf28      	it	cs
 80012fe:	f103 0238 	addcs.w	r2, r3, #56	; 0x38
 8001302:	635a      	str	r2, [r3, #52]	; 0x34
 8001304:	4770      	bx	lr
 8001306:	bf00      	nop
 8001308:	f3af 8000 	nop.w
 800130c:	f3af 8000 	nop.w

08001310 <_trace_init>:
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8001310:	f640 1058 	movw	r0, #2392	; 0x958
 8001314:	f2c2 0000 	movt	r0, #8192	; 0x2000
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8001318:	2180      	movs	r1, #128	; 0x80
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800131a:	f100 0238 	add.w	r2, r0, #56	; 0x38
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 800131e:	2300      	movs	r3, #0
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8001320:	8641      	strh	r1, [r0, #50]	; 0x32
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8001322:	6342      	str	r2, [r0, #52]	; 0x34
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8001324:	8603      	strh	r3, [r0, #48]	; 0x30
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8001326:	1cda      	adds	r2, r3, #3
 8001328:	eb00 1202 	add.w	r2, r0, r2, lsl #4
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800132c:	3301      	adds	r3, #1
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800132e:	7a11      	ldrb	r1, [r2, #8]
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001330:	2b80      	cmp	r3, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8001332:	f36f 0102 	bfc	r1, #0, #3
 8001336:	7211      	strb	r1, [r2, #8]
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001338:	d1f5      	bne.n	8001326 <_trace_init+0x16>
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
  }
}
 800133a:	4770      	bx	lr
 800133c:	f3af 8000 	nop.w

08001340 <_trace_switch>:
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8001340:	f640 1358 	movw	r3, #2392	; 0x958
 8001344:	f2c2 0300 	movt	r3, #8192	; 0x2000
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 8001348:	b410      	push	{r4}

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800134a:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 800134c:	07d2      	lsls	r2, r2, #31
 800134e:	d502      	bpl.n	8001356 <_trace_switch+0x16>
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
    trace_next();
  }
}
 8001350:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001354:	4770      	bx	lr
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8001356:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8001358:	699c      	ldr	r4, [r3, #24]
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800135a:	7813      	ldrb	r3, [r2, #0]
 800135c:	2001      	movs	r0, #1
 800135e:	f360 0302 	bfi	r3, r0, #0, #3
 8001362:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8001364:	f891 0020 	ldrb.w	r0, [r1, #32]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8001368:	6094      	str	r4, [r2, #8]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800136a:	f360 03c7 	bfi	r3, r0, #3, #5
 800136e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8001370:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001372:	60d3      	str	r3, [r2, #12]
    trace_next();
  }
}
 8001374:	f85d 4b04 	ldr.w	r4, [sp], #4
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
    trace_next();
 8001378:	f7ff bfaa 	b.w	80012d0 <trace_next>
 800137c:	f3af 8000 	nop.w

08001380 <_trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 8001380:	b508      	push	{r3, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001382:	f640 1358 	movw	r3, #2392	; 0x958
 8001386:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800138a:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 800138c:	0791      	lsls	r1, r2, #30
 800138e:	d40b      	bmi.n	80013a8 <_trace_isr_enter+0x28>
 8001390:	2220      	movs	r2, #32
 8001392:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001396:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001398:	2202      	movs	r2, #2
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800139a:	6098      	str	r0, [r3, #8]
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800139c:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 800139e:	f7ff ff97 	bl	80012d0 <trace_next>
 80013a2:	2300      	movs	r3, #0
 80013a4:	f383 8811 	msr	BASEPRI, r3
 80013a8:	bd08      	pop	{r3, pc}
 80013aa:	bf00      	nop
 80013ac:	f3af 8000 	nop.w

080013b0 <_trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 80013b0:	b508      	push	{r3, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80013b2:	f640 1358 	movw	r3, #2392	; 0x958
 80013b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80013ba:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 80013bc:	0792      	lsls	r2, r2, #30
 80013be:	d40b      	bmi.n	80013d8 <_trace_isr_leave+0x28>
 80013c0:	2220      	movs	r2, #32
 80013c2:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80013c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80013c8:	2203      	movs	r2, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80013ca:	6098      	str	r0, [r3, #8]
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80013cc:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 80013ce:	f7ff ff7f 	bl	80012d0 <trace_next>
 80013d2:	2300      	movs	r3, #0
 80013d4:	f383 8811 	msr	BASEPRI, r3
 80013d8:	bd08      	pop	{r3, pc}
 80013da:	bf00      	nop
 80013dc:	f3af 8000 	nop.w

080013e0 <_trace_halt>:
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 80013e0:	f640 1358 	movw	r3, #2392	; 0x958
 80013e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80013e8:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 80013ea:	f002 0204 	and.w	r2, r2, #4
 80013ee:	b292      	uxth	r2, r2
 80013f0:	b102      	cbz	r2, 80013f4 <_trace_halt+0x14>
 80013f2:	4770      	bx	lr
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80013f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80013f6:	7819      	ldrb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 80013f8:	6098      	str	r0, [r3, #8]
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80013fa:	2004      	movs	r0, #4
 80013fc:	f360 0102 	bfi	r1, r0, #0, #3
    ch.dbg.trace_buffer.ptr->state         = 0;
 8001400:	f362 01c7 	bfi	r1, r2, #3, #5
 8001404:	7019      	strb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
    trace_next();
 8001406:	f7ff bf63 	b.w	80012d0 <trace_next>
 800140a:	bf00      	nop
 800140c:	f3af 8000 	nop.w

08001410 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001410:	f640 1358 	movw	r3, #2392	; 0x958
 8001414:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001418:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 800141c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001420:	2100      	movs	r1, #0
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8001422:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001424:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001426:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001428:	621a      	str	r2, [r3, #32]
 800142a:	4770      	bx	lr
 800142c:	f3af 8000 	nop.w

08001430 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001432:	f640 1658 	movw	r6, #2392	; 0x958
 8001436:	f2c2 0600 	movt	r6, #8192	; 0x2000
 800143a:	4634      	mov	r4, r6
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800143c:	2901      	cmp	r1, #1
 800143e:	bf98      	it	ls
 8001440:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001442:	f854 7f1c 	ldr.w	r7, [r4, #28]!
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8001446:	6103      	str	r3, [r0, #16]
 8001448:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800144c:	42a7      	cmp	r7, r4
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800144e:	4605      	mov	r5, r0

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8001450:	60c2      	str	r2, [r0, #12]
 8001452:	6a58      	ldr	r0, [r3, #36]	; 0x24
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001454:	d01e      	beq.n	8001494 <chVTDoSetI+0x64>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 8001456:	6ab4      	ldr	r4, [r6, #40]	; 0x28
    if (delta < ch.vtlist.next->delta) {
 8001458:	68bb      	ldr	r3, [r7, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 800145a:	4408      	add	r0, r1
 800145c:	1b04      	subs	r4, r0, r4
    if (delta < ch.vtlist.next->delta) {
 800145e:	429c      	cmp	r4, r3
 8001460:	d315      	bcc.n	800148e <chVTDoSetI+0x5e>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
 8001462:	69f3      	ldr	r3, [r6, #28]
  while (p->delta < delta) {
 8001464:	689a      	ldr	r2, [r3, #8]
 8001466:	4294      	cmp	r4, r2
 8001468:	d904      	bls.n	8001474 <chVTDoSetI+0x44>
    delta -= p->delta;
    p = p->next;
 800146a:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
    delta -= p->delta;
 800146c:	1aa4      	subs	r4, r4, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 800146e:	689a      	ldr	r2, [r3, #8]
 8001470:	42a2      	cmp	r2, r4
 8001472:	d3fa      	bcc.n	800146a <chVTDoSetI+0x3a>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8001474:	685a      	ldr	r2, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8001476:	602b      	str	r3, [r5, #0]
  vtp->prev = vtp->next->prev;
 8001478:	606a      	str	r2, [r5, #4]
  vtp->prev->next = vtp;
 800147a:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 800147c:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
 800147e:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8001480:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8001482:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8001486:	1b14      	subs	r4, r2, r4
 8001488:	609c      	str	r4, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 800148a:	6271      	str	r1, [r6, #36]	; 0x24
 800148c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800148e:	f000 fbf7 	bl	8001c80 <stSetAlarm>
 8001492:	e7e6      	b.n	8001462 <chVTDoSetI+0x32>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8001494:	62b0      	str	r0, [r6, #40]	; 0x28
      ch.vtlist.next = vtp;
 8001496:	61f5      	str	r5, [r6, #28]
      ch.vtlist.prev = vtp;
 8001498:	6235      	str	r5, [r6, #32]
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 800149a:	4408      	add	r0, r1
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800149c:	602f      	str	r7, [r5, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800149e:	606f      	str	r7, [r5, #4]
      vtp->delta = delay;
 80014a0:	60a9      	str	r1, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
}
 80014a2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80014a6:	f000 bbdb 	b.w	8001c60 <stStartAlarm>
 80014aa:	bf00      	nop
 80014ac:	f3af 8000 	nop.w

080014b0 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80014b0:	f640 1358 	movw	r3, #2392	; 0x958
 80014b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80014b8:	b410      	push	{r4}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80014ba:	69da      	ldr	r2, [r3, #28]
 80014bc:	4282      	cmp	r2, r0
 80014be:	d010      	beq.n	80014e2 <chVTDoResetI+0x32>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80014c0:	6802      	ldr	r2, [r0, #0]
 80014c2:	6841      	ldr	r1, [r0, #4]
 80014c4:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 80014c6:	6802      	ldr	r2, [r0, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80014c8:	331c      	adds	r3, #28
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 80014ca:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80014cc:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 80014ce:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 80014d0:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80014d2:	d003      	beq.n	80014dc <chVTDoResetI+0x2c>
      vtp->next->delta += vtp->delta;
 80014d4:	6881      	ldr	r1, [r0, #8]
 80014d6:	6893      	ldr	r3, [r2, #8]
 80014d8:	440b      	add	r3, r1
 80014da:	6093      	str	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80014dc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80014e0:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80014e2:	6811      	ldr	r1, [r2, #0]
 80014e4:	4618      	mov	r0, r3
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 80014e6:	2400      	movs	r4, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80014e8:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80014ec:	4281      	cmp	r1, r0
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80014ee:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 80014f0:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80014f2:	d013      	beq.n	800151c <chVTDoResetI+0x6c>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80014f4:	6894      	ldr	r4, [r2, #8]
 80014f6:	6888      	ldr	r0, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 80014f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80014fa:	1823      	adds	r3, r4, r0
 80014fc:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8001500:	608b      	str	r3, [r1, #8]
 8001502:	6a40      	ldr	r0, [r0, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8001504:	1a82      	subs	r2, r0, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8001506:	4293      	cmp	r3, r2
 8001508:	d9e8      	bls.n	80014dc <chVTDoResetI+0x2c>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800150a:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800150c:	2b01      	cmp	r3, #1
 800150e:	bf98      	it	ls
 8001510:	2302      	movls	r3, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001512:	4418      	add	r0, r3
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001514:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001518:	f000 bbb2 	b.w	8001c80 <stSetAlarm>
 800151c:	f85d 4b04 	ldr.w	r4, [sp], #4
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8001520:	f000 bba6 	b.w	8001c70 <stStopAlarm>
 8001524:	f3af 8000 	nop.w
 8001528:	f3af 8000 	nop.w
 800152c:	f3af 8000 	nop.w

08001530 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8001530:	b410      	push	{r4}
 8001532:	2320      	movs	r3, #32
 8001534:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8001538:	f890 3020 	ldrb.w	r3, [r0, #32]
 800153c:	2b07      	cmp	r3, #7
 800153e:	d80e      	bhi.n	800155e <wakeup+0x2e>
 8001540:	e8df f003 	tbb	[pc, r3]
 8001544:	270d0d2b 	.word	0x270d0d2b
 8001548:	080d0408 	.word	0x080d0408
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800154c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800154e:	689a      	ldr	r2, [r3, #8]
 8001550:	3201      	adds	r2, #1
 8001552:	609a      	str	r2, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001554:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001558:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800155a:	6802      	ldr	r2, [r0, #0]
 800155c:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800155e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001562:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 8001564:	f640 1358 	movw	r3, #2392	; 0x958
 8001568:	6881      	ldr	r1, [r0, #8]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800156a:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800156c:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8001570:	f2c2 0300 	movt	r3, #8192	; 0x2000
  do {
    cp = cp->queue.next;
 8001574:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001576:	689a      	ldr	r2, [r3, #8]
 8001578:	428a      	cmp	r2, r1
 800157a:	d2fb      	bcs.n	8001574 <wakeup+0x44>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800157c:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800157e:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8001580:	6042      	str	r2, [r0, #4]
 8001582:	2100      	movs	r1, #0
  tp->queue.prev->queue.next = tp;
 8001584:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8001586:	6058      	str	r0, [r3, #4]
 8001588:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 800158c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001590:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8001592:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001594:	2200      	movs	r2, #0
 8001596:	601a      	str	r2, [r3, #0]
    break;
 8001598:	e7e1      	b.n	800155e <wakeup+0x2e>
 800159a:	2300      	movs	r3, #0
 800159c:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80015a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80015a4:	4770      	bx	lr
 80015a6:	bf00      	nop
 80015a8:	f3af 8000 	nop.w
 80015ac:	f3af 8000 	nop.w

080015b0 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80015b0:	f640 1358 	movw	r3, #2392	; 0x958
 80015b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 80015b8:	2200      	movs	r2, #0
 80015ba:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80015bc:	605b      	str	r3, [r3, #4]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 80015be:	611b      	str	r3, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 80015c0:	615b      	str	r3, [r3, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 80015c2:	609a      	str	r2, [r3, #8]
 80015c4:	4770      	bx	lr
 80015c6:	bf00      	nop
 80015c8:	f3af 8000 	nop.w
 80015cc:	f3af 8000 	nop.w

080015d0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80015d0:	2300      	movs	r3, #0
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80015d2:	b410      	push	{r4}
 80015d4:	6881      	ldr	r1, [r0, #8]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80015d6:	f880 3020 	strb.w	r3, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80015da:	f640 1358 	movw	r3, #2392	; 0x958
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80015de:	4604      	mov	r4, r0
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.queue;
 80015e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  do {
    cp = cp->queue.next;
 80015e4:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80015e6:	689a      	ldr	r2, [r3, #8]
 80015e8:	428a      	cmp	r2, r1
 80015ea:	d2fb      	bcs.n	80015e4 <chSchReadyI+0x14>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80015ec:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80015ee:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80015f0:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 80015f2:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80015f4:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80015f6:	605c      	str	r4, [r3, #4]

  return tp;
}
 80015f8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80015fc:	4770      	bx	lr
 80015fe:	bf00      	nop

08001600 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001600:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8001602:	f640 1458 	movw	r4, #2392	; 0x958
 8001606:	f2c2 0400 	movt	r4, #8192	; 0x2000
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800160a:	2601      	movs	r6, #1
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800160c:	6823      	ldr	r3, [r4, #0]
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 800160e:	69a5      	ldr	r5, [r4, #24]

  tqp->next             = tp->queue.next;
 8001610:	681a      	ldr	r2, [r3, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8001612:	f885 0020 	strb.w	r0, [r5, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001616:	4629      	mov	r1, r5
  tqp->next->queue.prev = (thread_t *)tqp;
 8001618:	6054      	str	r4, [r2, #4]
 800161a:	4618      	mov	r0, r3
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800161c:	f883 6020 	strb.w	r6, [r3, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001620:	6022      	str	r2, [r4, #0]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001622:	61a3      	str	r3, [r4, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001624:	f7ff fe8c 	bl	8001340 <_trace_switch>
 8001628:	4629      	mov	r1, r5
 800162a:	69a0      	ldr	r0, [r4, #24]
}
 800162c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001630:	f7fe be56 	b.w	80002e0 <_port_switch>
 8001634:	f3af 8000 	nop.w
 8001638:	f3af 8000 	nop.w
 800163c:	f3af 8000 	nop.w

08001640 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001640:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001642:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001644:	b087      	sub	sp, #28
 8001646:	4605      	mov	r5, r0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001648:	d017      	beq.n	800167a <chSchGoSleepTimeoutS+0x3a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800164a:	f640 1458 	movw	r4, #2392	; 0x958
 800164e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8001652:	f241 5231 	movw	r2, #5425	; 0x1531
 8001656:	69a3      	ldr	r3, [r4, #24]
 8001658:	a801      	add	r0, sp, #4
 800165a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800165e:	f7ff fee7 	bl	8001430 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8001662:	4628      	mov	r0, r5
 8001664:	f7ff ffcc 	bl	8001600 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8001668:	9b04      	ldr	r3, [sp, #16]
 800166a:	b113      	cbz	r3, 8001672 <chSchGoSleepTimeoutS+0x32>
      chVTDoResetI(&vt);
 800166c:	a801      	add	r0, sp, #4
 800166e:	f7ff ff1f 	bl	80014b0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8001672:	69a3      	ldr	r3, [r4, #24]
}
 8001674:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001676:	b007      	add	sp, #28
 8001678:	bd30      	pop	{r4, r5, pc}
 800167a:	f640 1458 	movw	r4, #2392	; 0x958
 800167e:	f2c2 0400 	movt	r4, #8192	; 0x2000
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001682:	f7ff ffbd 	bl	8001600 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8001686:	69a3      	ldr	r3, [r4, #24]
}
 8001688:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800168a:	b007      	add	sp, #28
 800168c:	bd30      	pop	{r4, r5, pc}
 800168e:	bf00      	nop

08001690 <chSchWakeupS>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8001690:	f640 1c58 	movw	ip, #2392	; 0x958
 8001694:	f2c2 0c00 	movt	ip, #8192	; 0x2000
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001698:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *otp = currp;
 800169a:	f8dc 7018 	ldr.w	r7, [ip, #24]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800169e:	6885      	ldr	r5, [r0, #8]
 80016a0:	68bc      	ldr	r4, [r7, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80016a2:	6241      	str	r1, [r0, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80016a4:	42a5      	cmp	r5, r4
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80016a6:	4606      	mov	r6, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80016a8:	d80d      	bhi.n	80016c6 <chSchWakeupS+0x36>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80016aa:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 80016ac:	4663      	mov	r3, ip
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80016ae:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 80016b2:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80016b4:	689a      	ldr	r2, [r3, #8]
 80016b6:	4295      	cmp	r5, r2
 80016b8:	d9fb      	bls.n	80016b2 <chSchWakeupS+0x22>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80016ba:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80016bc:	6033      	str	r3, [r6, #0]
  tp->queue.prev             = cp->queue.prev;
 80016be:	6072      	str	r2, [r6, #4]
  tp->queue.prev->queue.next = tp;
 80016c0:	6016      	str	r6, [r2, #0]
  cp->queue.prev             = tp;
 80016c2:	605e      	str	r6, [r3, #4]
 80016c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80016c6:	2300      	movs	r3, #0
 80016c8:	f887 3020 	strb.w	r3, [r7, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80016cc:	4663      	mov	r3, ip
  do {
    cp = cp->queue.next;
 80016ce:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80016d0:	689a      	ldr	r2, [r3, #8]
 80016d2:	4294      	cmp	r4, r2
 80016d4:	d9fb      	bls.n	80016ce <chSchWakeupS+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80016d6:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80016d8:	603b      	str	r3, [r7, #0]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80016da:	2401      	movs	r4, #1
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80016dc:	607a      	str	r2, [r7, #4]
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80016de:	4630      	mov	r0, r6
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80016e0:	6017      	str	r7, [r2, #0]
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80016e2:	4639      	mov	r1, r7
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;
 80016e4:	605f      	str	r7, [r3, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80016e6:	f886 4020 	strb.w	r4, [r6, #32]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80016ea:	f8cc 6018 	str.w	r6, [ip, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80016ee:	f7ff fe27 	bl	8001340 <_trace_switch>
 80016f2:	4630      	mov	r0, r6
 80016f4:	4639      	mov	r1, r7
  }
}
 80016f6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80016fa:	f7fe bdf1 	b.w	80002e0 <_port_switch>
 80016fe:	bf00      	nop

08001700 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001700:	f640 1358 	movw	r3, #2392	; 0x958
 8001704:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001708:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->prio;
 800170a:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800170c:	6890      	ldr	r0, [r2, #8]
 800170e:	689b      	ldr	r3, [r3, #8]
#endif
}
 8001710:	4298      	cmp	r0, r3
 8001712:	bf94      	ite	ls
 8001714:	2000      	movls	r0, #0
 8001716:	2001      	movhi	r0, #1
 8001718:	4770      	bx	lr
 800171a:	bf00      	nop
 800171c:	f3af 8000 	nop.w

08001720 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8001720:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8001722:	f640 1658 	movw	r6, #2392	; 0x958
 8001726:	f2c2 0600 	movt	r6, #8192	; 0x2000

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800172a:	2101      	movs	r1, #1
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800172c:	6830      	ldr	r0, [r6, #0]
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 800172e:	69b5      	ldr	r5, [r6, #24]

  tqp->next             = tp->queue.next;
 8001730:	6803      	ldr	r3, [r0, #0]
 8001732:	68ac      	ldr	r4, [r5, #8]
 8001734:	6033      	str	r3, [r6, #0]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001736:	2200      	movs	r2, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8001738:	605e      	str	r6, [r3, #4]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800173a:	f880 1020 	strb.w	r1, [r0, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800173e:	61b0      	str	r0, [r6, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001740:	f885 2020 	strb.w	r2, [r5, #32]
 8001744:	e000      	b.n	8001748 <chSchDoRescheduleAhead+0x28>
 8001746:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8001748:	689a      	ldr	r2, [r3, #8]
 800174a:	42a2      	cmp	r2, r4
 800174c:	d8fb      	bhi.n	8001746 <chSchDoRescheduleAhead+0x26>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800174e:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001750:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8001752:	606a      	str	r2, [r5, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001754:	4629      	mov	r1, r5
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8001756:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 8001758:	605d      	str	r5, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800175a:	f7ff fdf1 	bl	8001340 <_trace_switch>
 800175e:	69b0      	ldr	r0, [r6, #24]
 8001760:	4629      	mov	r1, r5
}
 8001762:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001766:	f7fe bdbb 	b.w	80002e0 <_port_switch>
 800176a:	bf00      	nop
 800176c:	f3af 8000 	nop.w

08001770 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8001770:	f640 1358 	movw	r3, #2392	; 0x958
 8001774:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001778:	681a      	ldr	r2, [r3, #0]
 800177a:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 800177c:	6892      	ldr	r2, [r2, #8]
 800177e:	689b      	ldr	r3, [r3, #8]
 8001780:	429a      	cmp	r2, r3
 8001782:	d800      	bhi.n	8001786 <chSchRescheduleS+0x16>
 8001784:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8001786:	f7ff bfcb 	b.w	8001720 <chSchDoRescheduleAhead>
 800178a:	bf00      	nop
 800178c:	f3af 8000 	nop.w

08001790 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001790:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8001792:	f640 1658 	movw	r6, #2392	; 0x958
 8001796:	f2c2 0600 	movt	r6, #8192	; 0x2000

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800179a:	2101      	movs	r1, #1
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800179c:	6830      	ldr	r0, [r6, #0]
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 800179e:	69b5      	ldr	r5, [r6, #24]

  tqp->next             = tp->queue.next;
 80017a0:	6803      	ldr	r3, [r0, #0]
 80017a2:	68ac      	ldr	r4, [r5, #8]
 80017a4:	6033      	str	r3, [r6, #0]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80017a6:	2200      	movs	r2, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80017a8:	605e      	str	r6, [r3, #4]
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80017aa:	f880 1020 	strb.w	r1, [r0, #32]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80017ae:	61b0      	str	r0, [r6, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80017b0:	f885 2020 	strb.w	r2, [r5, #32]
 80017b4:	e000      	b.n	80017b8 <chSchDoReschedule+0x28>
 80017b6:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 80017b8:	689a      	ldr	r2, [r3, #8]
 80017ba:	42a2      	cmp	r2, r4
 80017bc:	d8fb      	bhi.n	80017b6 <chSchDoReschedule+0x26>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80017be:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80017c0:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 80017c2:	606a      	str	r2, [r5, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80017c4:	4629      	mov	r1, r5
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80017c6:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 80017c8:	605d      	str	r5, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80017ca:	f7ff fdb9 	bl	8001340 <_trace_switch>
 80017ce:	69b0      	ldr	r0, [r6, #24]
 80017d0:	4629      	mov	r1, r5
}
 80017d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80017d6:	f7fe bd83 	b.w	80002e0 <_port_switch>
 80017da:	bf00      	nop
 80017dc:	f3af 8000 	nop.w

080017e0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 80017e0:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80017e4:	f640 1458 	movw	r4, #2392	; 0x958
 80017e8:	f2c2 0400 	movt	r4, #8192	; 0x2000
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80017ec:	2500      	movs	r5, #0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80017ee:	6966      	ldr	r6, [r4, #20]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80017f0:	f880 5021 	strb.w	r5, [r0, #33]	; 0x21
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 80017f4:	f100 072c 	add.w	r7, r0, #44	; 0x2c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 80017f8:	f04f 0902 	mov.w	r9, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 80017fc:	f04f 0801 	mov.w	r8, #1
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8001800:	f100 0c28 	add.w	ip, r0, #40	; 0x28
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001804:	6104      	str	r4, [r0, #16]
 8001806:	6146      	str	r6, [r0, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001808:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
 800180a:	f880 9020 	strb.w	r9, [r0, #32]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800180e:	f880 8022 	strb.w	r8, [r0, #34]	; 0x22
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8001812:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8001814:	6345      	str	r5, [r0, #52]	; 0x34
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8001816:	63c2      	str	r2, [r0, #60]	; 0x3c
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8001818:	6181      	str	r1, [r0, #24]
  REG_INSERT(tp);
 800181a:	6130      	str	r0, [r6, #16]
 800181c:	6160      	str	r0, [r4, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800181e:	62c7      	str	r7, [r0, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
 8001820:	6307      	str	r7, [r0, #48]	; 0x30
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8001822:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
 8001826:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 800182a:	4770      	bx	lr
 800182c:	f3af 8000 	nop.w

08001830 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8001830:	e92d 05f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl}
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8001834:	6883      	ldr	r3, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001836:	6844      	ldr	r4, [r0, #4]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001838:	6945      	ldr	r5, [r0, #20]
 800183a:	6901      	ldr	r1, [r0, #16]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800183c:	f8d0 800c 	ldr.w	r8, [r0, #12]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001840:	f843 5c68 	str.w	r5, [r3, #-104]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001844:	f640 1258 	movw	r2, #2392	; 0x958

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8001848:	6805      	ldr	r5, [r0, #0]
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800184a:	f843 4c2c 	str.w	r4, [r3, #-44]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 800184e:	2000      	movs	r0, #0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001850:	f2c2 0200 	movt	r2, #8192	; 0x2000
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8001854:	2702      	movs	r7, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001856:	2401      	movs	r4, #1
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8001858:	f803 7c28 	strb.w	r7, [r3, #-40]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800185c:	f803 4c26 	strb.w	r4, [r3, #-38]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001860:	f803 0c27 	strb.w	r0, [r3, #-39]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001864:	6956      	ldr	r6, [r2, #20]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001866:	f843 1c6c 	str.w	r1, [r3, #-108]
 800186a:	f240 24f1 	movw	r4, #753	; 0x2f1
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800186e:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8001872:	f1a3 071c 	sub.w	r7, r3, #28
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001876:	f1a3 0a6c 	sub.w	sl, r3, #108	; 0x6c
 800187a:	f6c0 0400 	movt	r4, #2048	; 0x800
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800187e:	f1a3 0c20 	sub.w	ip, r3, #32

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8001882:	f843 5c30 	str.w	r5, [r3, #-48]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001886:	f843 8c40 	str.w	r8, [r3, #-64]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800188a:	f843 8c0c 	str.w	r8, [r3, #-12]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800188e:	f843 ac3c 	str.w	sl, [r3, #-60]
 8001892:	f843 4c4c 	str.w	r4, [r3, #-76]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8001896:	f843 0c10 	str.w	r0, [r3, #-16]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800189a:	f843 0c14 	str.w	r0, [r3, #-20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800189e:	f843 6c34 	str.w	r6, [r3, #-52]
 80018a2:	f843 2c38 	str.w	r2, [r3, #-56]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 80018a6:	4608      	mov	r0, r1
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80018a8:	6131      	str	r1, [r6, #16]
 80018aa:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80018ac:	f843 7c1c 	str.w	r7, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 80018b0:	f843 7c18 	str.w	r7, [r3, #-24]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 80018b4:	f843 cc20 	str.w	ip, [r3, #-32]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 80018b8:	e8bd 05f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl}
 80018bc:	4770      	bx	lr
 80018be:	bf00      	nop

080018c0 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 80018c0:	b510      	push	{r4, lr}
 80018c2:	2320      	movs	r3, #32
 80018c4:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 80018c8:	f7ff ffb2 	bl	8001830 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 80018cc:	2100      	movs	r1, #0
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 80018ce:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 80018d0:	f7ff fede 	bl	8001690 <chSchWakeupS>
 80018d4:	2300      	movs	r3, #0
 80018d6:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 80018da:	4620      	mov	r0, r4
 80018dc:	bd10      	pop	{r4, pc}
 80018de:	bf00      	nop

080018e0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80018e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80018e4:	4698      	mov	r8, r3
 80018e6:	4696      	mov	lr, r2
 80018e8:	2320      	movs	r3, #32
 80018ea:	f383 8811 	msr	BASEPRI, r3
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80018ee:	f640 1658 	movw	r6, #2392	; 0x958
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 80018f2:	f1a1 0448 	sub.w	r4, r1, #72	; 0x48
 80018f6:	4404      	add	r4, r0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80018f8:	f2c2 0600 	movt	r6, #8192	; 0x2000
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 80018fc:	61e0      	str	r0, [r4, #28]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80018fe:	6972      	ldr	r2, [r6, #20]
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001900:	980a      	ldr	r0, [sp, #40]	; 0x28
 8001902:	f844 8c24 	str.w	r8, [r4, #-36]
 8001906:	f240 27f1 	movw	r7, #753	; 0x2f1
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800190a:	f245 4124 	movw	r1, #21540	; 0x5424
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 800190e:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8001910:	f104 032c 	add.w	r3, r4, #44	; 0x2c
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8001914:	f104 0c28 	add.w	ip, r4, #40	; 0x28
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001918:	f1a4 0a24 	sub.w	sl, r4, #36	; 0x24
 800191c:	f6c0 0700 	movt	r7, #2048	; 0x800
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8001920:	f04f 0902 	mov.w	r9, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001924:	f04f 0b01 	mov.w	fp, #1
  tp->name      = name;
 8001928:	f6c0 0100 	movt	r1, #2048	; 0x800
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800192c:	f844 0c20 	str.w	r0, [r4, #-32]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001930:	f8c4 e008 	str.w	lr, [r4, #8]
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001934:	f8c4 a00c 	str.w	sl, [r4, #12]
 8001938:	f844 7c04 	str.w	r7, [r4, #-4]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800193c:	61a1      	str	r1, [r4, #24]
  REG_INSERT(tp);
 800193e:	6126      	str	r6, [r4, #16]
 8001940:	6162      	str	r2, [r4, #20]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8001942:	f8c4 e03c 	str.w	lr, [r4, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8001946:	f884 9020 	strb.w	r9, [r4, #32]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800194a:	f884 b022 	strb.w	fp, [r4, #34]	; 0x22
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 800194e:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8001952:	63a5      	str	r5, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8001954:	6365      	str	r5, [r4, #52]	; 0x34
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8001956:	4620      	mov	r0, r4
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001958:	6114      	str	r4, [r2, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 800195a:	4629      	mov	r1, r5
 800195c:	f8c4 c028 	str.w	ip, [r4, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001960:	62e3      	str	r3, [r4, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
 8001962:	6323      	str	r3, [r4, #48]	; 0x30
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001964:	6174      	str	r4, [r6, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8001966:	f7ff fe93 	bl	8001690 <chSchWakeupS>
 800196a:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 800196e:	4620      	mov	r0, r4
 8001970:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001974:	f3af 8000 	nop.w
 8001978:	f3af 8000 	nop.w
 800197c:	f3af 8000 	nop.w

08001980 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001980:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8001982:	f640 1358 	movw	r3, #2392	; 0x958
 8001986:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800198a:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800198c:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800198e:	6260      	str	r0, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001990:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8001994:	429d      	cmp	r5, r3
 8001996:	d007      	beq.n	80019a8 <chThdExitS+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8001998:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(list_remove(&tp->waiting));
 800199a:	4618      	mov	r0, r3
 800199c:	62a2      	str	r2, [r4, #40]	; 0x28
 800199e:	f7ff fe17 	bl	80015d0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80019a2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80019a4:	42ab      	cmp	r3, r5
 80019a6:	d1f7      	bne.n	8001998 <chThdExitS+0x18>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80019a8:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 80019ac:	b94b      	cbnz	r3, 80019c2 <chThdExitS+0x42>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80019ae:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80019b2:	079b      	lsls	r3, r3, #30
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 80019b4:	bf01      	itttt	eq
 80019b6:	6922      	ldreq	r2, [r4, #16]
 80019b8:	6963      	ldreq	r3, [r4, #20]
 80019ba:	611a      	streq	r2, [r3, #16]
 80019bc:	6922      	ldreq	r2, [r4, #16]
 80019be:	bf08      	it	eq
 80019c0:	6153      	streq	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80019c2:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80019c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80019c8:	f7ff be1a 	b.w	8001600 <chSchGoSleepS>
 80019cc:	f3af 8000 	nop.w

080019d0 <chThdExit>:
 80019d0:	2320      	movs	r3, #32
 80019d2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 80019d6:	f7ff bfd3 	b.w	8001980 <chThdExitS>
 80019da:	bf00      	nop
 80019dc:	f3af 8000 	nop.w

080019e0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80019e0:	b508      	push	{r3, lr}
 80019e2:	4601      	mov	r1, r0
 80019e4:	2320      	movs	r3, #32
 80019e6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80019ea:	2008      	movs	r0, #8
 80019ec:	f7ff fe28 	bl	8001640 <chSchGoSleepTimeoutS>
 80019f0:	2300      	movs	r3, #0
 80019f2:	f383 8811 	msr	BASEPRI, r3
 80019f6:	bd08      	pop	{r3, pc}
 80019f8:	f3af 8000 	nop.w
 80019fc:	f3af 8000 	nop.w

08001a00 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8001a00:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001a02:	f640 1458 	movw	r4, #2392	; 0x958
 8001a06:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8001a0a:	4602      	mov	r2, r0
 8001a0c:	69a3      	ldr	r3, [r4, #24]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->u.wttrp = trp;
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001a0e:	2003      	movs	r0, #3
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 8001a10:	6013      	str	r3, [r2, #0]
  tp->u.wttrp = trp;
 8001a12:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001a14:	f7ff fdf4 	bl	8001600 <chSchGoSleepS>

  return chThdGetSelfX()->u.rdymsg;
 8001a18:	69a3      	ldr	r3, [r4, #24]
}
 8001a1a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001a1c:	bd10      	pop	{r4, pc}
 8001a1e:	bf00      	nop

08001a20 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001a20:	6803      	ldr	r3, [r0, #0]
 8001a22:	b12b      	cbz	r3, 8001a30 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001a24:	2200      	movs	r2, #0
 8001a26:	6002      	str	r2, [r0, #0]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001a28:	4618      	mov	r0, r3
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
 8001a2a:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001a2c:	f7ff bdd0 	b.w	80015d0 <chSchReadyI>
 8001a30:	4770      	bx	lr
 8001a32:	bf00      	nop
 8001a34:	f3af 8000 	nop.w
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <chTMStartMeasurementX>:
 8001a40:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001a44:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001a48:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001a4a:	6083      	str	r3, [r0, #8]
 8001a4c:	4770      	bx	lr
 8001a4e:	bf00      	nop

08001a50 <chTMStopMeasurementX>:
 8001a50:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001a54:	f2ce 0200 	movt	r2, #57344	; 0xe000
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001a58:	f640 1358 	movw	r3, #2392	; 0x958
 8001a5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a60:	6851      	ldr	r1, [r2, #4]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001a62:	b4f0      	push	{r4, r5, r6, r7}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001a64:	6886      	ldr	r6, [r0, #8]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001a66:	f8d3 787c 	ldr.w	r7, [r3, #2172]	; 0x87c
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8001a6a:	6844      	ldr	r4, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001a6c:	68c5      	ldr	r5, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001a6e:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001a72:	1b89      	subs	r1, r1, r6
 8001a74:	1bc9      	subs	r1, r1, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8001a76:	1852      	adds	r2, r2, r1
 8001a78:	f143 0300 	adc.w	r3, r3, #0
 8001a7c:	e9c0 2304 	strd	r2, r3, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8001a80:	6803      	ldr	r3, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001a82:	6081      	str	r1, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8001a84:	42a1      	cmp	r1, r4

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001a86:	f105 0501 	add.w	r5, r5, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8001a8a:	bf88      	it	hi
 8001a8c:	6041      	strhi	r1, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 8001a8e:	4299      	cmp	r1, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001a90:	60c5      	str	r5, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8001a92:	bf38      	it	cc
 8001a94:	6001      	strcc	r1, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8001a96:	bcf0      	pop	{r4, r5, r6, r7}
 8001a98:	4770      	bx	lr
 8001a9a:	bf00      	nop
 8001a9c:	f3af 8000 	nop.w

08001aa0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001aa0:	b530      	push	{r4, r5, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001aa2:	f640 1458 	movw	r4, #2392	; 0x958
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001aa6:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001aa8:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8001aac:	2100      	movs	r1, #0

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8001aae:	2200      	movs	r2, #0
 8001ab0:	2300      	movs	r3, #0
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001ab2:	4668      	mov	r0, sp
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001ab4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8001ab8:	e9cd 2304 	strd	r2, r3, [sp, #16]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001abc:	f8c4 187c 	str.w	r1, [r4, #2172]	; 0x87c
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8001ac0:	9101      	str	r1, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 8001ac2:	9102      	str	r1, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8001ac4:	9103      	str	r1, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001ac6:	9500      	str	r5, [sp, #0]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001ac8:	f7ff ffba 	bl	8001a40 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8001acc:	4668      	mov	r0, sp
 8001ace:	f7ff ffbf 	bl	8001a50 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001ad2:	9b02      	ldr	r3, [sp, #8]
 8001ad4:	f8c4 387c 	str.w	r3, [r4, #2172]	; 0x87c
}
 8001ad8:	b007      	add	sp, #28
 8001ada:	bd30      	pop	{r4, r5, pc}
 8001adc:	f3af 8000 	nop.w

08001ae0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001ae0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001ae2:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8001ae4:	6040      	str	r0, [r0, #4]
 8001ae6:	6083      	str	r3, [r0, #8]
 8001ae8:	4770      	bx	lr
 8001aea:	bf00      	nop
 8001aec:	f3af 8000 	nop.w

08001af0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001af0:	f241 11dc 	movw	r1, #4572	; 0x11dc
  endmem  = __heap_end__;
 8001af4:	f241 13d8 	movw	r3, #4568	; 0x11d8
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001af8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8001afc:	f641 00a8 	movw	r0, #6312	; 0x18a8
  endmem  = __heap_end__;
 8001b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b04:	f248 0200 	movw	r2, #32768	; 0x8000
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001b08:	f2c2 0000 	movt	r0, #8192	; 0x2000
  endmem  = __heap_end__;
 8001b0c:	f2c2 0201 	movt	r2, #8193	; 0x2001
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001b10:	6008      	str	r0, [r1, #0]
  endmem  = __heap_end__;
 8001b12:	601a      	str	r2, [r3, #0]
 8001b14:	4770      	bx	lr
 8001b16:	bf00      	nop
 8001b18:	f3af 8000 	nop.w
 8001b1c:	f3af 8000 	nop.w

08001b20 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 8001b20:	b430      	push	{r4, r5}
 8001b22:	2320      	movs	r3, #32
 8001b24:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001b28:	f241 13dc 	movw	r3, #4572	; 0x11dc
 8001b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000

  if (((size_t)endmem - (size_t)p) < size) {
 8001b30:	f241 12d8 	movw	r2, #4568	; 0x11d8

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001b34:	681c      	ldr	r4, [r3, #0]

  if (((size_t)endmem - (size_t)p) < size) {
 8001b36:	f2c2 0200 	movt	r2, #8192	; 0x2000

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001b3a:	3c01      	subs	r4, #1
 8001b3c:	440c      	add	r4, r1
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8001b3e:	1e4d      	subs	r5, r1, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8001b40:	6812      	ldr	r2, [r2, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8001b42:	4249      	negs	r1, r1
 8001b44:	4405      	add	r5, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001b46:	ea04 0001 	and.w	r0, r4, r1

  if (((size_t)endmem - (size_t)p) < size) {
 8001b4a:	1a12      	subs	r2, r2, r0
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8001b4c:	4029      	ands	r1, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8001b4e:	4291      	cmp	r1, r2
    return NULL;
  }
  nextmem = p + size;
 8001b50:	bf9a      	itte	ls
 8001b52:	1809      	addls	r1, r1, r0
 8001b54:	6019      	strls	r1, [r3, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 8001b56:	2000      	movhi	r0, #0
 8001b58:	2300      	movs	r3, #0
 8001b5a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 8001b5e:	bc30      	pop	{r4, r5}
 8001b60:	4770      	bx	lr
 8001b62:	bf00      	nop
 8001b64:	f3af 8000 	nop.w
 8001b68:	f3af 8000 	nop.w
 8001b6c:	f3af 8000 	nop.w

08001b70 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8001b70:	f241 13e0 	movw	r3, #4576	; 0x11e0
 8001b74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b78:	f641 3221 	movw	r2, #6945	; 0x1b21
  H_NEXT(&default_heap.header) = NULL;
 8001b7c:	2100      	movs	r1, #0
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8001b7e:	f6c0 0200 	movt	r2, #2048	; 0x800
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8001b82:	f103 0010 	add.w	r0, r3, #16
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8001b86:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8001b88:	6099      	str	r1, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
 8001b8a:	60d9      	str	r1, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8001b8c:	f7ff bfa8 	b.w	8001ae0 <chMtxObjectInit>

08001b90 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001b90:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8001b94:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001b96:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001b9a:	2300      	movs	r3, #0
 8001b9c:	f383 8811 	msr	BASEPRI, r3
 8001ba0:	4770      	bx	lr
 8001ba2:	bf00      	nop
 8001ba4:	f3af 8000 	nop.w
 8001ba8:	f3af 8000 	nop.w
 8001bac:	f3af 8000 	nop.w

08001bb0 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8001bb0:	b510      	push	{r4, lr}
 8001bb2:	2320      	movs	r3, #32
 8001bb4:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001bb8:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8001bbc:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001bc0:	685b      	ldr	r3, [r3, #4]
 8001bc2:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8001bc6:	d102      	bne.n	8001bce <_port_irq_epilogue+0x1e>
 8001bc8:	f383 8811 	msr	BASEPRI, r3
 8001bcc:	bd10      	pop	{r4, pc}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001bce:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001bd2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001bd6:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001bda:	f1a4 0320 	sub.w	r3, r4, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001bde:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001be2:	f7ff fd8d 	bl	8001700 <chSchIsPreemptionRequired>
 8001be6:	b130      	cbz	r0, 8001bf6 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001be8:	f240 3301 	movw	r3, #769	; 0x301
 8001bec:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001bf0:	f844 3c08 	str.w	r3, [r4, #-8]
 8001bf4:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001bf6:	f240 3304 	movw	r3, #772	; 0x304
 8001bfa:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001bfe:	f844 3c08 	str.w	r3, [r4, #-8]
 8001c02:	bd10      	pop	{r4, pc}
 8001c04:	f3af 8000 	nop.w
 8001c08:	f3af 8000 	nop.w
 8001c0c:	f3af 8000 	nop.w

08001c10 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001c10:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8001c12:	f000 fee5 	bl	80029e0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001c16:	f245 7018 	movw	r0, #22296	; 0x5718
 8001c1a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001c1e:	f001 fc87 	bl	8003530 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 8001c22:	f000 f835 	bl	8001c90 <adcInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8001c26:	f000 f873 	bl	8001d10 <pwmInit>
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
 8001c2a:	f000 f999 	bl	8001f60 <uartInit>
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
#endif
#if (HAL_USE_RTC == TRUE) || defined(__DOXYGEN__)
  rtcInit();
 8001c2e:	f000 f8e7 	bl	8001e00 <rtcInit>
#endif

  /* Community driver overlay initialization.*/
#if defined(HAL_USE_COMMUNITY) || defined(__DOXYGEN__)
#if (HAL_USE_COMMUNITY == TRUE) || defined(__DOXYGEN__)
  halCommunityInit();
 8001c32:	f000 fa05 	bl	8002040 <halCommunityInit>
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001c36:	f002 fab3 	bl	80041a0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8001c3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001c3e:	f000 b807 	b.w	8001c50 <stInit>
 8001c42:	bf00      	nop
 8001c44:	f3af 8000 	nop.w
 8001c48:	f3af 8000 	nop.w
 8001c4c:	f3af 8000 	nop.w

08001c50 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8001c50:	f001 bace 	b.w	80031f0 <st_lld_init>
 8001c54:	f3af 8000 	nop.w
 8001c58:	f3af 8000 	nop.w
 8001c5c:	f3af 8000 	nop.w

08001c60 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001c60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8001c64:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001c66:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001c68:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001c6a:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001c6c:	60da      	str	r2, [r3, #12]
 8001c6e:	4770      	bx	lr

08001c70 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001c70:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001c74:	2200      	movs	r2, #0
 8001c76:	60da      	str	r2, [r3, #12]
 8001c78:	4770      	bx	lr
 8001c7a:	bf00      	nop
 8001c7c:	f3af 8000 	nop.w

08001c80 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001c80:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001c84:	6358      	str	r0, [r3, #52]	; 0x34
 8001c86:	4770      	bx	lr
 8001c88:	f3af 8000 	nop.w
 8001c8c:	f3af 8000 	nop.w

08001c90 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 8001c90:	f001 bad6 	b.w	8003240 <adc_lld_init>
 8001c94:	f3af 8000 	nop.w
 8001c98:	f3af 8000 	nop.w
 8001c9c:	f3af 8000 	nop.w

08001ca0 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8001ca0:	2300      	movs	r3, #0
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8001ca2:	2201      	movs	r2, #1
 8001ca4:	7002      	strb	r2, [r0, #0]
  adcp->config   = NULL;
 8001ca6:	6043      	str	r3, [r0, #4]
  adcp->samples  = NULL;
 8001ca8:	6083      	str	r3, [r0, #8]
  adcp->depth    = 0;
 8001caa:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 8001cac:	6103      	str	r3, [r0, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8001cae:	6143      	str	r3, [r0, #20]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8001cb0:	3018      	adds	r0, #24
 8001cb2:	f7ff bf15 	b.w	8001ae0 <chMtxObjectInit>
 8001cb6:	bf00      	nop
 8001cb8:	f3af 8000 	nop.w
 8001cbc:	f3af 8000 	nop.w

08001cc0 <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8001cc0:	b510      	push	{r4, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001cc2:	2320      	movs	r3, #32
 8001cc4:	4604      	mov	r4, r0
 8001cc6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 8001cca:	6041      	str	r1, [r0, #4]
  adc_lld_start(adcp);
 8001ccc:	f001 fad8 	bl	8003280 <adc_lld_start>
  adcp->state = ADC_READY;
 8001cd0:	2302      	movs	r3, #2
 8001cd2:	7023      	strb	r3, [r4, #0]
 8001cd4:	2300      	movs	r3, #0
 8001cd6:	f383 8811 	msr	BASEPRI, r3
 8001cda:	bd10      	pop	{r4, pc}
 8001cdc:	f3af 8000 	nop.w

08001ce0 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8001ce0:	b510      	push	{r4, lr}
 8001ce2:	4604      	mov	r4, r0
 8001ce4:	2020      	movs	r0, #32
 8001ce6:	f380 8811 	msr	BASEPRI, r0
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 8001cea:	2003      	movs	r0, #3
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
 8001cec:	60e3      	str	r3, [r4, #12]
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 8001cee:	60a2      	str	r2, [r4, #8]
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 8001cf0:	6121      	str	r1, [r4, #16]
  adcp->state    = ADC_ACTIVE;
 8001cf2:	7020      	strb	r0, [r4, #0]
  adc_lld_start_conversion(adcp);
 8001cf4:	4620      	mov	r0, r4
 8001cf6:	f001 fafb 	bl	80032f0 <adc_lld_start_conversion>
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 8001cfa:	f104 0014 	add.w	r0, r4, #20
 8001cfe:	f7ff fe7f 	bl	8001a00 <chThdSuspendS>
 8001d02:	2300      	movs	r3, #0
 8001d04:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(adcp->thread == NULL, "already waiting");
  adcStartConversionI(adcp, grpp, samples, depth);
  msg = osalThreadSuspendS(&adcp->thread);
  osalSysUnlock();
  return msg;
}
 8001d08:	bd10      	pop	{r4, pc}
 8001d0a:	bf00      	nop
 8001d0c:	f3af 8000 	nop.w

08001d10 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 8001d10:	f001 be86 	b.w	8003a20 <pwm_lld_init>
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 8001d20:	2300      	movs	r3, #0
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8001d22:	2201      	movs	r2, #1
 8001d24:	7002      	strb	r2, [r0, #0]
  pwmp->config   = NULL;
 8001d26:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 8001d28:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 8001d2a:	7403      	strb	r3, [r0, #16]
 8001d2c:	4770      	bx	lr
 8001d2e:	bf00      	nop

08001d30 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8001d30:	b510      	push	{r4, lr}
 8001d32:	2320      	movs	r3, #32
 8001d34:	4604      	mov	r4, r0
 8001d36:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
 8001d3a:	684b      	ldr	r3, [r1, #4]
  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 8001d3c:	6041      	str	r1, [r0, #4]
  pwmp->period = config->period;
 8001d3e:	6083      	str	r3, [r0, #8]
  pwm_lld_start(pwmp);
 8001d40:	f001 fe8e 	bl	8003a60 <pwm_lld_start>
  pwmp->enabled = 0;
  pwmp->state = PWM_READY;
 8001d44:	2202      	movs	r2, #2
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
  pwmp->enabled = 0;
 8001d46:	2300      	movs	r3, #0
  pwmp->state = PWM_READY;
 8001d48:	7022      	strb	r2, [r4, #0]
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
  pwmp->enabled = 0;
 8001d4a:	60e3      	str	r3, [r4, #12]
 8001d4c:	f383 8811 	msr	BASEPRI, r3
 8001d50:	bd10      	pop	{r4, pc}
 8001d52:	bf00      	nop
 8001d54:	f3af 8000 	nop.w
 8001d58:	f3af 8000 	nop.w
 8001d5c:	f3af 8000 	nop.w

08001d60 <pwmStop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmStop(PWMDriver *pwmp) {
 8001d60:	b510      	push	{r4, lr}
 8001d62:	2320      	movs	r3, #32
 8001d64:	4604      	mov	r4, r0
 8001d66:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(pwmp != NULL);

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwm_lld_stop(pwmp);
 8001d6a:	f001 ff11 	bl	8003b90 <pwm_lld_stop>
  pwmp->enabled = 0;
  pwmp->state   = PWM_STOP;
 8001d6e:	2201      	movs	r2, #1

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwm_lld_stop(pwmp);
  pwmp->enabled = 0;
 8001d70:	2300      	movs	r3, #0
  pwmp->state   = PWM_STOP;
 8001d72:	7022      	strb	r2, [r4, #0]

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwm_lld_stop(pwmp);
  pwmp->enabled = 0;
 8001d74:	60e3      	str	r3, [r4, #12]
 8001d76:	f383 8811 	msr	BASEPRI, r3
 8001d7a:	bd10      	pop	{r4, pc}
 8001d7c:	f3af 8000 	nop.w

08001d80 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8001d80:	b510      	push	{r4, lr}
 8001d82:	2320      	movs	r3, #32
 8001d84:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 8001d88:	2401      	movs	r4, #1
 8001d8a:	68c3      	ldr	r3, [r0, #12]
 8001d8c:	408c      	lsls	r4, r1
 8001d8e:	4323      	orrs	r3, r4
 8001d90:	60c3      	str	r3, [r0, #12]
 8001d92:	f001 ff35 	bl	8003c00 <pwm_lld_enable_channel>
 8001d96:	2300      	movs	r3, #0
 8001d98:	f383 8811 	msr	BASEPRI, r3
 8001d9c:	bd10      	pop	{r4, pc}
 8001d9e:	bf00      	nop

08001da0 <pwmEnablePeriodicNotification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmEnablePeriodicNotification(PWMDriver *pwmp) {
 8001da0:	b508      	push	{r3, lr}
 8001da2:	2320      	movs	r3, #32
 8001da4:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");

  pwmEnablePeriodicNotificationI(pwmp);
 8001da8:	f001 ff42 	bl	8003c30 <pwm_lld_enable_periodic_notification>
 8001dac:	2300      	movs	r3, #0
 8001dae:	f383 8811 	msr	BASEPRI, r3
 8001db2:	bd08      	pop	{r3, pc}
 8001db4:	f3af 8000 	nop.w
 8001db8:	f3af 8000 	nop.w
 8001dbc:	f3af 8000 	nop.w

08001dc0 <pwmDisablePeriodicNotification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmDisablePeriodicNotification(PWMDriver *pwmp) {
 8001dc0:	b508      	push	{r3, lr}
 8001dc2:	2320      	movs	r3, #32
 8001dc4:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");

  pwmDisablePeriodicNotificationI(pwmp);
 8001dc8:	f001 ff42 	bl	8003c50 <pwm_lld_disable_periodic_notification>
 8001dcc:	2300      	movs	r3, #0
 8001dce:	f383 8811 	msr	BASEPRI, r3
 8001dd2:	bd08      	pop	{r3, pc}
 8001dd4:	f3af 8000 	nop.w
 8001dd8:	f3af 8000 	nop.w
 8001ddc:	f3af 8000 	nop.w

08001de0 <pwmEnableChannelNotification>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @api
 */
void pwmEnableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {
 8001de0:	b508      	push	{r3, lr}
 8001de2:	2320      	movs	r3, #32
 8001de4:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
                "channel not enabled");
  osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
                "undefined channel callback");

  pwmEnableChannelNotificationI(pwmp, channel);
 8001de8:	f001 ff3a 	bl	8003c60 <pwm_lld_enable_channel_notification>
 8001dec:	2300      	movs	r3, #0
 8001dee:	f383 8811 	msr	BASEPRI, r3
 8001df2:	bd08      	pop	{r3, pc}
 8001df4:	f3af 8000 	nop.w
 8001df8:	f3af 8000 	nop.w
 8001dfc:	f3af 8000 	nop.w

08001e00 <rtcInit>:
 *
 * @init
 */
void rtcInit(void) {

  rtc_lld_init();
 8001e00:	f001 bc96 	b.w	8003730 <rtc_lld_init>
 8001e04:	f3af 8000 	nop.w
 8001e08:	f3af 8000 	nop.w
 8001e0c:	f3af 8000 	nop.w

08001e10 <rtcObjectInit>:
 *
 * @param[out] rtcp     pointer to RTC driver structure
 *
 * @init
 */
void rtcObjectInit(RTCDriver *rtcp) {
 8001e10:	4770      	bx	lr
 8001e12:	bf00      	nop
 8001e14:	f3af 8000 	nop.w
 8001e18:	f3af 8000 	nop.w
 8001e1c:	f3af 8000 	nop.w

08001e20 <rtcSetTime>:
 */
void rtcSetTime(RTCDriver *rtcp, const RTCDateTime *timespec) {

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_set_time(rtcp, timespec);
 8001e20:	f001 bcbe 	b.w	80037a0 <rtc_lld_set_time>
 8001e24:	f3af 8000 	nop.w
 8001e28:	f3af 8000 	nop.w
 8001e2c:	f3af 8000 	nop.w

08001e30 <rtcGetTime>:
 */
void rtcGetTime(RTCDriver *rtcp, RTCDateTime *timespec) {

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_get_time(rtcp, timespec);
 8001e30:	f001 bd4e 	b.w	80038d0 <rtc_lld_get_time>
 8001e34:	f3af 8000 	nop.w
 8001e38:	f3af 8000 	nop.w
 8001e3c:	f3af 8000 	nop.w

08001e40 <rtcConvertDateTimeToStructTm>:
 *
 * @api
 */
void rtcConvertDateTimeToStructTm(const RTCDateTime *timespec,
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
 8001e40:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  timp->tm_mon   = (int)timespec->month - 1;
  timp->tm_mday  = (int)timespec->day;
  timp->tm_isdst = (int)timespec->dstflag;
  timp->tm_wday  = (int)timespec->dayofweek - 1;

  sec = (int)timespec->millisecond / 1000;
 8001e44:	6846      	ldr	r6, [r0, #4]
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
  timp->tm_mon   = (int)timespec->month - 1;
 8001e46:	7844      	ldrb	r4, [r0, #1]
void rtcConvertDateTimeToStructTm(const RTCDateTime *timespec,
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
 8001e48:	f890 c000 	ldrb.w	ip, [r0]
  timp->tm_mon   = (int)timespec->month - 1;
  timp->tm_mday  = (int)timespec->day;
 8001e4c:	f890 8002 	ldrb.w	r8, [r0, #2]
  timp->tm_isdst = (int)timespec->dstflag;
  timp->tm_wday  = (int)timespec->dayofweek - 1;

  sec = (int)timespec->millisecond / 1000;
 8001e50:	f644 55d3 	movw	r5, #19923	; 0x4dd3
 8001e54:	f3c6 061a 	ubfx	r6, r6, #0, #27
 8001e58:	f2c1 0562 	movt	r5, #4194	; 0x1062
 8001e5c:	fb85 0306 	smull	r0, r3, r5, r6
  timp->tm_hour = sec / 3600;
 8001e60:	f24b 37c5 	movw	r7, #46021	; 0xb3c5
  timp->tm_mon   = (int)timespec->month - 1;
  timp->tm_mday  = (int)timespec->day;
  timp->tm_isdst = (int)timespec->dstflag;
  timp->tm_wday  = (int)timespec->dayofweek - 1;

  sec = (int)timespec->millisecond / 1000;
 8001e64:	099b      	lsrs	r3, r3, #6
  timp->tm_hour = sec / 3600;
 8001e66:	f2c9 17a2 	movt	r7, #37282	; 0x91a2
 8001e6a:	fb87 9703 	smull	r9, r7, r7, r3
 8001e6e:	441f      	add	r7, r3
  sec %= 3600;
 8001e70:	f44f 6961 	mov.w	r9, #3600	; 0xe10
  timp->tm_mday  = (int)timespec->day;
  timp->tm_isdst = (int)timespec->dstflag;
  timp->tm_wday  = (int)timespec->dayofweek - 1;

  sec = (int)timespec->millisecond / 1000;
  timp->tm_hour = sec / 3600;
 8001e74:	12ff      	asrs	r7, r7, #11
  sec %= 3600;
  timp->tm_min = sec / 60;
 8001e76:	f648 0089 	movw	r0, #34953	; 0x8889
  timp->tm_isdst = (int)timespec->dstflag;
  timp->tm_wday  = (int)timespec->dayofweek - 1;

  sec = (int)timespec->millisecond / 1000;
  timp->tm_hour = sec / 3600;
  sec %= 3600;
 8001e7a:	fb09 3317 	mls	r3, r9, r7, r3
  timp->tm_min = sec / 60;
 8001e7e:	f6c8 0088 	movt	r0, #34952	; 0x8888
 8001e82:	fb80 9003 	smull	r9, r0, r0, r3
 8001e86:	4418      	add	r0, r3
 8001e88:	ea4f 79e3 	mov.w	r9, r3, asr #31
 8001e8c:	ebc9 1060 	rsb	r0, r9, r0, asr #5
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
  timp->tm_mon   = (int)timespec->month - 1;
 8001e90:	f004 0b0f 	and.w	fp, r4, #15
  timp->tm_mday  = (int)timespec->day;
  timp->tm_isdst = (int)timespec->dstflag;
  timp->tm_wday  = (int)timespec->dayofweek - 1;
 8001e94:	ea4f 1a54 	mov.w	sl, r4, lsr #5

  sec = (int)timespec->millisecond / 1000;
  timp->tm_hour = sec / 3600;
  sec %= 3600;
  timp->tm_min = sec / 60;
  timp->tm_sec = sec % 60;
 8001e98:	ebc0 1900 	rsb	r9, r0, r0, lsl #4
void rtcConvertDateTimeToStructTm(const RTCDateTime *timespec,
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
 8001e9c:	f10c 0c50 	add.w	ip, ip, #80	; 0x50
  timp->tm_mon   = (int)timespec->month - 1;
 8001ea0:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
  timp->tm_mday  = (int)timespec->day;
 8001ea4:	f008 081f 	and.w	r8, r8, #31
  timp->tm_isdst = (int)timespec->dstflag;
 8001ea8:	f3c4 1400 	ubfx	r4, r4, #4, #1
  timp->tm_wday  = (int)timespec->dayofweek - 1;
 8001eac:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff

  sec = (int)timespec->millisecond / 1000;
  timp->tm_hour = sec / 3600;
  sec %= 3600;
  timp->tm_min = sec / 60;
  timp->tm_sec = sec % 60;
 8001eb0:	eba3 0389 	sub.w	r3, r3, r9, lsl #2
void rtcConvertDateTimeToStructTm(const RTCDateTime *timespec,
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
 8001eb4:	f8c1 c014 	str.w	ip, [r1, #20]
  timp->tm_mon   = (int)timespec->month - 1;
 8001eb8:	f8c1 b010 	str.w	fp, [r1, #16]
  timp->tm_mday  = (int)timespec->day;
 8001ebc:	f8c1 800c 	str.w	r8, [r1, #12]
  timp->tm_isdst = (int)timespec->dstflag;
 8001ec0:	620c      	str	r4, [r1, #32]
  timp->tm_wday  = (int)timespec->dayofweek - 1;
 8001ec2:	f8c1 a018 	str.w	sl, [r1, #24]

  sec = (int)timespec->millisecond / 1000;
  timp->tm_hour = sec / 3600;
 8001ec6:	608f      	str	r7, [r1, #8]
  sec %= 3600;
  timp->tm_min = sec / 60;
 8001ec8:	6048      	str	r0, [r1, #4]
  timp->tm_sec = sec % 60;
 8001eca:	600b      	str	r3, [r1, #0]

  if (NULL != tv_msec) {
 8001ecc:	b13a      	cbz	r2, 8001ede <rtcConvertDateTimeToStructTm+0x9e>
    *tv_msec = (uint32_t)timespec->millisecond % 1000U;
 8001ece:	fba5 0506 	umull	r0, r5, r5, r6
 8001ed2:	09ad      	lsrs	r5, r5, #6
 8001ed4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001ed8:	fb03 6615 	mls	r6, r3, r5, r6
 8001edc:	6016      	str	r6, [r2, #0]
  }
}
 8001ede:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001ee2:	4770      	bx	lr
 8001ee4:	f3af 8000 	nop.w
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <rtcConvertStructTmToDateTime>:
 *
 * @api
 */
void rtcConvertStructTmToDateTime(const struct tm *timp,
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {
 8001ef0:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
 8001ef4:	6906      	ldr	r6, [r0, #16]
  timespec->day       = (uint32_t)timp->tm_mday;
 8001ef6:	7894      	ldrb	r4, [r2, #2]
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
  if (-1 == timp->tm_isdst) {
 8001ef8:	6a05      	ldr	r5, [r0, #32]

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
  timespec->day       = (uint32_t)timp->tm_mday;
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
 8001efa:	6987      	ldr	r7, [r0, #24]
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
 8001efc:	7853      	ldrb	r3, [r2, #1]
 8001efe:	f106 0801 	add.w	r8, r6, #1
void rtcConvertStructTmToDateTime(const struct tm *timp,
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
 8001f02:	6946      	ldr	r6, [r0, #20]
 8001f04:	f1a6 0c50 	sub.w	ip, r6, #80	; 0x50
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
  timespec->day       = (uint32_t)timp->tm_mday;
 8001f08:	68c6      	ldr	r6, [r0, #12]
void rtcConvertStructTmToDateTime(const struct tm *timp,
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
 8001f0a:	f882 c000 	strb.w	ip, [r2]
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
  timespec->day       = (uint32_t)timp->tm_mday;
 8001f0e:	f366 0404 	bfi	r4, r6, #0, #5
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
 8001f12:	f368 0303 	bfi	r3, r8, #0, #4
  timespec->day       = (uint32_t)timp->tm_mday;
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
 8001f16:	3701      	adds	r7, #1
                                  RTCDateTime *timespec) {

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
  timespec->day       = (uint32_t)timp->tm_mday;
 8001f18:	7094      	strb	r4, [r2, #2]
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
  if (-1 == timp->tm_isdst) {
 8001f1a:	1c6c      	adds	r4, r5, #1
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
                                                (timp->tm_min * 60) +
 8001f1c:	c851      	ldmia	r0, {r0, r4, r6}

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
  timespec->day       = (uint32_t)timp->tm_mday;
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
 8001f1e:	f367 1347 	bfi	r3, r7, #5, #3
 8001f22:	7053      	strb	r3, [r2, #1]
  if (-1 == timp->tm_isdst) {
    timespec->dstflag = 0U;  /* set zero if dst is unknown */
  }
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
 8001f24:	bf18      	it	ne
 8001f26:	7853      	ldrbne	r3, [r2, #1]
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
                                                (timp->tm_min * 60) +
 8001f28:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
  timespec->day       = (uint32_t)timp->tm_mday;
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
  if (-1 == timp->tm_isdst) {
    timespec->dstflag = 0U;  /* set zero if dst is unknown */
 8001f2c:	bf0c      	ite	eq
 8001f2e:	b2db      	uxtbeq	r3, r3
  }
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
 8001f30:	f365 1304 	bfine	r3, r5, #4, #1
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
                                                (timp->tm_min * 60) +
 8001f34:	ea4f 0584 	mov.w	r5, r4, lsl #2
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 8001f38:	f44f 6461 	mov.w	r4, #3600	; 0xe10
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
  timespec->day       = (uint32_t)timp->tm_mday;
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
  if (-1 == timp->tm_isdst) {
    timespec->dstflag = 0U;  /* set zero if dst is unknown */
 8001f3c:	bf08      	it	eq
 8001f3e:	f36f 1304 	bfceq	r3, #4, #1
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 8001f42:	fb04 5406 	mla	r4, r4, r6, r5
                                                (timp->tm_min * 60) +
 8001f46:	4404      	add	r4, r0
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
  if (-1 == timp->tm_isdst) {
    timespec->dstflag = 0U;  /* set zero if dst is unknown */
  }
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
 8001f48:	7053      	strb	r3, [r2, #1]
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
 8001f4a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 8001f4e:	6853      	ldr	r3, [r2, #4]
 8001f50:	fb00 1104 	mla	r1, r0, r4, r1
 8001f54:	f361 031a 	bfi	r3, r1, #0, #27
 8001f58:	6053      	str	r3, [r2, #4]
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
  /*lint -restore*/
}
 8001f5a:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8001f5e:	4770      	bx	lr

08001f60 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
 8001f60:	f001 bfee 	b.w	8003f40 <uart_lld_init>
 8001f64:	f3af 8000 	nop.w
 8001f68:	f3af 8000 	nop.w
 8001f6c:	f3af 8000 	nop.w

08001f70 <uartObjectInit>:
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
  uartp->txstate    = UART_TX_IDLE;
 8001f70:	2300      	movs	r3, #0
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
 8001f72:	2201      	movs	r2, #1
 8001f74:	7002      	strb	r2, [r0, #0]
  uartp->txstate    = UART_TX_IDLE;
 8001f76:	7043      	strb	r3, [r0, #1]
  uartp->rxstate    = UART_RX_IDLE;
 8001f78:	7083      	strb	r3, [r0, #2]
  uartp->config     = NULL;
 8001f7a:	6043      	str	r3, [r0, #4]
 8001f7c:	4770      	bx	lr
 8001f7e:	bf00      	nop

08001f80 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
 8001f80:	b510      	push	{r4, lr}
 8001f82:	2320      	movs	r3, #32
 8001f84:	4604      	mov	r4, r0
 8001f86:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uartp->config = config;
 8001f8a:	6041      	str	r1, [r0, #4]
  uart_lld_start(uartp);
 8001f8c:	f001 fff0 	bl	8003f70 <uart_lld_start>
  uartp->state = UART_READY;
 8001f90:	2302      	movs	r3, #2
 8001f92:	7023      	strb	r3, [r4, #0]
 8001f94:	2300      	movs	r3, #0
 8001f96:	f383 8811 	msr	BASEPRI, r3
 8001f9a:	bd10      	pop	{r4, pc}
 8001f9c:	f3af 8000 	nop.w

08001fa0 <uartStartSend>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void uartStartSend(UARTDriver *uartp, size_t n, const void *txbuf) {
 8001fa0:	b510      	push	{r4, lr}
 8001fa2:	2320      	movs	r3, #32
 8001fa4:	4604      	mov	r4, r0
 8001fa6:	f383 8811 	msr	BASEPRI, r3
             
  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");

  uart_lld_start_send(uartp, n, txbuf);
 8001faa:	f002 f879 	bl	80040a0 <uart_lld_start_send>
  uartp->txstate = UART_TX_ACTIVE;
 8001fae:	2301      	movs	r3, #1
 8001fb0:	7063      	strb	r3, [r4, #1]
 8001fb2:	2300      	movs	r3, #0
 8001fb4:	f383 8811 	msr	BASEPRI, r3
 8001fb8:	bd10      	pop	{r4, pc}
 8001fba:	bf00      	nop
 8001fbc:	f3af 8000 	nop.w

08001fc0 <uartStopSend>:
 *                      stopped transmit operation.
 * @retval 0            There was no transmit operation in progress.
 *
 * @api
 */
size_t uartStopSend(UARTDriver *uartp) {
 8001fc0:	b510      	push	{r4, lr}
 8001fc2:	2320      	movs	r3, #32
 8001fc4:	4604      	mov	r4, r0
 8001fc6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(uartp != NULL);

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->txstate == UART_TX_ACTIVE) {
 8001fca:	7843      	ldrb	r3, [r0, #1]
 8001fcc:	2b01      	cmp	r3, #1
    n = uart_lld_stop_send(uartp);
    uartp->txstate = UART_TX_IDLE;
  }
  else {
    n = 0;
 8001fce:	bf18      	it	ne
 8001fd0:	2000      	movne	r0, #0
  osalDbgCheck(uartp != NULL);

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->txstate == UART_TX_ACTIVE) {
 8001fd2:	d003      	beq.n	8001fdc <uartStopSend+0x1c>
 8001fd4:	2300      	movs	r3, #0
 8001fd6:	f383 8811 	msr	BASEPRI, r3
    n = 0;
  }
  osalSysUnlock();

  return n;
}
 8001fda:	bd10      	pop	{r4, pc}

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->txstate == UART_TX_ACTIVE) {
    n = uart_lld_stop_send(uartp);
 8001fdc:	4620      	mov	r0, r4
 8001fde:	f002 f87f 	bl	80040e0 <uart_lld_stop_send>
    uartp->txstate = UART_TX_IDLE;
 8001fe2:	2300      	movs	r3, #0
 8001fe4:	7063      	strb	r3, [r4, #1]
 8001fe6:	2300      	movs	r3, #0
 8001fe8:	f383 8811 	msr	BASEPRI, r3
    n = 0;
  }
  osalSysUnlock();

  return n;
}
 8001fec:	bd10      	pop	{r4, pc}
 8001fee:	bf00      	nop

08001ff0 <uartStartReceive>:
 * @param[in] n         number of data frames to receive
 * @param[in] rxbuf     the pointer to the receive buffer
 *
 * @api
 */
void uartStartReceive(UARTDriver *uartp, size_t n, void *rxbuf) {
 8001ff0:	b510      	push	{r4, lr}
 8001ff2:	2320      	movs	r3, #32
 8001ff4:	4604      	mov	r4, r0
 8001ff6:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");

  uart_lld_start_receive(uartp, n, rxbuf);
 8001ffa:	f002 f881 	bl	8004100 <uart_lld_start_receive>
  uartp->rxstate = UART_RX_ACTIVE;
 8001ffe:	2301      	movs	r3, #1
 8002000:	70a3      	strb	r3, [r4, #2]
 8002002:	2300      	movs	r3, #0
 8002004:	f383 8811 	msr	BASEPRI, r3
 8002008:	bd10      	pop	{r4, pc}
 800200a:	bf00      	nop
 800200c:	f3af 8000 	nop.w

08002010 <uartStopReceive>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @api
 */
size_t uartStopReceive(UARTDriver *uartp) {
 8002010:	b510      	push	{r4, lr}
 8002012:	2320      	movs	r3, #32
 8002014:	4604      	mov	r4, r0
 8002016:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(uartp != NULL);

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->rxstate == UART_RX_ACTIVE) {
 800201a:	7883      	ldrb	r3, [r0, #2]
 800201c:	2b01      	cmp	r3, #1
    n = uart_lld_stop_receive(uartp);
    uartp->rxstate = UART_RX_IDLE;
  }
  else {
    n = 0;
 800201e:	bf18      	it	ne
 8002020:	2000      	movne	r0, #0
  osalDbgCheck(uartp != NULL);

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->rxstate == UART_RX_ACTIVE) {
 8002022:	d003      	beq.n	800202c <uartStopReceive+0x1c>
 8002024:	2300      	movs	r3, #0
 8002026:	f383 8811 	msr	BASEPRI, r3
    n = 0;
  }
  osalSysUnlock();

  return n;
}
 800202a:	bd10      	pop	{r4, pc}

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->rxstate == UART_RX_ACTIVE) {
    n = uart_lld_stop_receive(uartp);
 800202c:	4620      	mov	r0, r4
 800202e:	f002 f887 	bl	8004140 <uart_lld_stop_receive>
    uartp->rxstate = UART_RX_IDLE;
 8002032:	2300      	movs	r3, #0
 8002034:	70a3      	strb	r3, [r4, #2]
 8002036:	2300      	movs	r3, #0
 8002038:	f383 8811 	msr	BASEPRI, r3
    n = 0;
  }
  osalSysUnlock();

  return n;
}
 800203c:	bd10      	pop	{r4, pc}
 800203e:	bf00      	nop

08002040 <halCommunityInit>:
/**
 * @brief   HAL initialization (community part).
 *
 * @init
 */
void halCommunityInit(void) {
 8002040:	4770      	bx	lr
 8002042:	bf00      	nop
 8002044:	f3af 8000 	nop.w
 8002048:	f3af 8000 	nop.w
 800204c:	f3af 8000 	nop.w

08002050 <ow_write_bit_I.isra.1>:
 * @param[in] owp       pointer to the @p onewireDriver object
 * @param[in] bit       value to be written
 *
 * @notapi
 */
static void ow_write_bit_I(onewireDriver *owp, uint_fast8_t bit) {
 8002050:	b508      	push	{r3, lr}
 8002052:	2320      	movs	r3, #32
 8002054:	f383 8811 	msr	BASEPRI, r3
#if ONEWIRE_SYNTH_SEARCH_TEST
  _synth_ow_write_bit(owp, bit);
#else
  osalSysLockFromISR();
  if (0 == bit) {
    pwmEnableChannelI(owp->config->pwmd, owp->config->master_channel,
 8002058:	6803      	ldr	r3, [r0, #0]
 800205a:	6818      	ldr	r0, [r3, #0]
static void ow_write_bit_I(onewireDriver *owp, uint_fast8_t bit) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  _synth_ow_write_bit(owp, bit);
#else
  osalSysLockFromISR();
  if (0 == bit) {
 800205c:	b169      	cbz	r1, 800207a <ow_write_bit_I.isra.1+0x2a>
    pwmEnableChannelI(owp->config->pwmd, owp->config->master_channel,
                      ONEWIRE_ZERO_WIDTH);
  }
  else {
    pwmEnableChannelI(owp->config->pwmd, owp->config->master_channel,
 800205e:	68d9      	ldr	r1, [r3, #12]
 8002060:	68c3      	ldr	r3, [r0, #12]
 8002062:	2201      	movs	r2, #1
 8002064:	408a      	lsls	r2, r1
 8002066:	4313      	orrs	r3, r2
 8002068:	60c3      	str	r3, [r0, #12]
 800206a:	b2c9      	uxtb	r1, r1
 800206c:	2206      	movs	r2, #6
 800206e:	f001 fdc7 	bl	8003c00 <pwm_lld_enable_channel>
 8002072:	2300      	movs	r3, #0
 8002074:	f383 8811 	msr	BASEPRI, r3
 8002078:	bd08      	pop	{r3, pc}
#if ONEWIRE_SYNTH_SEARCH_TEST
  _synth_ow_write_bit(owp, bit);
#else
  osalSysLockFromISR();
  if (0 == bit) {
    pwmEnableChannelI(owp->config->pwmd, owp->config->master_channel,
 800207a:	68d9      	ldr	r1, [r3, #12]
 800207c:	68c3      	ldr	r3, [r0, #12]
 800207e:	2201      	movs	r2, #1
 8002080:	408a      	lsls	r2, r1
 8002082:	4313      	orrs	r3, r2
 8002084:	60c3      	str	r3, [r0, #12]
 8002086:	b2c9      	uxtb	r1, r1
 8002088:	223c      	movs	r2, #60	; 0x3c
 800208a:	f001 fdb9 	bl	8003c00 <pwm_lld_enable_channel>
 800208e:	2300      	movs	r3, #0
 8002090:	f383 8811 	msr	BASEPRI, r3
 8002094:	bd08      	pop	{r3, pc}
 8002096:	bf00      	nop
 8002098:	f3af 8000 	nop.w
 800209c:	f3af 8000 	nop.w

080020a0 <pwm_search_rom_cb>:

#if ONEWIRE_USE_SEARCH_ROM
/**
 * @brief     PWM adapter
 */
static void pwm_search_rom_cb(PWMDriver *pwmp) {
 80020a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 */
static void ow_search_rom_cb(PWMDriver *pwmp, onewireDriver *owp) {

  onewire_search_rom_t *sr = &owp->search_rom;

  if (0 == sr->reg.bit_step) {                    /* read direct bit */
 80020a2:	f241 2400 	movw	r4, #4608	; 0x1200
 80020a6:	f2c2 0400 	movt	r4, #8192	; 0x2000

#if ONEWIRE_USE_SEARCH_ROM
/**
 * @brief     PWM adapter
 */
static void pwm_search_rom_cb(PWMDriver *pwmp) {
 80020aa:	4605      	mov	r5, r0
 */
static void ow_search_rom_cb(PWMDriver *pwmp, onewireDriver *owp) {

  onewire_search_rom_t *sr = &owp->search_rom;

  if (0 == sr->reg.bit_step) {                    /* read direct bit */
 80020ac:	7b23      	ldrb	r3, [r4, #12]
 80020ae:	f3c3 1201 	ubfx	r2, r3, #4, #2
 80020b2:	b9ca      	cbnz	r2, 80020e8 <pwm_search_rom_cb+0x48>
 * @param[in] pwmp      pointer to the @p PWMDriver object
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @notapi
 */
static void ow_search_rom_cb(PWMDriver *pwmp, onewireDriver *owp) {
 80020b4:	6862      	ldr	r2, [r4, #4]
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 80020b6:	6951      	ldr	r1, [r2, #20]
 80020b8:	6992      	ldr	r2, [r2, #24]
 80020ba:	6909      	ldr	r1, [r1, #16]
 80020bc:	fa21 f202 	lsr.w	r2, r1, r2
 80020c0:	f002 0201 	and.w	r2, r2, #1
static void ow_search_rom_cb(PWMDriver *pwmp, onewireDriver *owp) {

  onewire_search_rom_t *sr = &owp->search_rom;

  if (0 == sr->reg.bit_step) {                    /* read direct bit */
    sr->reg.bit_buf |= ow_read_bit(owp);
 80020c4:	ea42 1293 	orr.w	r2, r2, r3, lsr #6
 80020c8:	f362 1387 	bfi	r3, r2, #6, #2
    sr->reg.bit_step++;
 80020cc:	2201      	movs	r2, #1
 80020ce:	f362 1305 	bfi	r3, r2, #4, #2
 80020d2:	7323      	strb	r3, [r4, #12]
    sr->reg.bit_step = 0;
    sr->reg.bit_buf = 0;
  }

  /* one ROM successfully discovered */
  if (64 == sr->reg.rombit) {
 80020d4:	7b62      	ldrb	r2, [r4, #13]
 80020d6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80020da:	f241 2300 	movw	r3, #4608	; 0x1200
 80020de:	2a40      	cmp	r2, #64	; 0x40
 80020e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80020e4:	d051      	beq.n	800218a <pwm_search_rom_cb+0xea>
 80020e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (0 == sr->reg.bit_step) {                    /* read direct bit */
    sr->reg.bit_buf |= ow_read_bit(owp);
    sr->reg.bit_step++;
  }
  else if (1 == sr->reg.bit_step) {               /* read complement bit */
 80020e8:	2a01      	cmp	r2, #1
 80020ea:	d00a      	beq.n	8002102 <pwm_search_rom_cb+0x62>
      break;
    }
  }
  else {                                      /* start next step */
    #if !ONEWIRE_SYNTH_SEARCH_TEST
    ow_write_bit_I(owp, 1);
 80020ec:	1d20      	adds	r0, r4, #4
 80020ee:	2101      	movs	r1, #1
 80020f0:	f7ff ffae 	bl	8002050 <ow_write_bit_I.isra.1>
    #endif
    sr->reg.bit_step = 0;
 80020f4:	7b23      	ldrb	r3, [r4, #12]
    sr->reg.bit_buf = 0;
 80020f6:	f003 03cf 	and.w	r3, r3, #207	; 0xcf
 80020fa:	f36f 1387 	bfc	r3, #6, #2
 80020fe:	7323      	strb	r3, [r4, #12]
 8002100:	e7e8      	b.n	80020d4 <pwm_search_rom_cb+0x34>
 * @param[in] pwmp      pointer to the @p PWMDriver object
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @notapi
 */
static void ow_search_rom_cb(PWMDriver *pwmp, onewireDriver *owp) {
 8002102:	6862      	ldr	r2, [r4, #4]
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 8002104:	6951      	ldr	r1, [r2, #20]
 8002106:	6992      	ldr	r2, [r2, #24]
 8002108:	6909      	ldr	r1, [r1, #16]
 800210a:	40d1      	lsrs	r1, r2
 800210c:	f001 0101 	and.w	r1, r1, #1
  if (0 == sr->reg.bit_step) {                    /* read direct bit */
    sr->reg.bit_buf |= ow_read_bit(owp);
    sr->reg.bit_step++;
  }
  else if (1 == sr->reg.bit_step) {               /* read complement bit */
    sr->reg.bit_buf |= ow_read_bit(owp) << 1;
 8002110:	0049      	lsls	r1, r1, #1
 8002112:	ea41 1193 	orr.w	r1, r1, r3, lsr #6
    sr->reg.bit_step++;
 8002116:	2202      	movs	r2, #2
  if (0 == sr->reg.bit_step) {                    /* read direct bit */
    sr->reg.bit_buf |= ow_read_bit(owp);
    sr->reg.bit_step++;
  }
  else if (1 == sr->reg.bit_step) {               /* read complement bit */
    sr->reg.bit_buf |= ow_read_bit(owp) << 1;
 8002118:	f361 1387 	bfi	r3, r1, #6, #2
    sr->reg.bit_step++;
 800211c:	f362 1305 	bfi	r3, r2, #4, #2
    switch(sr->reg.bit_buf){
 8002120:	4291      	cmp	r1, r2
    sr->reg.bit_buf |= ow_read_bit(owp);
    sr->reg.bit_step++;
  }
  else if (1 == sr->reg.bit_step) {               /* read complement bit */
    sr->reg.bit_buf |= ow_read_bit(owp) << 1;
    sr->reg.bit_step++;
 8002122:	7323      	strb	r3, [r4, #12]
    switch(sr->reg.bit_buf){
 8002124:	d067      	beq.n	80021f6 <pwm_search_rom_cb+0x156>
 8002126:	2903      	cmp	r1, #3
 8002128:	f000 8084 	beq.w	8002234 <pwm_search_rom_cb+0x194>
 800212c:	2901      	cmp	r1, #1
 800212e:	d06c      	beq.n	800220a <pwm_search_rom_cb+0x16a>
      store_bit(sr, 0);
      ow_write_bit_I(owp, 0);
      break;
    case 0b00:
      /* collision */
      sr->reg.single_device = false;
 8002130:	7b23      	ldrb	r3, [r4, #12]
 8002132:	f36f 0300 	bfc	r3, #0, #1
 */
static uint_fast8_t collision_handler(onewire_search_rom_t *sr) {

  uint_fast8_t bit;

  switch(sr->reg.search_iter) {
 8002136:	b2da      	uxtb	r2, r3
 8002138:	f3c2 0140 	ubfx	r1, r2, #1, #1
      store_bit(sr, 0);
      ow_write_bit_I(owp, 0);
      break;
    case 0b00:
      /* collision */
      sr->reg.single_device = false;
 800213c:	7323      	strb	r3, [r4, #12]
 */
static uint_fast8_t collision_handler(onewire_search_rom_t *sr) {

  uint_fast8_t bit;

  switch(sr->reg.search_iter) {
 800213e:	2900      	cmp	r1, #0
 8002140:	d07d      	beq.n	800223e <pwm_search_rom_cb+0x19e>
  case ONEWIRE_SEARCH_ROM_NEXT:
    if ((int)sr->reg.rombit < sr->last_zero_branch) {
 8002142:	7b67      	ldrb	r7, [r4, #13]
 8002144:	7f26      	ldrb	r6, [r4, #28]
 8002146:	f3c7 0006 	ubfx	r0, r7, #0, #7
 800214a:	b2c3      	uxtb	r3, r0
 800214c:	fa4f fe86 	sxtb.w	lr, r6
 8002150:	4573      	cmp	r3, lr
 8002152:	f280 8086 	bge.w	8002262 <pwm_search_rom_cb+0x1c2>
 *                      'search ROM' helper structure
 * @param[in] bit       number of bit [0..63]
 */
static uint_fast8_t extract_path_bit(const uint8_t *path, uint_fast8_t bit) {
  /*                / 8          % 8                                        */
  return (path[bit >> 3] >> (bit & 7)) & 1;
 8002156:	08de      	lsrs	r6, r3, #3
 8002158:	19a1      	adds	r1, r4, r6
 800215a:	f003 0307 	and.w	r3, r3, #7
 800215e:	7d09      	ldrb	r1, [r1, #20]
 8002160:	4119      	asrs	r1, r3

  switch(sr->reg.search_iter) {
  case ONEWIRE_SEARCH_ROM_NEXT:
    if ((int)sr->reg.rombit < sr->last_zero_branch) {
      bit = extract_path_bit(sr->prev_path, sr->reg.rombit);
      if (0 == bit) {
 8002162:	f011 0101 	ands.w	r1, r1, #1
        sr->prev_zero_branch = sr->reg.rombit;
        sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
 8002166:	bf04      	itt	eq
 8002168:	f361 0283 	bfieq	r2, r1, #2, #2
 800216c:	7322      	strbeq	r2, [r4, #12]
static void store_bit(onewire_search_rom_t *sr, uint_fast8_t bit) {

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
 800216e:	6922      	ldr	r2, [r4, #16]
  switch(sr->reg.search_iter) {
  case ONEWIRE_SEARCH_ROM_NEXT:
    if ((int)sr->reg.rombit < sr->last_zero_branch) {
      bit = extract_path_bit(sr->prev_path, sr->reg.rombit);
      if (0 == bit) {
        sr->prev_zero_branch = sr->reg.rombit;
 8002170:	bf08      	it	eq
 8002172:	7760      	strbeq	r0, [r4, #29]
static void store_bit(onewire_search_rom_t *sr, uint_fast8_t bit) {

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
 8002174:	5d90      	ldrb	r0, [r2, r6]
 8002176:	fa01 f303 	lsl.w	r3, r1, r3
 800217a:	4303      	orrs	r3, r0
 800217c:	5593      	strb	r3, [r2, r6]
  sr->reg.rombit++;
 800217e:	7b63      	ldrb	r3, [r4, #13]
 8002180:	1c5a      	adds	r2, r3, #1
 8002182:	f362 0306 	bfi	r3, r2, #0, #7
 8002186:	7363      	strb	r3, [r4, #13]
 8002188:	e067      	b.n	800225a <pwm_search_rom_cb+0x1ba>
    sr->reg.bit_buf = 0;
  }

  /* one ROM successfully discovered */
  if (64 == sr->reg.rombit) {
    sr->reg.devices_found++;
 800218a:	68da      	ldr	r2, [r3, #12]
 800218c:	f3c2 31c7 	ubfx	r1, r2, #15, #8
 8002190:	3101      	adds	r1, #1
 8002192:	f361 32d6 	bfi	r2, r1, #15, #8
    sr->reg.search_iter = ONEWIRE_SEARCH_ROM_NEXT;
 8002196:	b2d0      	uxtb	r0, r2
 8002198:	f040 0002 	orr.w	r0, r0, #2
    sr->reg.bit_buf = 0;
  }

  /* one ROM successfully discovered */
  if (64 == sr->reg.rombit) {
    sr->reg.devices_found++;
 800219c:	60da      	str	r2, [r3, #12]
    sr->reg.search_iter = ONEWIRE_SEARCH_ROM_NEXT;
    if (true == sr->reg.single_device)
 800219e:	4601      	mov	r1, r0
 80021a0:	f010 0201 	ands.w	r2, r0, #1
      sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
 80021a4:	bf18      	it	ne
 80021a6:	f362 0183 	bfine	r1, r2, #2, #2
  }

  /* one ROM successfully discovered */
  if (64 == sr->reg.rombit) {
    sr->reg.devices_found++;
    sr->reg.search_iter = ONEWIRE_SEARCH_ROM_NEXT;
 80021aa:	7318      	strb	r0, [r3, #12]
    if (true == sr->reg.single_device)
      sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
 80021ac:	bf18      	it	ne
 80021ae:	7319      	strbne	r1, [r3, #12]
 80021b0:	2320      	movs	r3, #32
 80021b2:	f383 8811 	msr	BASEPRI, r3
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)pwmp;
  return;
#else
  osalSysLockFromISR();
  pwmDisableChannelI(pwmp, owp->config->master_channel);
 80021b6:	6862      	ldr	r2, [r4, #4]
 80021b8:	68eb      	ldr	r3, [r5, #12]
 80021ba:	68d1      	ldr	r1, [r2, #12]
 80021bc:	2601      	movs	r6, #1
 80021be:	fa06 f201 	lsl.w	r2, r6, r1
 80021c2:	ea23 0302 	bic.w	r3, r3, r2
 80021c6:	60eb      	str	r3, [r5, #12]
 80021c8:	4628      	mov	r0, r5
 80021ca:	b2c9      	uxtb	r1, r1
 80021cc:	f001 fd20 	bl	8003c10 <pwm_lld_disable_channel>
  pwmDisableChannelI(pwmp, owp->config->sample_channel);
 80021d0:	6862      	ldr	r2, [r4, #4]
 80021d2:	68eb      	ldr	r3, [r5, #12]
 80021d4:	6911      	ldr	r1, [r2, #16]
 80021d6:	408e      	lsls	r6, r1
 80021d8:	ea23 0306 	bic.w	r3, r3, r6
 80021dc:	60eb      	str	r3, [r5, #12]
 80021de:	4628      	mov	r0, r5
 80021e0:	b2c9      	uxtb	r1, r1
 80021e2:	f001 fd15 	bl	8003c10 <pwm_lld_disable_channel>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 80021e6:	482d      	ldr	r0, [pc, #180]	; (800229c <pwm_search_rom_cb+0x1fc>)
 80021e8:	2100      	movs	r1, #0
 80021ea:	f7ff fc19 	bl	8001a20 <chThdResumeI>
 80021ee:	2300      	movs	r3, #0
 80021f0:	f383 8811 	msr	BASEPRI, r3
 80021f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 * @param[in] bit       discovered bit to be stored in helper structure
 */
static void store_bit(onewire_search_rom_t *sr, uint_fast8_t bit) {

  size_t rb = sr->reg.rombit;
 80021f6:	7b63      	ldrb	r3, [r4, #13]

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
  sr->reg.rombit++;
 80021f8:	1c5a      	adds	r2, r3, #1
 80021fa:	f362 0306 	bfi	r3, r2, #0, #7
      ow_write_bit_I(owp, 1);
      break;
    case 0b10:
      /* all slaves have 0 in this position */
      store_bit(sr, 0);
      ow_write_bit_I(owp, 0);
 80021fe:	1d20      	adds	r0, r4, #4
 8002200:	2100      	movs	r1, #0

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
  sr->reg.rombit++;
 8002202:	7363      	strb	r3, [r4, #13]
      ow_write_bit_I(owp, 1);
      break;
    case 0b10:
      /* all slaves have 0 in this position */
      store_bit(sr, 0);
      ow_write_bit_I(owp, 0);
 8002204:	f7ff ff24 	bl	8002050 <ow_write_bit_I.isra.1>
 8002208:	e764      	b.n	80020d4 <pwm_search_rom_cb+0x34>
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 * @param[in] bit       discovered bit to be stored in helper structure
 */
static void store_bit(onewire_search_rom_t *sr, uint_fast8_t bit) {

  size_t rb = sr->reg.rombit;
 800220a:	7b60      	ldrb	r0, [r4, #13]

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
 800220c:	6922      	ldr	r2, [r4, #16]
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 * @param[in] bit       discovered bit to be stored in helper structure
 */
static void store_bit(onewire_search_rom_t *sr, uint_fast8_t bit) {

  size_t rb = sr->reg.rombit;
 800220e:	f000 007f 	and.w	r0, r0, #127	; 0x7f

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
 8002212:	08c3      	lsrs	r3, r0, #3
 8002214:	f000 0007 	and.w	r0, r0, #7
 8002218:	5cd6      	ldrb	r6, [r2, r3]
 800221a:	fa01 f000 	lsl.w	r0, r1, r0
 800221e:	4330      	orrs	r0, r6
 8002220:	54d0      	strb	r0, [r2, r3]
  sr->reg.rombit++;
 8002222:	7b63      	ldrb	r3, [r4, #13]
 8002224:	1c5a      	adds	r2, r3, #1
 8002226:	f362 0306 	bfi	r3, r2, #0, #7
      goto THE_END;
      break;
    case 0b01:
      /* all slaves have 1 in this position */
      store_bit(sr, 1);
      ow_write_bit_I(owp, 1);
 800222a:	1d20      	adds	r0, r4, #4

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
  sr->reg.rombit++;
 800222c:	7363      	strb	r3, [r4, #13]
      goto THE_END;
      break;
    case 0b01:
      /* all slaves have 1 in this position */
      store_bit(sr, 1);
      ow_write_bit_I(owp, 1);
 800222e:	f7ff ff0f 	bl	8002050 <ow_write_bit_I.isra.1>
 8002232:	e74f      	b.n	80020d4 <pwm_search_rom_cb+0x34>
    sr->reg.bit_buf |= ow_read_bit(owp) << 1;
    sr->reg.bit_step++;
    switch(sr->reg.bit_buf){
    case 0b11:
      /* no one device on bus or any other fail happened */
      sr->reg.result = ONEWIRE_SEARCH_ROM_ERROR;
 8002234:	7b23      	ldrb	r3, [r4, #12]
 8002236:	f362 0383 	bfi	r3, r2, #2, #2
 800223a:	7323      	strb	r3, [r4, #12]
 800223c:	e7b8      	b.n	80021b0 <pwm_search_rom_cb+0x110>
    break;

  case ONEWIRE_SEARCH_ROM_FIRST:
    /* always take 0-branch */
    sr->prev_zero_branch = sr->last_zero_branch;
    sr->last_zero_branch = sr->reg.rombit;
 800223e:	7b61      	ldrb	r1, [r4, #13]
    }
    break;

  case ONEWIRE_SEARCH_ROM_FIRST:
    /* always take 0-branch */
    sr->prev_zero_branch = sr->last_zero_branch;
 8002240:	7f20      	ldrb	r0, [r4, #28]
    sr->last_zero_branch = sr->reg.rombit;
 8002242:	f3c1 0306 	ubfx	r3, r1, #0, #7

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
  sr->reg.rombit++;
 8002246:	1c5e      	adds	r6, r3, #1
 8002248:	f366 0106 	bfi	r1, r6, #0, #7
  case ONEWIRE_SEARCH_ROM_FIRST:
    /* always take 0-branch */
    sr->prev_zero_branch = sr->last_zero_branch;
    sr->last_zero_branch = sr->reg.rombit;
    store_bit(sr, 0);
    sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
 800224c:	f36f 0283 	bfc	r2, #2, #2

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
  sr->reg.rombit++;
 8002250:	7361      	strb	r1, [r4, #13]
  case ONEWIRE_SEARCH_ROM_FIRST:
    /* always take 0-branch */
    sr->prev_zero_branch = sr->last_zero_branch;
    sr->last_zero_branch = sr->reg.rombit;
    store_bit(sr, 0);
    sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
 8002252:	7322      	strb	r2, [r4, #12]
    break;

  case ONEWIRE_SEARCH_ROM_FIRST:
    /* always take 0-branch */
    sr->prev_zero_branch = sr->last_zero_branch;
    sr->last_zero_branch = sr->reg.rombit;
 8002254:	7723      	strb	r3, [r4, #28]
    }
    break;

  case ONEWIRE_SEARCH_ROM_FIRST:
    /* always take 0-branch */
    sr->prev_zero_branch = sr->last_zero_branch;
 8002256:	7760      	strb	r0, [r4, #29]
    sr->last_zero_branch = sr->reg.rombit;
    store_bit(sr, 0);
    sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
    return 0;
 8002258:	2100      	movs	r1, #0
      ow_write_bit_I(owp, 0);
      break;
    case 0b00:
      /* collision */
      sr->reg.single_device = false;
      ow_write_bit_I(owp, collision_handler(sr));
 800225a:	4811      	ldr	r0, [pc, #68]	; (80022a0 <pwm_search_rom_cb+0x200>)
 800225c:	f7ff fef8 	bl	8002050 <ow_write_bit_I.isra.1>
 8002260:	e738      	b.n	80020d4 <pwm_search_rom_cb+0x34>
        sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
      }
      store_bit(sr, bit);
      return bit;
    }
    else if ((int)sr->reg.rombit == sr->last_zero_branch) {
 8002262:	d00a      	beq.n	800227a <pwm_search_rom_cb+0x1da>

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
  sr->reg.rombit++;
 8002264:	3301      	adds	r3, #1
 8002266:	f363 0706 	bfi	r7, r3, #0, #7
    else {
      /* found next branch some levels deeper */
      sr->prev_zero_branch = sr->last_zero_branch;
      sr->last_zero_branch = sr->reg.rombit;
      store_bit(sr, 0);
      sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
 800226a:	f36f 0283 	bfc	r2, #2, #2

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
  sr->reg.rombit++;
 800226e:	7367      	strb	r7, [r4, #13]
    else {
      /* found next branch some levels deeper */
      sr->prev_zero_branch = sr->last_zero_branch;
      sr->last_zero_branch = sr->reg.rombit;
      store_bit(sr, 0);
      sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
 8002270:	7322      	strb	r2, [r4, #12]
      store_bit(sr, 1);
      return 1;
    }
    else {
      /* found next branch some levels deeper */
      sr->prev_zero_branch = sr->last_zero_branch;
 8002272:	7766      	strb	r6, [r4, #29]
      sr->last_zero_branch = sr->reg.rombit;
 8002274:	7720      	strb	r0, [r4, #28]
      store_bit(sr, 0);
      sr->reg.result = ONEWIRE_SEARCH_ROM_SUCCESS;
      return 0;
 8002276:	2100      	movs	r1, #0
 8002278:	e7ef      	b.n	800225a <pwm_search_rom_cb+0x1ba>
      }
      store_bit(sr, bit);
      return bit;
    }
    else if ((int)sr->reg.rombit == sr->last_zero_branch) {
      sr->last_zero_branch = sr->prev_zero_branch;
 800227a:	7f62      	ldrb	r2, [r4, #29]
static void store_bit(onewire_search_rom_t *sr, uint_fast8_t bit) {

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
 800227c:	6920      	ldr	r0, [r4, #16]
      }
      store_bit(sr, bit);
      return bit;
    }
    else if ((int)sr->reg.rombit == sr->last_zero_branch) {
      sr->last_zero_branch = sr->prev_zero_branch;
 800227e:	7722      	strb	r2, [r4, #28]
static void store_bit(onewire_search_rom_t *sr, uint_fast8_t bit) {

  size_t rb = sr->reg.rombit;

  /*             / 8                % 8                                     */
  sr->retbuf[rb >> 3] |= bit << (rb & 7);
 8002280:	08da      	lsrs	r2, r3, #3
 8002282:	f003 0307 	and.w	r3, r3, #7
 8002286:	5c86      	ldrb	r6, [r0, r2]
 8002288:	fa01 f303 	lsl.w	r3, r1, r3
 800228c:	4333      	orrs	r3, r6
 800228e:	5483      	strb	r3, [r0, r2]
  sr->reg.rombit++;
 8002290:	7b63      	ldrb	r3, [r4, #13]
 8002292:	1c5a      	adds	r2, r3, #1
 8002294:	f362 0306 	bfi	r3, r2, #0, #7
 8002298:	7363      	strb	r3, [r4, #13]
 800229a:	e7de      	b.n	800225a <pwm_search_rom_cb+0x1ba>
 800229c:	20001220 	.word	0x20001220
 80022a0:	20001204 	.word	0x20001204
 80022a4:	f3af 8000 	nop.w
 80022a8:	f3af 8000 	nop.w
 80022ac:	f3af 8000 	nop.w

080022b0 <pwm_write_bit_cb>:
}

/**
 * @brief     PWM adapter
 */
static void pwm_write_bit_cb(PWMDriver *pwmp) {
 80022b0:	b510      	push	{r4, lr}
 *
 * @notapi
 */
static void ow_write_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (8 == owp->reg.bit) {
 80022b2:	f241 2300 	movw	r3, #4608	; 0x1200
 80022b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80022ba:	781a      	ldrb	r2, [r3, #0]
 80022bc:	f3c2 01c3 	ubfx	r1, r2, #3, #4
 80022c0:	2908      	cmp	r1, #8
 80022c2:	d018      	beq.n	80022f6 <pwm_write_bit_cb+0x46>
      return;
    }
  }

  /* wait until timer generate last pulse */
  if (true == owp->reg.final_timeslot) {
 80022c4:	781b      	ldrb	r3, [r3, #0]
 80022c6:	f241 2400 	movw	r4, #4608	; 0x1200
 80022ca:	09da      	lsrs	r2, r3, #7
 80022cc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80022d0:	d139      	bne.n	8002346 <pwm_write_bit_cb+0x96>
    osalThreadResumeI(&owp->thread, MSG_OK);
    osalSysUnlockFromISR();
    return;
  }

  ow_write_bit_I(owp, (*owp->buf >> owp->reg.bit) & 1);
 80022d2:	68a2      	ldr	r2, [r4, #8]
 80022d4:	7811      	ldrb	r1, [r2, #0]
 80022d6:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80022da:	4119      	asrs	r1, r3
 80022dc:	f001 0101 	and.w	r1, r1, #1
 80022e0:	1d20      	adds	r0, r4, #4
 80022e2:	f7ff feb5 	bl	8002050 <ow_write_bit_I.isra.1>
  owp->reg.bit++;
 80022e6:	7823      	ldrb	r3, [r4, #0]
 80022e8:	f3c3 02c3 	ubfx	r2, r3, #3, #4
 80022ec:	3201      	adds	r2, #1
 80022ee:	f362 03c6 	bfi	r3, r2, #3, #4
 80022f2:	7023      	strb	r3, [r4, #0]
 80022f4:	bd10      	pop	{r4, pc}
static void ow_write_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (8 == owp->reg.bit) {
    owp->buf++;
    owp->reg.bit = 0;
    owp->reg.bytes--;
 80022f6:	f8b3 1001 	ldrh.w	r1, [r3, #1]
 * @notapi
 */
static void ow_write_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (8 == owp->reg.bit) {
    owp->buf++;
 80022fa:	689c      	ldr	r4, [r3, #8]
    owp->reg.bit = 0;
    owp->reg.bytes--;
 80022fc:	3901      	subs	r1, #1
 */
static void ow_write_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (8 == owp->reg.bit) {
    owp->buf++;
    owp->reg.bit = 0;
 80022fe:	f36f 02c6 	bfc	r2, #3, #4
    owp->reg.bytes--;
 8002302:	b289      	uxth	r1, r1
 * @notapi
 */
static void ow_write_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (8 == owp->reg.bit) {
    owp->buf++;
 8002304:	3401      	adds	r4, #1
    owp->reg.bit = 0;
 8002306:	701a      	strb	r2, [r3, #0]
    owp->reg.bytes--;
 8002308:	f8a3 1001 	strh.w	r1, [r3, #1]
 * @notapi
 */
static void ow_write_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (8 == owp->reg.bit) {
    owp->buf++;
 800230c:	609c      	str	r4, [r3, #8]
    owp->reg.bit = 0;
    owp->reg.bytes--;

    if (0 == owp->reg.bytes) {
 800230e:	2900      	cmp	r1, #0
 8002310:	d1d8      	bne.n	80022c4 <pwm_write_bit_cb+0x14>
 8002312:	2220      	movs	r2, #32
 8002314:	f382 8811 	msr	BASEPRI, r2
      osalSysLockFromISR();
      pwmDisableChannelI(pwmp, owp->config->master_channel);
 8002318:	685a      	ldr	r2, [r3, #4]
 800231a:	68c3      	ldr	r3, [r0, #12]
 800231c:	68d1      	ldr	r1, [r2, #12]
 800231e:	2201      	movs	r2, #1
 8002320:	408a      	lsls	r2, r1
 8002322:	ea23 0302 	bic.w	r3, r3, r2
 8002326:	60c3      	str	r3, [r0, #12]
 8002328:	b2c9      	uxtb	r1, r1
 800232a:	f001 fc71 	bl	8003c10 <pwm_lld_disable_channel>
 800232e:	2300      	movs	r3, #0
 8002330:	f383 8811 	msr	BASEPRI, r3
      osalSysUnlockFromISR();
      /* used to prevent premature timer stop from userspace */
      owp->reg.final_timeslot = true;
 8002334:	f241 2300 	movw	r3, #4608	; 0x1200
 8002338:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800233c:	781a      	ldrb	r2, [r3, #0]
 800233e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002342:	701a      	strb	r2, [r3, #0]
 8002344:	bd10      	pop	{r4, pc}
 8002346:	2320      	movs	r3, #32
 8002348:	f383 8811 	msr	BASEPRI, r3
 800234c:	2100      	movs	r1, #0
 800234e:	f104 0020 	add.w	r0, r4, #32
 8002352:	f7ff fb65 	bl	8001a20 <chThdResumeI>
 8002356:	2300      	movs	r3, #0
 8002358:	f383 8811 	msr	BASEPRI, r3
 800235c:	bd10      	pop	{r4, pc}
 800235e:	bf00      	nop

08002360 <pwm_read_bit_cb>:
}

/**
 * @brief     PWM adapter
 */
static void pwm_read_bit_cb(PWMDriver *pwmp) {
 8002360:	b570      	push	{r4, r5, r6, lr}
 *
 * @notapi
 */
static void ow_read_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (true == owp->reg.final_timeslot) {
 8002362:	f241 2300 	movw	r3, #4608	; 0x1200
 8002366:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800236a:	781a      	ldrb	r2, [r3, #0]
 800236c:	09d1      	lsrs	r1, r2, #7
 800236e:	d140      	bne.n	80023f2 <pwm_read_bit_cb+0x92>
 * @param[in] pwmp      pointer to the @p PWMDriver object
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @notapi
 */
static void ow_read_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {
 8002370:	685c      	ldr	r4, [r3, #4]
    osalThreadResumeI(&owp->thread, MSG_OK);
    osalSysUnlockFromISR();
    return;
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
 8002372:	6899      	ldr	r1, [r3, #8]
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 8002374:	6966      	ldr	r6, [r4, #20]
 8002376:	69a5      	ldr	r5, [r4, #24]
 8002378:	6936      	ldr	r6, [r6, #16]
    osalThreadResumeI(&owp->thread, MSG_OK);
    osalSysUnlockFromISR();
    return;
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
 800237a:	780c      	ldrb	r4, [r1, #0]
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 800237c:	fa26 f505 	lsr.w	r5, r6, r5
    osalThreadResumeI(&owp->thread, MSG_OK);
    osalSysUnlockFromISR();
    return;
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
 8002380:	f3c2 02c3 	ubfx	r2, r2, #3, #4
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 8002384:	f005 0501 	and.w	r5, r5, #1
    osalThreadResumeI(&owp->thread, MSG_OK);
    osalSysUnlockFromISR();
    return;
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
 8002388:	fa05 f202 	lsl.w	r2, r5, r2
 800238c:	4322      	orrs	r2, r4
 800238e:	700a      	strb	r2, [r1, #0]
    owp->reg.bit++;
 8002390:	7819      	ldrb	r1, [r3, #0]
 8002392:	f3c1 02c3 	ubfx	r2, r1, #3, #4
 8002396:	3201      	adds	r2, #1
 8002398:	f002 020f 	and.w	r2, r2, #15
 800239c:	f362 01c6 	bfi	r1, r2, #3, #4
    if (8 == owp->reg.bit) {
 80023a0:	2a08      	cmp	r2, #8
    osalSysUnlockFromISR();
    return;
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
    owp->reg.bit++;
 80023a2:	7019      	strb	r1, [r3, #0]
    if (8 == owp->reg.bit) {
 80023a4:	d000      	beq.n	80023a8 <pwm_read_bit_cb+0x48>
 80023a6:	bd70      	pop	{r4, r5, r6, pc}
      owp->reg.bit = 0;
      owp->buf++;
      owp->reg.bytes--;
 80023a8:	f8b3 2001 	ldrh.w	r2, [r3, #1]
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
    owp->reg.bit++;
    if (8 == owp->reg.bit) {
      owp->reg.bit = 0;
      owp->buf++;
 80023ac:	689c      	ldr	r4, [r3, #8]
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
    owp->reg.bit++;
    if (8 == owp->reg.bit) {
      owp->reg.bit = 0;
 80023ae:	b2c9      	uxtb	r1, r1
      owp->buf++;
      owp->reg.bytes--;
 80023b0:	3a01      	subs	r2, #1
 80023b2:	b292      	uxth	r2, r2
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
    owp->reg.bit++;
    if (8 == owp->reg.bit) {
      owp->reg.bit = 0;
 80023b4:	f36f 01c6 	bfc	r1, #3, #4
      owp->buf++;
 80023b8:	3401      	adds	r4, #1
      owp->reg.bytes--;
 80023ba:	f8a3 2001 	strh.w	r2, [r3, #1]
  }
  else {
    *owp->buf |= ow_read_bit(owp) << owp->reg.bit;
    owp->reg.bit++;
    if (8 == owp->reg.bit) {
      owp->reg.bit = 0;
 80023be:	7019      	strb	r1, [r3, #0]
      owp->buf++;
 80023c0:	609c      	str	r4, [r3, #8]
      owp->reg.bytes--;
      if (0 == owp->reg.bytes) {
 80023c2:	2a00      	cmp	r2, #0
 80023c4:	d1ef      	bne.n	80023a6 <pwm_read_bit_cb+0x46>
        owp->reg.final_timeslot = true;
 80023c6:	b2ca      	uxtb	r2, r1
 80023c8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80023cc:	701a      	strb	r2, [r3, #0]
 80023ce:	2220      	movs	r2, #32
 80023d0:	f382 8811 	msr	BASEPRI, r2
        osalSysLockFromISR();
        /* Only master channel must be stopped here.
           Sample channel will be stopped in next ISR call.
           It is still needed to generate final interrupt. */
        pwmDisableChannelI(pwmp, owp->config->master_channel);
 80023d4:	685a      	ldr	r2, [r3, #4]
 80023d6:	68c3      	ldr	r3, [r0, #12]
 80023d8:	68d1      	ldr	r1, [r2, #12]
 80023da:	2201      	movs	r2, #1
 80023dc:	408a      	lsls	r2, r1
 80023de:	ea23 0302 	bic.w	r3, r3, r2
 80023e2:	60c3      	str	r3, [r0, #12]
 80023e4:	b2c9      	uxtb	r1, r1
 80023e6:	f001 fc13 	bl	8003c10 <pwm_lld_disable_channel>
 80023ea:	2300      	movs	r3, #0
 80023ec:	f383 8811 	msr	BASEPRI, r3
 80023f0:	bd70      	pop	{r4, r5, r6, pc}
 80023f2:	2220      	movs	r2, #32
 80023f4:	f382 8811 	msr	BASEPRI, r2
 */
static void ow_read_bit_cb(PWMDriver *pwmp, onewireDriver *owp) {

  if (true == owp->reg.final_timeslot) {
    osalSysLockFromISR();
    pwmDisableChannelI(pwmp, owp->config->sample_channel);
 80023f8:	685a      	ldr	r2, [r3, #4]
 80023fa:	68c3      	ldr	r3, [r0, #12]
 80023fc:	6911      	ldr	r1, [r2, #16]
 80023fe:	2201      	movs	r2, #1
 8002400:	408a      	lsls	r2, r1
 8002402:	ea23 0302 	bic.w	r3, r3, r2
 8002406:	60c3      	str	r3, [r0, #12]
 8002408:	b2c9      	uxtb	r1, r1
 800240a:	f001 fc01 	bl	8003c10 <pwm_lld_disable_channel>
 800240e:	4804      	ldr	r0, [pc, #16]	; (8002420 <pwm_read_bit_cb+0xc0>)
 8002410:	2100      	movs	r1, #0
 8002412:	f7ff fb05 	bl	8001a20 <chThdResumeI>
 8002416:	2300      	movs	r3, #0
 8002418:	f383 8811 	msr	BASEPRI, r3
 800241c:	bd70      	pop	{r4, r5, r6, pc}
 800241e:	bf00      	nop
 8002420:	20001220 	.word	0x20001220
 8002424:	f3af 8000 	nop.w
 8002428:	f3af 8000 	nop.w
 800242c:	f3af 8000 	nop.w

08002430 <pwm_reset_cb>:
}

/**
 * @brief     PWM adapter
 */
static void pwm_reset_cb(PWMDriver *pwmp) {
 8002430:	b510      	push	{r4, lr}
 * @param[in] pwmp      pointer to the @p PWMDriver object
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @notapi
 */
static void ow_reset_cb(PWMDriver *pwmp, onewireDriver *owp) {
 8002432:	f241 2300 	movw	r3, #4608	; 0x1200
 8002436:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800243a:	6859      	ldr	r1, [r3, #4]

  owp->reg.slave_present = (PAL_LOW == ow_read_bit(owp));
 800243c:	781a      	ldrb	r2, [r3, #0]
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 800243e:	694c      	ldr	r4, [r1, #20]
 8002440:	6989      	ldr	r1, [r1, #24]
 8002442:	6924      	ldr	r4, [r4, #16]
 8002444:	fa24 f101 	lsr.w	r1, r4, r1
 8002448:	f001 0101 	and.w	r1, r1, #1
 800244c:	f081 0101 	eor.w	r1, r1, #1
 *
 * @notapi
 */
static void ow_reset_cb(PWMDriver *pwmp, onewireDriver *owp) {

  owp->reg.slave_present = (PAL_LOW == ow_read_bit(owp));
 8002450:	f361 0200 	bfi	r2, r1, #0, #1
 8002454:	701a      	strb	r2, [r3, #0]
 8002456:	2320      	movs	r3, #32
 8002458:	f383 8811 	msr	BASEPRI, r3

  osalSysLockFromISR();
  pwmDisableChannelI(pwmp, owp->config->sample_channel);
 800245c:	f241 2400 	movw	r4, #4608	; 0x1200
 8002460:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8002464:	68c3      	ldr	r3, [r0, #12]
 8002466:	6862      	ldr	r2, [r4, #4]
 8002468:	6911      	ldr	r1, [r2, #16]
 800246a:	2201      	movs	r2, #1
 800246c:	408a      	lsls	r2, r1
 800246e:	ea23 0302 	bic.w	r3, r3, r2
 8002472:	60c3      	str	r3, [r0, #12]
 8002474:	b2c9      	uxtb	r1, r1
 8002476:	f001 fbcb 	bl	8003c10 <pwm_lld_disable_channel>
 800247a:	f104 0020 	add.w	r0, r4, #32
 800247e:	2100      	movs	r1, #0
 8002480:	f7ff face 	bl	8001a20 <chThdResumeI>
 8002484:	2300      	movs	r3, #0
 8002486:	f383 8811 	msr	BASEPRI, r3
 800248a:	bd10      	pop	{r4, pc}
 800248c:	f3af 8000 	nop.w

08002490 <ow_bus_idle>:
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 8002490:	6843      	ldr	r3, [r0, #4]
 8002492:	6818      	ldr	r0, [r3, #0]
 8002494:	f7ff bc64 	b.w	8001d60 <pwmStop>
 8002498:	f3af 8000 	nop.w
 800249c:	f3af 8000 	nop.w

080024a0 <onewireObjectInit>:
void onewireObjectInit(onewireDriver *owp) {

  osalDbgCheck(NULL != owp);

  owp->config = NULL;
  owp->reg.slave_present = false;
 80024a0:	7803      	ldrb	r3, [r0, #0]
  owp->reg.state = ONEWIRE_STOP;
 80024a2:	2201      	movs	r2, #1
 80024a4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 80024a8:	f362 0342 	bfi	r3, r2, #1, #2
 80024ac:	7003      	strb	r3, [r0, #0]
  owp->thread = NULL;

  owp->reg.bytes = 0;
 80024ae:	6802      	ldr	r2, [r0, #0]
 */
void onewireObjectInit(onewireDriver *owp) {

  osalDbgCheck(NULL != owp);

  owp->config = NULL;
 80024b0:	2300      	movs	r3, #0
  owp->reg.slave_present = false;
  owp->reg.state = ONEWIRE_STOP;
  owp->thread = NULL;

  owp->reg.bytes = 0;
 80024b2:	f363 2217 	bfi	r2, r3, #8, #16
  owp->reg.bit = 0;
  owp->reg.final_timeslot = false;
 80024b6:	f002 0187 	and.w	r1, r2, #135	; 0x87
 80024ba:	f363 11c7 	bfi	r1, r3, #7, #1
 */
void onewireObjectInit(onewireDriver *owp) {

  osalDbgCheck(NULL != owp);

  owp->config = NULL;
 80024be:	e880 000c 	stmia.w	r0, {r2, r3}
  owp->reg.slave_present = false;
  owp->reg.state = ONEWIRE_STOP;
  owp->thread = NULL;
 80024c2:	6203      	str	r3, [r0, #32]

  owp->reg.bytes = 0;
  owp->reg.bit = 0;
  owp->reg.final_timeslot = false;
 80024c4:	7001      	strb	r1, [r0, #0]
  owp->buf = NULL;
 80024c6:	6083      	str	r3, [r0, #8]
 80024c8:	4770      	bx	lr
 80024ca:	bf00      	nop
 80024cc:	f3af 8000 	nop.w

080024d0 <onewireStart>:
 * @param[in] owp       pointer to the @p onewireDriver object
 * @param[in] config    pointer to the @p onewireConfig object
 *
 * @api
 */
void onewireStart(onewireDriver *owp, const onewireConfig *config) {
 80024d0:	460b      	mov	r3, r1
 80024d2:	b570      	push	{r4, r5, r6, lr}
  osalDbgCheck((NULL != config->pullup_assert) &&
               (NULL != config->pullup_release));
#endif

  owp->config = config;
  owp->config->pwmcfg->frequency = ONEWIRE_PWM_FREQUENCY;
 80024d4:	684a      	ldr	r2, [r1, #4]
  owp->config->pwmcfg->period = ONEWIRE_RESET_TOTAL_WIDTH;

#if !defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
 80024d6:	6989      	ldr	r1, [r1, #24]
#if ONEWIRE_USE_STRONG_PULLUP
  osalDbgCheck((NULL != config->pullup_assert) &&
               (NULL != config->pullup_release));
#endif

  owp->config = config;
 80024d8:	6043      	str	r3, [r0, #4]
 * @param[in] owp       pointer to the @p onewireDriver object
 * @param[in] config    pointer to the @p onewireConfig object
 *
 * @api
 */
void onewireStart(onewireDriver *owp, const onewireConfig *config) {
 80024da:	4604      	mov	r4, r0
  osalDbgCheck((NULL != config->pullup_assert) &&
               (NULL != config->pullup_release));
#endif

  owp->config = config;
  owp->config->pwmcfg->frequency = ONEWIRE_PWM_FREQUENCY;
 80024dc:	f244 2040 	movw	r0, #16960	; 0x4240
 80024e0:	f2c0 000f 	movt	r0, #15
  owp->config->pwmcfg->period = ONEWIRE_RESET_TOTAL_WIDTH;
 80024e4:	f44f 7670 	mov.w	r6, #960	; 0x3c0

#if !defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
 80024e8:	2501      	movs	r5, #1
               (NULL != config->pullup_release));
#endif

  owp->config = config;
  owp->config->pwmcfg->frequency = ONEWIRE_PWM_FREQUENCY;
  owp->config->pwmcfg->period = ONEWIRE_RESET_TOTAL_WIDTH;
 80024ea:	e882 0041 	stmia.w	r2, {r0, r6}

#if !defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
 80024ee:	fa05 f101 	lsl.w	r1, r5, r1
 80024f2:	69da      	ldr	r2, [r3, #28]
 80024f4:	6958      	ldr	r0, [r3, #20]
 80024f6:	f001 f8a3 	bl	8003640 <_pal_lld_setgroupmode>
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 80024fa:	6863      	ldr	r3, [r4, #4]
 80024fc:	6818      	ldr	r0, [r3, #0]
 80024fe:	f7ff fc2f 	bl	8001d60 <pwmStop>
#if !defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_active);
#endif
  ow_bus_idle(owp);
  owp->reg.state = ONEWIRE_READY;
 8002502:	7823      	ldrb	r3, [r4, #0]
 8002504:	2202      	movs	r2, #2
 8002506:	f362 0342 	bfi	r3, r2, #1, #2
 800250a:	7023      	strb	r3, [r4, #0]
 800250c:	bd70      	pop	{r4, r5, r6, pc}
 800250e:	bf00      	nop

08002510 <onewireStop>:
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 8002510:	6843      	ldr	r3, [r0, #4]
 *
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @api
 */
void onewireStop(onewireDriver *owp) {
 8002512:	b510      	push	{r4, lr}
 8002514:	4604      	mov	r4, r0
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 8002516:	6818      	ldr	r0, [r3, #0]
 8002518:	f7ff fc22 	bl	8001d60 <pwmStop>
  osalDbgCheck(NULL != owp);
#if ONEWIRE_USE_STRONG_PULLUP
  owp->config->pullup_release();
#endif
  ow_bus_idle(owp);
  pwmStop(owp->config->pwmd);
 800251c:	6863      	ldr	r3, [r4, #4]
 800251e:	6818      	ldr	r0, [r3, #0]
 8002520:	f7ff fc1e 	bl	8001d60 <pwmStop>
  owp->config = NULL;
  owp->reg.state = ONEWIRE_STOP;
 8002524:	7823      	ldrb	r3, [r4, #0]
 8002526:	2101      	movs	r1, #1
#if ONEWIRE_USE_STRONG_PULLUP
  owp->config->pullup_release();
#endif
  ow_bus_idle(owp);
  pwmStop(owp->config->pwmd);
  owp->config = NULL;
 8002528:	2200      	movs	r2, #0
  owp->reg.state = ONEWIRE_STOP;
 800252a:	f361 0342 	bfi	r3, r1, #1, #2
#if ONEWIRE_USE_STRONG_PULLUP
  owp->config->pullup_release();
#endif
  ow_bus_idle(owp);
  pwmStop(owp->config->pwmd);
  owp->config = NULL;
 800252e:	6062      	str	r2, [r4, #4]
  owp->reg.state = ONEWIRE_STOP;
 8002530:	7023      	strb	r3, [r4, #0]
 8002532:	bd10      	pop	{r4, pc}
 8002534:	f3af 8000 	nop.w
 8002538:	f3af 8000 	nop.w
 800253c:	f3af 8000 	nop.w

08002540 <onewireReset>:
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @return              Bool flag denoting device presence.
 * @retval true         There is at least one device on bus.
 */
bool onewireReset(onewireDriver *owp) {
 8002540:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002544:	6843      	ldr	r3, [r0, #4]
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 8002546:	6959      	ldr	r1, [r3, #20]
 8002548:	699a      	ldr	r2, [r3, #24]
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @return              Bool flag denoting device presence.
 * @retval true         There is at least one device on bus.
 */
bool onewireReset(onewireDriver *owp) {
 800254a:	4604      	mov	r4, r0
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 800254c:	6908      	ldr	r0, [r1, #16]
 800254e:	40d0      	lsrs	r0, r2

  osalDbgCheck(NULL != owp);
  osalDbgAssert(owp->reg.state == ONEWIRE_READY, "Invalid state");

  /* short circuit on bus or any other device transmit data */
  if (PAL_LOW == ow_read_bit(owp))
 8002550:	f010 0001 	ands.w	r0, r0, #1
 8002554:	d101      	bne.n	800255a <onewireReset+0x1a>
  ow_bus_idle(owp);

  /* wait until slave release bus to discriminate short circuit condition */
  osalThreadSleepMicroseconds(500);
  return (PAL_HIGH == ow_read_bit(owp)) && (true == owp->reg.slave_present);
}
 8002556:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  /* short circuit on bus or any other device transmit data */
  if (PAL_LOW == ow_read_bit(owp))
    return false;

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
 800255a:	685a      	ldr	r2, [r3, #4]
  mch = owp->config->master_channel;
 800255c:	68df      	ldr	r7, [r3, #12]
  sch = owp->config->sample_channel;
 800255e:	691e      	ldr	r6, [r3, #16]


  pwmcfg->period = ONEWIRE_RESET_LOW_WIDTH + ONEWIRE_RESET_SAMPLE_WIDTH;
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
 8002560:	f8d3 8008 	ldr.w	r8, [r3, #8]

  /* short circuit on bus or any other device transmit data */
  if (PAL_LOW == ow_read_bit(owp))
    return false;

  pwmd = owp->config->pwmd;
 8002564:	681d      	ldr	r5, [r3, #0]
 8002566:	eb02 00c7 	add.w	r0, r2, r7, lsl #3
 800256a:	eb02 01c6 	add.w	r1, r2, r6, lsl #3

  pwmcfg->period = ONEWIRE_RESET_LOW_WIDTH + ONEWIRE_RESET_SAMPLE_WIDTH;
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_reset_cb;
 800256e:	f242 4331 	movw	r3, #9265	; 0x2431
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;


  pwmcfg->period = ONEWIRE_RESET_LOW_WIDTH + ONEWIRE_RESET_SAMPLE_WIDTH;
  pwmcfg->callback = NULL;
 8002572:	f04f 0e00 	mov.w	lr, #0
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_reset_cb;
  pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;
 8002576:	f04f 0c02 	mov.w	ip, #2
  pwmcfg = owp->config->pwmcfg;
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;


  pwmcfg->period = ONEWIRE_RESET_LOW_WIDTH + ONEWIRE_RESET_SAMPLE_WIDTH;
 800257a:	f240 4906 	movw	r9, #1030	; 0x406
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_reset_cb;
 800257e:	f6c0 0300 	movt	r3, #2048	; 0x800
  pwmcfg = owp->config->pwmcfg;
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;


  pwmcfg->period = ONEWIRE_RESET_LOW_WIDTH + ONEWIRE_RESET_SAMPLE_WIDTH;
 8002582:	f8c2 9004 	str.w	r9, [r2, #4]
  pwmcfg->callback = NULL;
 8002586:	f8c2 e008 	str.w	lr, [r2, #8]
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
 800258a:	f8c0 800c 	str.w	r8, [r0, #12]
  sch = owp->config->sample_channel;


  pwmcfg->period = ONEWIRE_RESET_LOW_WIDTH + ONEWIRE_RESET_SAMPLE_WIDTH;
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
 800258e:	f8c0 e010 	str.w	lr, [r0, #16]
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_reset_cb;
  pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;
 8002592:	f8c1 c00c 	str.w	ip, [r1, #12]

  pwmcfg->period = ONEWIRE_RESET_LOW_WIDTH + ONEWIRE_RESET_SAMPLE_WIDTH;
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_reset_cb;
 8002596:	610b      	str	r3, [r1, #16]
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @return              Bool flag denoting device presence.
 * @retval true         There is at least one device on bus.
 */
bool onewireReset(onewireDriver *owp) {
 8002598:	6863      	ldr	r3, [r4, #4]

/**
 * @brief     Put bus in active mode.
 */
static void ow_bus_active(onewireDriver *owp) {
  pwmStart(owp->config->pwmd, owp->config->pwmcfg);
 800259a:	e893 0003 	ldmia.w	r3, {r0, r1}
 800259e:	f7ff fbc7 	bl	8001d30 <pwmStart>
 80025a2:	2320      	movs	r3, #32
 80025a4:	f383 8811 	msr	BASEPRI, r3
  pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;

  ow_bus_active(owp);

  osalSysLock();
  pwmEnableChannelI(pwmd, mch, ONEWIRE_RESET_LOW_WIDTH);
 80025a8:	f04f 0801 	mov.w	r8, #1
 80025ac:	68eb      	ldr	r3, [r5, #12]
 80025ae:	fa08 f207 	lsl.w	r2, r8, r7
 80025b2:	4313      	orrs	r3, r2
 80025b4:	60eb      	str	r3, [r5, #12]
 80025b6:	b2f9      	uxtb	r1, r7
 80025b8:	4628      	mov	r0, r5
 80025ba:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 80025be:	f001 fb1f 	bl	8003c00 <pwm_lld_enable_channel>
  pwmEnableChannelI(pwmd, sch, ONEWIRE_RESET_SAMPLE_WIDTH);
 80025c2:	68eb      	ldr	r3, [r5, #12]
 80025c4:	fa08 f806 	lsl.w	r8, r8, r6
 80025c8:	ea43 0308 	orr.w	r3, r3, r8
 80025cc:	b2f6      	uxtb	r6, r6
 80025ce:	60eb      	str	r3, [r5, #12]
 80025d0:	f240 2226 	movw	r2, #550	; 0x226
 80025d4:	4631      	mov	r1, r6
 80025d6:	4628      	mov	r0, r5
 80025d8:	f001 fb12 	bl	8003c00 <pwm_lld_enable_channel>
  pwmEnableChannelNotificationI(pwmd, sch);
 80025dc:	4628      	mov	r0, r5
 80025de:	4631      	mov	r1, r6
 80025e0:	f001 fb3e 	bl	8003c60 <pwm_lld_enable_channel_notification>
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 80025e4:	f104 0020 	add.w	r0, r4, #32
 80025e8:	f7ff fa0a 	bl	8001a00 <chThdSuspendS>
 80025ec:	2300      	movs	r3, #0
 80025ee:	f383 8811 	msr	BASEPRI, r3
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 80025f2:	6863      	ldr	r3, [r4, #4]
 80025f4:	6818      	ldr	r0, [r3, #0]
 80025f6:	f7ff fbb3 	bl	8001d60 <pwmStop>
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 80025fa:	2005      	movs	r0, #5
 80025fc:	f7ff f9f0 	bl	80019e0 <chThdSleep>
 * @param[in] owp       pointer to the @p onewireDriver object
 *
 * @return              Bool flag denoting device presence.
 * @retval true         There is at least one device on bus.
 */
bool onewireReset(onewireDriver *owp) {
 8002600:	6863      	ldr	r3, [r4, #4]
static uint_fast8_t ow_read_bit(onewireDriver *owp) {
#if ONEWIRE_SYNTH_SEARCH_TEST
  (void)owp;
  return _synth_ow_read_bit();
#else
  return palReadPad(owp->config->port, owp->config->pad);
 8002602:	695a      	ldr	r2, [r3, #20]
 8002604:	699b      	ldr	r3, [r3, #24]
 8002606:	6912      	ldr	r2, [r2, #16]
 8002608:	fa22 f303 	lsr.w	r3, r2, r3

  ow_bus_idle(owp);

  /* wait until slave release bus to discriminate short circuit condition */
  osalThreadSleepMicroseconds(500);
  return (PAL_HIGH == ow_read_bit(owp)) && (true == owp->reg.slave_present);
 800260c:	07db      	lsls	r3, r3, #31
 800260e:	bf58      	it	pl
 8002610:	2000      	movpl	r0, #0
 8002612:	d5a0      	bpl.n	8002556 <onewireReset+0x16>
 8002614:	7820      	ldrb	r0, [r4, #0]
 8002616:	f000 0001 	and.w	r0, r0, #1
 800261a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800261e:	bf00      	nop

08002620 <onewireRead>:
 *
 * @param[in] owp       pointer to the @p onewireDriver object
 * @param[out] rxbuf    pointer to the buffer for read data
 * @param[in] rxbytes   amount of data to be received
 */
void onewireRead(onewireDriver *owp, uint8_t *rxbuf, size_t rxbytes) {
 8002620:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002624:	4604      	mov	r4, r0
 8002626:	4689      	mov	r9, r1
  osalDbgCheck((rxbytes > 0) && (rxbytes <= ONEWIRE_MAX_TRANSACTION_LEN));
  osalDbgAssert(owp->reg.state == ONEWIRE_READY, "Invalid state");

  /* Buffer zeroing. This is important because of driver collects
     bits using |= operation.*/
  memset(rxbuf, 0, rxbytes);
 8002628:	4608      	mov	r0, r1
 800262a:	2100      	movs	r1, #0
 *
 * @param[in] owp       pointer to the @p onewireDriver object
 * @param[out] rxbuf    pointer to the buffer for read data
 * @param[in] rxbytes   amount of data to be received
 */
void onewireRead(onewireDriver *owp, uint8_t *rxbuf, size_t rxbytes) {
 800262c:	4692      	mov	sl, r2
  osalDbgCheck((rxbytes > 0) && (rxbytes <= ONEWIRE_MAX_TRANSACTION_LEN));
  osalDbgAssert(owp->reg.state == ONEWIRE_READY, "Invalid state");

  /* Buffer zeroing. This is important because of driver collects
     bits using |= operation.*/
  memset(rxbuf, 0, rxbytes);
 800262e:	f002 fdbf 	bl	80051b0 <memset>

  pwmd = owp->config->pwmd;
 8002632:	6863      	ldr	r3, [r4, #4]
  pwmcfg = owp->config->pwmcfg;
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->reg.bit = 0; //Numero del bit que esta transmitiendo
 8002634:	f894 e000 	ldrb.w	lr, [r4]
  /* Buffer zeroing. This is important because of driver collects
     bits using |= operation.*/
  memset(rxbuf, 0, rxbytes);

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
 8002638:	685e      	ldr	r6, [r3, #4]
  mch = owp->config->master_channel;
 800263a:	f8d3 800c 	ldr.w	r8, [r3, #12]
  sch = owp->config->sample_channel;
 800263e:	691f      	ldr	r7, [r3, #16]
  owp->reg.bytes = rxbytes; //Bytes a leer

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH; //Tiempos de lectura del onewire, para el pwm
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
 8002640:	f8d3 c008 	ldr.w	ip, [r3, #8]

  /* Buffer zeroing. This is important because of driver collects
     bits using |= operation.*/
  memset(rxbuf, 0, rxbytes);

  pwmd = owp->config->pwmd;
 8002644:	681d      	ldr	r5, [r3, #0]
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->reg.bit = 0; //Numero del bit que esta transmitiendo
  owp->reg.final_timeslot = false;
  owp->buf = rxbuf; //Puntero del buffer en el que se guardan los datos
 8002646:	f8c4 9008 	str.w	r9, [r4, #8]
 800264a:	eb06 02c8 	add.w	r2, r6, r8, lsl #3
 800264e:	eb06 01c7 	add.w	r1, r6, r7, lsl #3
  pwmcfg = owp->config->pwmcfg;
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->reg.bit = 0; //Numero del bit que esta transmitiendo
  owp->reg.final_timeslot = false;
 8002652:	f00e 0e87 	and.w	lr, lr, #135	; 0x87

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH; //Tiempos de lectura del onewire, para el pwm
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_read_bit_cb;
 8002656:	f242 3361 	movw	r3, #9057	; 0x2361
  pwmcfg = owp->config->pwmcfg;
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->reg.bit = 0; //Numero del bit que esta transmitiendo
  owp->reg.final_timeslot = false;
 800265a:	f36f 1ec7 	bfc	lr, #7, #1
  owp->buf = rxbuf; //Puntero del buffer en el que se guardan los datos
  owp->reg.bytes = rxbytes; //Bytes a leer

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH; //Tiempos de lectura del onewire, para el pwm
  pwmcfg->callback = NULL;
 800265e:	2000      	movs	r0, #0
  owp->reg.bit = 0; //Numero del bit que esta transmitiendo
  owp->reg.final_timeslot = false;
  owp->buf = rxbuf; //Puntero del buffer en el que se guardan los datos
  owp->reg.bytes = rxbytes; //Bytes a leer

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH; //Tiempos de lectura del onewire, para el pwm
 8002660:	f04f 0b46 	mov.w	fp, #70	; 0x46
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_read_bit_cb;
 8002664:	f6c0 0300 	movt	r3, #2048	; 0x800
  pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;
 8002668:	f04f 0902 	mov.w	r9, #2
  pwmcfg = owp->config->pwmcfg;
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->reg.bit = 0; //Numero del bit que esta transmitiendo
  owp->reg.final_timeslot = false;
 800266c:	f884 e000 	strb.w	lr, [r4]
  owp->buf = rxbuf; //Puntero del buffer en el que se guardan los datos
  owp->reg.bytes = rxbytes; //Bytes a leer
 8002670:	f8a4 a001 	strh.w	sl, [r4, #1]

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH; //Tiempos de lectura del onewire, para el pwm
  pwmcfg->callback = NULL;
 8002674:	60b0      	str	r0, [r6, #8]
  owp->reg.bit = 0; //Numero del bit que esta transmitiendo
  owp->reg.final_timeslot = false;
  owp->buf = rxbuf; //Puntero del buffer en el que se guardan los datos
  owp->reg.bytes = rxbytes; //Bytes a leer

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH; //Tiempos de lectura del onewire, para el pwm
 8002676:	f8c6 b004 	str.w	fp, [r6, #4]
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
 800267a:	6110      	str	r0, [r2, #16]
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
 800267c:	f8c2 c00c 	str.w	ip, [r2, #12]
  pwmcfg->channels[sch].callback = pwm_read_bit_cb;
  pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;
 8002680:	f8c1 900c 	str.w	r9, [r1, #12]

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH; //Tiempos de lectura del onewire, para el pwm
  pwmcfg->callback = NULL;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = pwm_read_bit_cb;
 8002684:	610b      	str	r3, [r1, #16]
 *
 * @param[in] owp       pointer to the @p onewireDriver object
 * @param[out] rxbuf    pointer to the buffer for read data
 * @param[in] rxbytes   amount of data to be received
 */
void onewireRead(onewireDriver *owp, uint8_t *rxbuf, size_t rxbytes) {
 8002686:	6863      	ldr	r3, [r4, #4]

/**
 * @brief     Put bus in active mode.
 */
static void ow_bus_active(onewireDriver *owp) {
  pwmStart(owp->config->pwmd, owp->config->pwmcfg);
 8002688:	e893 0003 	ldmia.w	r3, {r0, r1}
 800268c:	f7ff fb50 	bl	8001d30 <pwmStart>
 8002690:	2320      	movs	r3, #32
 8002692:	f383 8811 	msr	BASEPRI, r3
  pwmcfg->channels[sch].callback = pwm_read_bit_cb;
  pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;

  ow_bus_active(owp); //Activa el Driver del One Wire
  osalSysLock();
  pwmEnableChannelI(pwmd, mch, ONEWIRE_ONE_WIDTH); // Con la configuración del pwm y lo habilita
 8002696:	2601      	movs	r6, #1
 8002698:	68eb      	ldr	r3, [r5, #12]
 800269a:	fa06 f208 	lsl.w	r2, r6, r8
 800269e:	4313      	orrs	r3, r2
 80026a0:	60eb      	str	r3, [r5, #12]
 80026a2:	fa5f f188 	uxtb.w	r1, r8
 80026a6:	4628      	mov	r0, r5
 80026a8:	2206      	movs	r2, #6
 80026aa:	f001 faa9 	bl	8003c00 <pwm_lld_enable_channel>
  pwmEnableChannelI(pwmd, sch, ONEWIRE_SAMPLE_WIDTH);
 80026ae:	68eb      	ldr	r3, [r5, #12]
 80026b0:	40be      	lsls	r6, r7
 80026b2:	4333      	orrs	r3, r6
 80026b4:	b2ff      	uxtb	r7, r7
 80026b6:	60eb      	str	r3, [r5, #12]
 80026b8:	220f      	movs	r2, #15
 80026ba:	4639      	mov	r1, r7
 80026bc:	4628      	mov	r0, r5
 80026be:	f001 fa9f 	bl	8003c00 <pwm_lld_enable_channel>
  pwmEnableChannelNotificationI(pwmd, sch);
 80026c2:	4628      	mov	r0, r5
 80026c4:	4639      	mov	r1, r7
 80026c6:	f001 facb 	bl	8003c60 <pwm_lld_enable_channel_notification>
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 80026ca:	f104 0020 	add.w	r0, r4, #32
 80026ce:	f7ff f997 	bl	8001a00 <chThdSuspendS>
 80026d2:	2300      	movs	r3, #0
 80026d4:	f383 8811 	msr	BASEPRI, r3
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 80026d8:	6863      	ldr	r3, [r4, #4]
 80026da:	6818      	ldr	r0, [r3, #0]
  pwmEnableChannelNotificationI(pwmd, sch);
  osalThreadSuspendS(&owp->thread);
  osalSysUnlock();

  ow_bus_idle(owp); //Detiene el pwm
}
 80026dc:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 80026e0:	f7ff bb3e 	b.w	8001d60 <pwmStop>
 80026e4:	f3af 8000 	nop.w
 80026e8:	f3af 8000 	nop.w
 80026ec:	f3af 8000 	nop.w

080026f0 <onewireWrite>:
#if !ONEWIRE_USE_STRONG_PULLUP
  osalDbgAssert(0 == pullup_time,
      "Non zero time is valid only when strong pull enabled");
#endif

  pwmd = owp->config->pwmd;
 80026f0:	6843      	ldr	r3, [r0, #4]
 * @param[in] txbytes       amount of data to be written
 * @param[in] pullup_time   how long strong pull up must be activated. Set
 *                          it to 0 if not needed.
 */
void onewireWrite(onewireDriver *owp, uint8_t *txbuf,
                  size_t txbytes, systime_t pullup_time) {
 80026f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  osalDbgAssert(0 == pullup_time,
      "Non zero time is valid only when strong pull enabled");
#endif

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
 80026f6:	685d      	ldr	r5, [r3, #4]
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;
 80026f8:	f8d3 8010 	ldr.w	r8, [r3, #16]

  owp->buf = txbuf; 
  owp->reg.bit = 0;
 80026fc:	f890 e000 	ldrb.w	lr, [r0]
  owp->reg.bytes = txbytes;

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
  pwmcfg->callback = pwm_write_bit_cb;
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
 8002700:	f8d3 c008 	ldr.w	ip, [r3, #8]
#if !ONEWIRE_USE_STRONG_PULLUP
  osalDbgAssert(0 == pullup_time,
      "Non zero time is valid only when strong pull enabled");
#endif

  pwmd = owp->config->pwmd;
 8002704:	681f      	ldr	r7, [r3, #0]
 * @param[in] txbytes       amount of data to be written
 * @param[in] pullup_time   how long strong pull up must be activated. Set
 *                          it to 0 if not needed.
 */
void onewireWrite(onewireDriver *owp, uint8_t *txbuf,
                  size_t txbytes, systime_t pullup_time) {
 8002706:	4604      	mov	r4, r0
      "Non zero time is valid only when strong pull enabled");
#endif

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
  mch = owp->config->master_channel;
 8002708:	68d8      	ldr	r0, [r3, #12]
  sch = owp->config->sample_channel;

  owp->buf = txbuf; 
 800270a:	60a1      	str	r1, [r4, #8]
 800270c:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 8002710:	eb05 01c8 	add.w	r1, r5, r8, lsl #3
  owp->reg.bit = 0;
  owp->reg.final_timeslot = false;
  owp->reg.bytes = txbytes;

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
  pwmcfg->callback = pwm_write_bit_cb;
 8002714:	f242 26b1 	movw	r6, #8881	; 0x22b1
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->buf = txbuf; 
  owp->reg.bit = 0;
  owp->reg.final_timeslot = false;
 8002718:	f00e 0e87 	and.w	lr, lr, #135	; 0x87
  owp->reg.bytes = txbytes;

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
  pwmcfg->callback = pwm_write_bit_cb;
  pwmcfg->channels[mch].callback = NULL;
 800271c:	2300      	movs	r3, #0
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->buf = txbuf; 
  owp->reg.bit = 0;
  owp->reg.final_timeslot = false;
 800271e:	f36f 1ec7 	bfc	lr, #7, #1
  owp->reg.bytes = txbytes;

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
 8002722:	f04f 0846 	mov.w	r8, #70	; 0x46
  pwmcfg->callback = pwm_write_bit_cb;
 8002726:	f6c0 0600 	movt	r6, #2048	; 0x800
  sch = owp->config->sample_channel;

  owp->buf = txbuf; 
  owp->reg.bit = 0;
  owp->reg.final_timeslot = false;
  owp->reg.bytes = txbytes;
 800272a:	f8a4 2001 	strh.w	r2, [r4, #1]
  mch = owp->config->master_channel;
  sch = owp->config->sample_channel;

  owp->buf = txbuf; 
  owp->reg.bit = 0;
  owp->reg.final_timeslot = false;
 800272e:	f884 e000 	strb.w	lr, [r4]
  owp->reg.bytes = txbytes;

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
 8002732:	f8c5 8004 	str.w	r8, [r5, #4]
  pwmcfg->callback = pwm_write_bit_cb;
 8002736:	60ae      	str	r6, [r5, #8]
  pwmcfg->channels[mch].callback = NULL;
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
 8002738:	f8c0 c00c 	str.w	ip, [r0, #12]
  owp->reg.final_timeslot = false;
  owp->reg.bytes = txbytes;

  pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
  pwmcfg->callback = pwm_write_bit_cb;
  pwmcfg->channels[mch].callback = NULL;
 800273c:	6103      	str	r3, [r0, #16]
  pwmcfg->channels[mch].mode = owp->config->pwmmode;
  pwmcfg->channels[sch].callback = NULL;
 800273e:	610b      	str	r3, [r1, #16]
  pwmcfg->channels[sch].mode = PWM_OUTPUT_DISABLED;
 8002740:	60cb      	str	r3, [r1, #12]
 * @param[in] txbuf         pointer to the buffer with data to be written
 * @param[in] txbytes       amount of data to be written
 * @param[in] pullup_time   how long strong pull up must be activated. Set
 *                          it to 0 if not needed.
 */
void onewireWrite(onewireDriver *owp, uint8_t *txbuf,
 8002742:	6863      	ldr	r3, [r4, #4]

/**
 * @brief     Put bus in active mode.
 */
static void ow_bus_active(onewireDriver *owp) {
  pwmStart(owp->config->pwmd, owp->config->pwmcfg);
 8002744:	e893 0003 	ldmia.w	r3, {r0, r1}
 8002748:	f7ff faf2 	bl	8001d30 <pwmStart>
 800274c:	2320      	movs	r3, #32
 800274e:	f383 8811 	msr	BASEPRI, r3
  }
#endif

  ow_bus_active(owp);
  osalSysLock();
  pwmEnablePeriodicNotificationI(pwmd);
 8002752:	4638      	mov	r0, r7
 8002754:	f001 fa6c 	bl	8003c30 <pwm_lld_enable_periodic_notification>
 8002758:	f104 0020 	add.w	r0, r4, #32
 800275c:	f7ff f950 	bl	8001a00 <chThdSuspendS>
 8002760:	2300      	movs	r3, #0
 8002762:	f383 8811 	msr	BASEPRI, r3
  osalThreadSuspendS(&owp->thread);
  osalSysUnlock();

  pwmDisablePeriodicNotification(pwmd);
 8002766:	4638      	mov	r0, r7
 8002768:	f7ff fb2a 	bl	8001dc0 <pwmDisablePeriodicNotification>
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 800276c:	6863      	ldr	r3, [r4, #4]
    osalThreadSleep(pullup_time);
    owp->config->pullup_release();
    owp->reg.state = ONEWIRE_READY;
  }
#endif
}
 800276e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 8002772:	6818      	ldr	r0, [r3, #0]
 8002774:	f7ff baf4 	b.w	8001d60 <pwmStop>
 8002778:	f3af 8000 	nop.w
 800277c:	f3af 8000 	nop.w

08002780 <onewireSearchRom>:
 *
 * @return              Count of discovered ROMs. May be more than max_rom_cnt.
 * @retval 0            no ROMs found or communication error occurred.
 */
size_t onewireSearchRom(onewireDriver *owp, uint8_t *result,
                        size_t max_rom_cnt) {
 8002780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002784:	4604      	mov	r4, r0
 8002786:	b08d      	sub	sp, #52	; 0x34

  osalDbgCheck(NULL != owp);
  osalDbgAssert(ONEWIRE_READY == owp->reg.state, "Invalid state");
  osalDbgCheck((max_rom_cnt <= 256) && (max_rom_cnt > 0));

  pwmd = owp->config->pwmd;
 8002788:	6863      	ldr	r3, [r4, #4]
 *
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 */
static void search_clean_start(onewire_search_rom_t *sr) {

  sr->reg.single_device = true; /* presume simplest way at beginning */
 800278a:	7b25      	ldrb	r5, [r4, #12]

  osalDbgCheck(NULL != owp);
  osalDbgAssert(ONEWIRE_READY == owp->reg.state, "Invalid state");
  osalDbgCheck((max_rom_cnt <= 256) && (max_rom_cnt > 0));

  pwmd = owp->config->pwmd;
 800278c:	681e      	ldr	r6, [r3, #0]
  pwmcfg = owp->config->pwmcfg;
 800278e:	685f      	ldr	r7, [r3, #4]

  osalDbgCheck(NULL != owp);
  osalDbgAssert(ONEWIRE_READY == owp->reg.state, "Invalid state");
  osalDbgCheck((max_rom_cnt <= 256) && (max_rom_cnt > 0));

  pwmd = owp->config->pwmd;
 8002790:	9601      	str	r6, [sp, #4]
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 */
static void search_clean_start(onewire_search_rom_t *sr) {

  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
 8002792:	2001      	movs	r0, #1
 8002794:	4305      	orrs	r5, r0
  osalDbgCheck((max_rom_cnt <= 256) && (max_rom_cnt > 0));

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
  cmd = ONEWIRE_CMD_SEARCH_ROM;
  mch = owp->config->master_channel;
 8002796:	68de      	ldr	r6, [r3, #12]
  sch = owp->config->sample_channel;
 8002798:	f8d3 8010 	ldr.w	r8, [r3, #16]
  osalDbgCheck((max_rom_cnt <= 256) && (max_rom_cnt > 0));

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
  cmd = ONEWIRE_CMD_SEARCH_ROM;
  mch = owp->config->master_channel;
 800279c:	9603      	str	r6, [sp, #12]
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 */
static void search_clean_start(onewire_search_rom_t *sr) {

  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
 800279e:	f360 0583 	bfi	r5, r0, #2, #2
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
 80027a2:	f36f 0541 	bfc	r5, #1, #1
 80027a6:	7325      	strb	r5, [r4, #12]
  sr->retbuf = NULL;
  sr->reg.devices_found = 0;
 80027a8:	68e3      	ldr	r3, [r4, #12]
 *
 * @return              Count of discovered ROMs. May be more than max_rom_cnt.
 * @retval 0            no ROMs found or communication error occurred.
 */
size_t onewireSearchRom(onewireDriver *owp, uint8_t *result,
                        size_t max_rom_cnt) {
 80027aa:	9109      	str	r1, [sp, #36]	; 0x24
static void search_clean_start(onewire_search_rom_t *sr) {

  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
 80027ac:	2500      	movs	r5, #0
  sr->reg.devices_found = 0;
 80027ae:	f365 33d6 	bfi	r3, r5, #15, #8
    /* Reconfiguration always needed because of previous call onewireWrite.*/
    pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
    pwmcfg->callback = NULL;
    pwmcfg->channels[mch].callback = NULL;
    pwmcfg->channels[mch].mode = owp->config->pwmmode;
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
 80027b2:	f242 06a1 	movw	r6, #8353	; 0x20a1
 *
 * @return              Count of discovered ROMs. May be more than max_rom_cnt.
 * @retval 0            no ROMs found or communication error occurred.
 */
size_t onewireSearchRom(onewireDriver *owp, uint8_t *result,
                        size_t max_rom_cnt) {
 80027b6:	9205      	str	r2, [sp, #20]
    /* Reconfiguration always needed because of previous call onewireWrite.*/
    pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
    pwmcfg->callback = NULL;
    pwmcfg->channels[mch].callback = NULL;
    pwmcfg->channels[mch].mode = owp->config->pwmmode;
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
 80027b8:	9604      	str	r6, [sp, #16]

  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
  sr->reg.devices_found = 0;
 80027ba:	60e3      	str	r3, [r4, #12]
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
    pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;

    ow_bus_active(owp);
    osalSysLock();
    pwmEnableChannelI(pwmd, mch, ONEWIRE_ONE_WIDTH);
 80027bc:	9e03      	ldr	r6, [sp, #12]
static void search_clean_start(onewire_search_rom_t *sr) {

  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
 80027be:	6125      	str	r5, [r4, #16]
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
    pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;

    ow_bus_active(owp);
    osalSysLock();
    pwmEnableChannelI(pwmd, mch, ONEWIRE_ONE_WIDTH);
 80027c0:	fa00 f606 	lsl.w	r6, r0, r6
 80027c4:	9606      	str	r6, [sp, #24]
 80027c6:	9e03      	ldr	r6, [sp, #12]
  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
  sr->reg.devices_found = 0;
  memset(sr->prev_path, 0, 8);
 80027c8:	7525      	strb	r5, [r4, #20]
    if (false == onewireReset(owp))
      return 0;

    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
 80027ca:	f102 5200 	add.w	r2, r2, #536870912	; 0x20000000
 80027ce:	eb07 09c6 	add.w	r9, r7, r6, lsl #3
 80027d2:	9e09      	ldr	r6, [sp, #36]	; 0x24
  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
  sr->reg.devices_found = 0;
  memset(sr->prev_path, 0, 8);
 80027d4:	7565      	strb	r5, [r4, #21]

  sr->reg.rombit = 0;
 80027d6:	ea4f 2c13 	mov.w	ip, r3, lsr #8
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
 80027da:	f003 0ecf 	and.w	lr, r3, #207	; 0xcf
    if (false == onewireReset(owp))
      return 0;

    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
 80027de:	3a01      	subs	r2, #1
  memset(sr->prev_path, 0, 8);

  sr->reg.rombit = 0;
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
  sr->last_zero_branch = -1;
 80027e0:	21ff      	movs	r1, #255	; 0xff
    if (false == onewireReset(owp))
      return 0;

    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
 80027e2:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
  sr->reg.devices_found = 0;
  memset(sr->prev_path, 0, 8);

  sr->reg.rombit = 0;
 80027e6:	f365 0c06 	bfi	ip, r5, #0, #7
  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
  sr->reg.devices_found = 0;
  memset(sr->prev_path, 0, 8);
 80027ea:	f104 0614 	add.w	r6, r4, #20

  sr->reg.rombit = 0;
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
 80027ee:	f365 1e87 	bfi	lr, r5, #6, #2
    pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;

    ow_bus_active(owp);
    osalSysLock();
    pwmEnableChannelI(pwmd, mch, ONEWIRE_ONE_WIDTH);
    pwmEnableChannelI(pwmd, sch, ONEWIRE_SAMPLE_WIDTH);
 80027f2:	fa00 f008 	lsl.w	r0, r0, r8
  sr->reg.single_device = true; /* presume simplest way at beginning */
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
  sr->reg.search_iter = ONEWIRE_SEARCH_ROM_FIRST;
  sr->retbuf = NULL;
  sr->reg.devices_found = 0;
  memset(sr->prev_path, 0, 8);
 80027f6:	9602      	str	r6, [sp, #8]
 80027f8:	75a5      	strb	r5, [r4, #22]
 80027fa:	75e5      	strb	r5, [r4, #23]
 80027fc:	7625      	strb	r5, [r4, #24]
 80027fe:	7665      	strb	r5, [r4, #25]
 8002800:	76a5      	strb	r5, [r4, #26]
 8002802:	76e5      	strb	r5, [r4, #27]

  sr->reg.rombit = 0;
 8002804:	f884 c00d 	strb.w	ip, [r4, #13]
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
 8002808:	f884 e00c 	strb.w	lr, [r4, #12]
    pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;

    ow_bus_active(owp);
    osalSysLock();
    pwmEnableChannelI(pwmd, mch, ONEWIRE_ONE_WIDTH);
    pwmEnableChannelI(pwmd, sch, ONEWIRE_SAMPLE_WIDTH);
 800280c:	9007      	str	r0, [sp, #28]
    if (false == onewireReset(owp))
      return 0;

    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
 800280e:	9208      	str	r2, [sp, #32]
  memset(sr->prev_path, 0, 8);

  sr->reg.rombit = 0;
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
  sr->last_zero_branch = -1;
 8002810:	7721      	strb	r1, [r4, #28]
    /* Reconfiguration always needed because of previous call onewireWrite.*/
    pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
    pwmcfg->callback = NULL;
    pwmcfg->channels[mch].callback = NULL;
    pwmcfg->channels[mch].mode = owp->config->pwmmode;
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
 8002812:	9e04      	ldr	r6, [sp, #16]

  sr->reg.rombit = 0;
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
  sr->last_zero_branch = -1;
  sr->prev_zero_branch = -1;
 8002814:	7761      	strb	r1, [r4, #29]
    /* Reconfiguration always needed because of previous call onewireWrite.*/
    pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
    pwmcfg->callback = NULL;
    pwmcfg->channels[mch].callback = NULL;
    pwmcfg->channels[mch].mode = owp->config->pwmmode;
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
 8002816:	f6c0 0600 	movt	r6, #2048	; 0x800
  osalDbgAssert(ONEWIRE_READY == owp->reg.state, "Invalid state");
  osalDbgCheck((max_rom_cnt <= 256) && (max_rom_cnt > 0));

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
  cmd = ONEWIRE_CMD_SEARCH_ROM;
 800281a:	f04f 0af0 	mov.w	sl, #240	; 0xf0
 800281e:	f245 4b44 	movw	fp, #21572	; 0x5444
    /* Reconfiguration always needed because of previous call onewireWrite.*/
    pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
    pwmcfg->callback = NULL;
    pwmcfg->channels[mch].callback = NULL;
    pwmcfg->channels[mch].mode = owp->config->pwmmode;
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
 8002822:	9604      	str	r6, [sp, #16]
 8002824:	9e01      	ldr	r6, [sp, #4]
  osalDbgAssert(ONEWIRE_READY == owp->reg.state, "Invalid state");
  osalDbgCheck((max_rom_cnt <= 256) && (max_rom_cnt > 0));

  pwmd = owp->config->pwmd;
  pwmcfg = owp->config->pwmcfg;
  cmd = ONEWIRE_CMD_SEARCH_ROM;
 8002826:	f88d a02f 	strb.w	sl, [sp, #47]	; 0x2f
 800282a:	f6c0 0b00 	movt	fp, #2048	; 0x800

  search_clean_start(&owp->search_rom);

  do {
    /* every search must be started from reset pulse */
    if (false == onewireReset(owp))
 800282e:	4620      	mov	r0, r4
 8002830:	f7ff fe86 	bl	8002540 <onewireReset>
 8002834:	2800      	cmp	r0, #0
 8002836:	f000 8094 	beq.w	8002962 <onewireSearchRom+0x1e2>
      return 0;

    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
 800283a:	68e1      	ldr	r1, [r4, #12]
 800283c:	9a05      	ldr	r2, [sp, #20]
 800283e:	f3c1 31c7 	ubfx	r1, r1, #15, #8
 8002842:	4291      	cmp	r1, r2
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
 8002844:	bf2b      	itete	cs
 8002846:	9b08      	ldrcs	r3, [sp, #32]
    else
      owp->search_rom.retbuf = result + 8*owp->search_rom.reg.devices_found;
 8002848:	9a09      	ldrcc	r2, [sp, #36]	; 0x24
    if (false == onewireReset(owp))
      return 0;

    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
 800284a:	6123      	strcs	r3, [r4, #16]
    else
      owp->search_rom.retbuf = result + 8*owp->search_rom.reg.devices_found;
 800284c:	eb02 01c1 	addcc.w	r1, r2, r1, lsl #3
 8002850:	bf28      	it	cs
 8002852:	4619      	movcs	r1, r3
    memset(owp->search_rom.retbuf, 0, 8);
 8002854:	460b      	mov	r3, r1

    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
    else
      owp->search_rom.retbuf = result + 8*owp->search_rom.reg.devices_found;
 8002856:	bf38      	it	cc
 8002858:	6121      	strcc	r1, [r4, #16]
    memset(owp->search_rom.retbuf, 0, 8);
 800285a:	f803 5b01 	strb.w	r5, [r3], #1
static void search_clean_iteration(onewire_search_rom_t *sr) {

  sr->reg.rombit = 0;
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
 800285e:	2201      	movs	r2, #1
    /* initialize buffer to store result */
    if (owp->search_rom.reg.devices_found >= max_rom_cnt)
      owp->search_rom.retbuf = result + 8*(max_rom_cnt-1);
    else
      owp->search_rom.retbuf = result + 8*owp->search_rom.reg.devices_found;
    memset(owp->search_rom.retbuf, 0, 8);
 8002860:	4413      	add	r3, r2
 8002862:	704d      	strb	r5, [r1, #1]
 8002864:	f803 5b01 	strb.w	r5, [r3], #1
 8002868:	f803 5b01 	strb.w	r5, [r3], #1
 800286c:	f803 5b01 	strb.w	r5, [r3], #1
 8002870:	f803 5b01 	strb.w	r5, [r3], #1
 8002874:	f803 5b01 	strb.w	r5, [r3], #1
 8002878:	701d      	strb	r5, [r3, #0]
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 */
static void search_clean_iteration(onewire_search_rom_t *sr) {

  sr->reg.rombit = 0;
  sr->reg.bit_step = 0;
 800287a:	7b21      	ldrb	r1, [r4, #12]
 *
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 */
static void search_clean_iteration(onewire_search_rom_t *sr) {

  sr->reg.rombit = 0;
 800287c:	7b63      	ldrb	r3, [r4, #13]
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
 800287e:	f001 010f 	and.w	r1, r1, #15
 8002882:	f362 0183 	bfi	r1, r2, #2, #2
 *
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 */
static void search_clean_iteration(onewire_search_rom_t *sr) {

  sr->reg.rombit = 0;
 8002886:	f36f 0306 	bfc	r3, #0, #7

    /* clean iteration state */
    search_clean_iteration(&owp->search_rom);

    /**/
    onewireWrite(&OWD1, &cmd, 1, 0);
 800288a:	f241 2000 	movw	r0, #4608	; 0x1200
static void search_clean_iteration(onewire_search_rom_t *sr) {

  sr->reg.rombit = 0;
  sr->reg.bit_step = 0;
  sr->reg.bit_buf = 0;
  sr->reg.result = ONEWIRE_SEARCH_ROM_LAST;
 800288e:	7321      	strb	r1, [r4, #12]
 *
 * @param[in] sr        pointer to the @p onewire_search_rom_t helper structure
 */
static void search_clean_iteration(onewire_search_rom_t *sr) {

  sr->reg.rombit = 0;
 8002890:	7363      	strb	r3, [r4, #13]

    /* clean iteration state */
    search_clean_iteration(&owp->search_rom);

    /**/
    onewireWrite(&OWD1, &cmd, 1, 0);
 8002892:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
 8002896:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800289a:	2300      	movs	r3, #0
 800289c:	f7ff ff28 	bl	80026f0 <onewireWrite>

    /* Reconfiguration always needed because of previous call onewireWrite.*/
    pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
 80028a0:	2346      	movs	r3, #70	; 0x46
 80028a2:	607b      	str	r3, [r7, #4]
    pwmcfg->callback = NULL;
 80028a4:	60bd      	str	r5, [r7, #8]
    pwmcfg->channels[mch].callback = NULL;
 80028a6:	f8c9 5010 	str.w	r5, [r9, #16]
    pwmcfg->channels[mch].mode = owp->config->pwmmode;
 80028aa:	6862      	ldr	r2, [r4, #4]
 80028ac:	6892      	ldr	r2, [r2, #8]
 80028ae:	eb07 03c8 	add.w	r3, r7, r8, lsl #3
 80028b2:	f8c9 200c 	str.w	r2, [r9, #12]
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
 80028b6:	9a04      	ldr	r2, [sp, #16]
    pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;
 80028b8:	2102      	movs	r1, #2
    /* Reconfiguration always needed because of previous call onewireWrite.*/
    pwmcfg->period = ONEWIRE_ZERO_WIDTH + ONEWIRE_RECOVERY_WIDTH;
    pwmcfg->callback = NULL;
    pwmcfg->channels[mch].callback = NULL;
    pwmcfg->channels[mch].mode = owp->config->pwmmode;
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
 80028ba:	611a      	str	r2, [r3, #16]
    pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;
 80028bc:	60d9      	str	r1, [r3, #12]
 * @param[in] max_rom_cnt buffer size in ROMs count for overflow prevention
 *
 * @return              Count of discovered ROMs. May be more than max_rom_cnt.
 * @retval 0            no ROMs found or communication error occurred.
 */
size_t onewireSearchRom(onewireDriver *owp, uint8_t *result,
 80028be:	6863      	ldr	r3, [r4, #4]

/**
 * @brief     Put bus in active mode.
 */
static void ow_bus_active(onewireDriver *owp) {
  pwmStart(owp->config->pwmd, owp->config->pwmcfg);
 80028c0:	e893 0003 	ldmia.w	r3, {r0, r1}
 80028c4:	f7ff fa34 	bl	8001d30 <pwmStart>
 80028c8:	2320      	movs	r3, #32
 80028ca:	f383 8811 	msr	BASEPRI, r3
    pwmcfg->channels[sch].callback = pwm_search_rom_cb;
    pwmcfg->channels[sch].mode = PWM_OUTPUT_ACTIVE_LOW;

    ow_bus_active(owp);
    osalSysLock();
    pwmEnableChannelI(pwmd, mch, ONEWIRE_ONE_WIDTH);
 80028ce:	68f3      	ldr	r3, [r6, #12]
 80028d0:	9906      	ldr	r1, [sp, #24]
 80028d2:	9a03      	ldr	r2, [sp, #12]
 80028d4:	430b      	orrs	r3, r1
 80028d6:	60f3      	str	r3, [r6, #12]
 80028d8:	4630      	mov	r0, r6
 80028da:	b2d1      	uxtb	r1, r2
 80028dc:	2206      	movs	r2, #6
 80028de:	f001 f98f 	bl	8003c00 <pwm_lld_enable_channel>
    pwmEnableChannelI(pwmd, sch, ONEWIRE_SAMPLE_WIDTH);
 80028e2:	68f2      	ldr	r2, [r6, #12]
 80028e4:	9907      	ldr	r1, [sp, #28]
 80028e6:	fa5f f388 	uxtb.w	r3, r8
 80028ea:	430a      	orrs	r2, r1
 80028ec:	469a      	mov	sl, r3
 80028ee:	4619      	mov	r1, r3
 80028f0:	60f2      	str	r2, [r6, #12]
 80028f2:	4630      	mov	r0, r6
 80028f4:	220f      	movs	r2, #15
 80028f6:	f001 f983 	bl	8003c00 <pwm_lld_enable_channel>
    pwmEnableChannelNotificationI(pwmd, sch);
 80028fa:	4630      	mov	r0, r6
 80028fc:	4651      	mov	r1, sl
 80028fe:	f001 f9af 	bl	8003c60 <pwm_lld_enable_channel_notification>
 8002902:	f104 0020 	add.w	r0, r4, #32
 8002906:	f7ff f87b 	bl	8001a00 <chThdSuspendS>
 800290a:	f385 8811 	msr	BASEPRI, r5
/*static*/ void ow_bus_idle(onewireDriver *owp) {
#if defined(STM32F1XX)
  palSetPadMode(owp->config->port, owp->config->pad,
      owp->config->pad_mode_idle);
#endif
  pwmStop(owp->config->pwmd);
 800290e:	6863      	ldr	r3, [r4, #4]
 8002910:	6818      	ldr	r0, [r3, #0]
 8002912:	f7ff fa25 	bl	8001d60 <pwmStop>
    osalThreadSuspendS(&owp->thread);
    osalSysUnlock();

    ow_bus_idle(owp);

    if (ONEWIRE_SEARCH_ROM_ERROR != owp->search_rom.reg.result) {
 8002916:	7b23      	ldrb	r3, [r4, #12]
 8002918:	f3c3 0381 	ubfx	r3, r3, #2, #2
 800291c:	2b02      	cmp	r3, #2
 800291e:	d020      	beq.n	8002962 <onewireSearchRom+0x1e2>
      /* check CRC and return 0 (0 == error) if mismatch */
      if (owp->search_rom.retbuf[7] != onewireCRC(owp->search_rom.retbuf, 7))
 8002920:	6920      	ldr	r0, [r4, #16]
 * @param[in] len     lenght of data buffer
 *
 * @init
 */
uint8_t onewireCRC(const uint8_t *buf, size_t len) {
  uint8_t ret = 0;
 8002922:	2200      	movs	r2, #0

    ow_bus_idle(owp);

    if (ONEWIRE_SEARCH_ROM_ERROR != owp->search_rom.reg.result) {
      /* check CRC and return 0 (0 == error) if mismatch */
      if (owp->search_rom.retbuf[7] != onewireCRC(owp->search_rom.retbuf, 7))
 8002924:	f890 c007 	ldrb.w	ip, [r0, #7]
 */
uint8_t onewireCRC(const uint8_t *buf, size_t len) {
  uint8_t ret = 0;
  size_t i;

  for (i=0; i<len; i++)
 8002928:	4613      	mov	r3, r2
    ret = onewire_crc_table[ret ^ buf[i]];
 800292a:	5cc1      	ldrb	r1, [r0, r3]
 */
uint8_t onewireCRC(const uint8_t *buf, size_t len) {
  uint8_t ret = 0;
  size_t i;

  for (i=0; i<len; i++)
 800292c:	3301      	adds	r3, #1
    ret = onewire_crc_table[ret ^ buf[i]];
 800292e:	404a      	eors	r2, r1
 */
uint8_t onewireCRC(const uint8_t *buf, size_t len) {
  uint8_t ret = 0;
  size_t i;

  for (i=0; i<len; i++)
 8002930:	2b07      	cmp	r3, #7
    ret = onewire_crc_table[ret ^ buf[i]];
 8002932:	f81b 2002 	ldrb.w	r2, [fp, r2]
 */
uint8_t onewireCRC(const uint8_t *buf, size_t len) {
  uint8_t ret = 0;
  size_t i;

  for (i=0; i<len; i++)
 8002936:	d1f8      	bne.n	800292a <onewireSearchRom+0x1aa>

    ow_bus_idle(owp);

    if (ONEWIRE_SEARCH_ROM_ERROR != owp->search_rom.reg.result) {
      /* check CRC and return 0 (0 == error) if mismatch */
      if (owp->search_rom.retbuf[7] != onewireCRC(owp->search_rom.retbuf, 7))
 8002938:	4594      	cmp	ip, r2
 800293a:	d112      	bne.n	8002962 <onewireSearchRom+0x1e2>
        return 0;
      /* store cached result for usage in next iteration */
      memcpy(owp->search_rom.prev_path, owp->search_rom.retbuf, 8);
 800293c:	6843      	ldr	r3, [r0, #4]
 800293e:	6802      	ldr	r2, [r0, #0]
 8002940:	9902      	ldr	r1, [sp, #8]
 8002942:	600a      	str	r2, [r1, #0]
 8002944:	604b      	str	r3, [r1, #4]
    }
  }
  while (ONEWIRE_SEARCH_ROM_SUCCESS == owp->search_rom.reg.result);
 8002946:	7b23      	ldrb	r3, [r4, #12]
 8002948:	f3c3 0381 	ubfx	r3, r3, #2, #2
 800294c:	2b00      	cmp	r3, #0
 800294e:	f43f af6e 	beq.w	800282e <onewireSearchRom+0xae>

  /**/
  if (ONEWIRE_SEARCH_ROM_ERROR == owp->search_rom.reg.result)
 8002952:	2b02      	cmp	r3, #2
 8002954:	d005      	beq.n	8002962 <onewireSearchRom+0x1e2>
    return 0;
  else
    return owp->search_rom.reg.devices_found;
 8002956:	68e0      	ldr	r0, [r4, #12]
 8002958:	f3c0 30c7 	ubfx	r0, r0, #15, #8
}
 800295c:	b00d      	add	sp, #52	; 0x34
 800295e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  search_clean_start(&owp->search_rom);

  do {
    /* every search must be started from reset pulse */
    if (false == onewireReset(owp))
      return 0;
 8002962:	2000      	movs	r0, #0
  /**/
  if (ONEWIRE_SEARCH_ROM_ERROR == owp->search_rom.reg.result)
    return 0;
  else
    return owp->search_rom.reg.devices_found;
}
 8002964:	b00d      	add	sp, #52	; 0x34
 8002966:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800296a:	bf00      	nop
 800296c:	f3af 8000 	nop.w

08002970 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002970:	0942      	lsrs	r2, r0, #5
 8002972:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002974:	f100 4360 	add.w	r3, r0, #3758096384	; 0xe0000000
 8002978:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 800297c:	b410      	push	{r4}
 800297e:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002982:	2401      	movs	r4, #1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002984:	0109      	lsls	r1, r1, #4
 8002986:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800298a:	f000 001f 	and.w	r0, r0, #31
 800298e:	fa04 f000 	lsl.w	r0, r4, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002992:	b2c9      	uxtb	r1, r1
 8002994:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002998:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800299c:	6010      	str	r0, [r2, #0]
}
 800299e:	f85d 4b04 	ldr.w	r4, [sp], #4
 80029a2:	4770      	bx	lr
 80029a4:	f3af 8000 	nop.w
 80029a8:	f3af 8000 	nop.w
 80029ac:	f3af 8000 	nop.w

080029b0 <nvicDisableVector>:
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80029b0:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80029b4:	0941      	lsrs	r1, r0, #5
 80029b6:	f2ce 0300 	movt	r3, #57344	; 0xe000
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 80029ba:	b410      	push	{r4}

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80029bc:	f000 021f 	and.w	r2, r0, #31
 80029c0:	3120      	adds	r1, #32
 80029c2:	2401      	movs	r4, #1
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 80029c4:	4418      	add	r0, r3
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80029c6:	4094      	lsls	r4, r2
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 80029c8:	2200      	movs	r2, #0
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80029ca:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 80029ce:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
#endif
}
 80029d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80029d6:	4770      	bx	lr
 80029d8:	f3af 8000 	nop.w
 80029dc:	f3af 8000 	nop.w

080029e0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80029e0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80029e4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80029e8:	2200      	movs	r2, #0
 80029ea:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80029ee:	6918      	ldr	r0, [r3, #16]
 80029f0:	6119      	str	r1, [r3, #16]
 80029f2:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 80029f4:	6958      	ldr	r0, [r3, #20]
 80029f6:	6159      	str	r1, [r3, #20]
 80029f8:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80029fa:	6a18      	ldr	r0, [r3, #32]
 80029fc:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8002a00:	6218      	str	r0, [r3, #32]
 8002a02:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8002a04:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002a06:	6259      	str	r1, [r3, #36]	; 0x24
 8002a08:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002a0a:	6c18      	ldr	r0, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002a0c:	f44f 41e0 	mov.w	r1, #28672	; 0x7000
 8002a10:	f2c4 0100 	movt	r1, #16384	; 0x4000
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  rccResetAPB2(~0);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002a14:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
 8002a18:	6418      	str	r0, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002a1a:	6808      	ldr	r0, [r1, #0]
 8002a1c:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8002a20:	6008      	str	r0, [r1, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8002a22:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8002a24:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8002a28:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8002a2c:	bf1e      	ittt	ne
 8002a2e:	f44f 3180 	movne.w	r1, #65536	; 0x10000
 8002a32:	6719      	strne	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8002a34:	671a      	strne	r2, [r3, #112]	; 0x70
#endif

#if HAL_USE_RTC
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8002a36:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002a3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002a3e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002a40:	0412      	lsls	r2, r2, #16
 8002a42:	d407      	bmi.n	8002a54 <hal_lld_init+0x74>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8002a44:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002a46:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002a4a:	671a      	str	r2, [r3, #112]	; 0x70

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8002a4c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002a4e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002a52:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8002a54:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8002a58:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8002a5c:	685a      	ldr	r2, [r3, #4]
 8002a5e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8002a62:	605a      	str	r2, [r3, #4]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8002a64:	f000 bb1c 	b.w	80030a0 <dmaInit>
 8002a68:	f3af 8000 	nop.w
 8002a6c:	f3af 8000 	nop.w

08002a70 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8002a70:	f44f 5160 	mov.w	r1, #14336	; 0x3800

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8002a74:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8002a78:	f2c4 0102 	movt	r1, #16386	; 0x4002

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8002a7c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8002a80:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8002a84:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8002a88:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8002a8a:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8002a8c:	680b      	ldr	r3, [r1, #0]
 8002a8e:	f043 0301 	orr.w	r3, r3, #1
 8002a92:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8002a94:	680a      	ldr	r2, [r1, #0]
 8002a96:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002a9a:	0790      	lsls	r0, r2, #30
 8002a9c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002aa0:	d5f8      	bpl.n	8002a94 <stm32_clock_init+0x24>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8002aa2:	689a      	ldr	r2, [r3, #8]
 8002aa4:	f022 0203 	bic.w	r2, r2, #3
 8002aa8:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8002aaa:	689a      	ldr	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002aac:	4619      	mov	r1, r3

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8002aae:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002ab0:	688b      	ldr	r3, [r1, #8]
 8002ab2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002ab6:	f013 030c 	ands.w	r3, r3, #12
 8002aba:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002abe:	d1f7      	bne.n	8002ab0 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8002ac0:	6811      	ldr	r1, [r2, #0]
 8002ac2:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8002ac6:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8002ac8:	6093      	str	r3, [r2, #8]
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8002aca:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8002acc:	f043 0301 	orr.w	r3, r3, #1
 8002ad0:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8002ad2:	6f51      	ldr	r1, [r2, #116]	; 0x74
 8002ad4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002ad8:	0789      	lsls	r1, r1, #30
 8002ada:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002ade:	d5f8      	bpl.n	8002ad2 <stm32_clock_init+0x62>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8002ae0:	f245 4210 	movw	r2, #21520	; 0x5410
 8002ae4:	f2c0 7201 	movt	r2, #1793	; 0x701
 8002ae8:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8002aea:	6819      	ldr	r1, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8002aec:	f44f 42e0 	mov.w	r2, #28672	; 0x7000

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8002af0:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8002af4:	6019      	str	r1, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8002af6:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8002afa:	6853      	ldr	r3, [r2, #4]
 8002afc:	045b      	lsls	r3, r3, #17
 8002afe:	d5fc      	bpl.n	8002afa <stm32_clock_init+0x8a>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8002b00:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8002b04:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002b08:	680a      	ldr	r2, [r1, #0]
 8002b0a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002b0e:	0190      	lsls	r0, r2, #6
 8002b10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002b14:	d5f8      	bpl.n	8002b08 <stm32_clock_init+0x98>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8002b16:	f44f 5180 	mov.w	r1, #4096	; 0x1000

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8002b1a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8002b1e:	f6c3 0188 	movt	r1, #14472	; 0x3888

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8002b22:	f2ce 0204 	movt	r2, #57348	; 0xe004
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8002b26:	6099      	str	r1, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8002b28:	6812      	ldr	r2, [r2, #0]
 8002b2a:	f246 4311 	movw	r3, #25617	; 0x6411
 8002b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b32:	429a      	cmp	r2, r3
 8002b34:	d021      	beq.n	8002b7a <stm32_clock_init+0x10a>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8002b36:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8002b3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002b3e:	f240 7202 	movw	r2, #1794	; 0x702
 8002b42:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8002b44:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002b48:	f2c4 0302 	movt	r3, #16386	; 0x4002
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8002b4c:	4619      	mov	r1, r3
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8002b4e:	689a      	ldr	r2, [r3, #8]
 8002b50:	f042 0202 	orr.w	r2, r2, #2
 8002b54:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8002b56:	688a      	ldr	r2, [r1, #8]
 8002b58:	f002 020c 	and.w	r2, r2, #12
 8002b5c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002b60:	2a08      	cmp	r2, #8
 8002b62:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002b66:	d1f6      	bne.n	8002b56 <stm32_clock_init+0xe6>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8002b68:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002b6a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002b6e:	645a      	str	r2, [r3, #68]	; 0x44
 8002b70:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8002b72:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002b76:	665a      	str	r2, [r3, #100]	; 0x64
 8002b78:	4770      	bx	lr

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8002b7a:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8002b7e:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8002b82:	f24c 2341 	movw	r3, #49729	; 0xc241
 8002b86:	6812      	ldr	r2, [r2, #0]
 8002b88:	f2c4 130f 	movt	r3, #16655	; 0x410f
 8002b8c:	429a      	cmp	r2, r3
 8002b8e:	d1d2      	bne.n	8002b36 <stm32_clock_init+0xc6>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8002b90:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8002b94:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002b98:	f44f 7281 	mov.w	r2, #258	; 0x102
 8002b9c:	601a      	str	r2, [r3, #0]
 8002b9e:	e7d1      	b.n	8002b44 <stm32_clock_init+0xd4>

08002ba0 <Vector6C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ba0:	f245 5044 	movw	r0, #21828	; 0x5544
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8002ba4:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ba6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002baa:	f7fe fbe9 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002bae:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002bb2:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
 8002bb6:	f241 2324 	movw	r3, #4644	; 0x1224
 8002bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002bbe:	6811      	ldr	r1, [r2, #0]
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
 8002bc0:	681c      	ldr	r4, [r3, #0]
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002bc2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8002bc6:	6091      	str	r1, [r2, #8]
  if (dma_isr_redir[0].dma_func)
 8002bc8:	b10c      	cbz	r4, 8002bce <Vector6C+0x2e>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8002bca:	6858      	ldr	r0, [r3, #4]
 8002bcc:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002bce:	f245 5044 	movw	r0, #21828	; 0x5544
 8002bd2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002bd6:	f7fe fbeb 	bl	80013b0 <_trace_isr_leave>
}
 8002bda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002bde:	f7fe bfe7 	b.w	8001bb0 <_port_irq_epilogue>
 8002be2:	bf00      	nop
 8002be4:	f3af 8000 	nop.w
 8002be8:	f3af 8000 	nop.w
 8002bec:	f3af 8000 	nop.w

08002bf0 <Vector70>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002bf0:	f245 5074 	movw	r0, #21876	; 0x5574
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002bf4:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002bf6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002bfa:	f7fe fbc1 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002bfe:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002c02:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 8002c06:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002c0a:	6811      	ldr	r1, [r2, #0]
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 8002c0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002c10:	0989      	lsrs	r1, r1, #6
 8002c12:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 8002c16:	689c      	ldr	r4, [r3, #8]
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6U;
 8002c18:	0188      	lsls	r0, r1, #6
 8002c1a:	6090      	str	r0, [r2, #8]
  if (dma_isr_redir[1].dma_func)
 8002c1c:	b10c      	cbz	r4, 8002c22 <Vector70+0x32>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8002c1e:	68d8      	ldr	r0, [r3, #12]
 8002c20:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002c22:	f245 5074 	movw	r0, #21876	; 0x5574
 8002c26:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002c2a:	f7fe fbc1 	bl	80013b0 <_trace_isr_leave>
}
 8002c2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002c32:	f7fe bfbd 	b.w	8001bb0 <_port_irq_epilogue>
 8002c36:	bf00      	nop
 8002c38:	f3af 8000 	nop.w
 8002c3c:	f3af 8000 	nop.w

08002c40 <Vector74>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c40:	f245 508c 	movw	r0, #21900	; 0x558c
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8002c44:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c46:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002c4a:	f7fe fb99 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002c4e:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002c52:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 8002c56:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002c5a:	6811      	ldr	r1, [r2, #0]
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 8002c5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002c60:	0c09      	lsrs	r1, r1, #16
 8002c62:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 8002c66:	691c      	ldr	r4, [r3, #16]
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16U;
 8002c68:	0408      	lsls	r0, r1, #16
 8002c6a:	6090      	str	r0, [r2, #8]
  if (dma_isr_redir[2].dma_func)
 8002c6c:	b10c      	cbz	r4, 8002c72 <Vector74+0x32>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8002c6e:	6958      	ldr	r0, [r3, #20]
 8002c70:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002c72:	f245 508c 	movw	r0, #21900	; 0x558c
 8002c76:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002c7a:	f7fe fb99 	bl	80013b0 <_trace_isr_leave>
}
 8002c7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002c82:	f7fe bf95 	b.w	8001bb0 <_port_irq_epilogue>
 8002c86:	bf00      	nop
 8002c88:	f3af 8000 	nop.w
 8002c8c:	f3af 8000 	nop.w

08002c90 <Vector78>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c90:	f245 50e0 	movw	r0, #21984	; 0x55e0
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8002c94:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c96:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002c9a:	f7fe fb71 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002c9e:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002ca2:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 8002ca6:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002caa:	6811      	ldr	r1, [r2, #0]
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 8002cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002cb0:	0d89      	lsrs	r1, r1, #22
 8002cb2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 8002cb6:	699c      	ldr	r4, [r3, #24]
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22U;
 8002cb8:	0588      	lsls	r0, r1, #22
 8002cba:	6090      	str	r0, [r2, #8]
  if (dma_isr_redir[3].dma_func)
 8002cbc:	b10c      	cbz	r4, 8002cc2 <Vector78+0x32>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8002cbe:	69d8      	ldr	r0, [r3, #28]
 8002cc0:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002cc2:	f245 50e0 	movw	r0, #21984	; 0x55e0
 8002cc6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002cca:	f7fe fb71 	bl	80013b0 <_trace_isr_leave>
}
 8002cce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002cd2:	f7fe bf6d 	b.w	8001bb0 <_port_irq_epilogue>
 8002cd6:	bf00      	nop
 8002cd8:	f3af 8000 	nop.w
 8002cdc:	f3af 8000 	nop.w

08002ce0 <Vector7C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ce0:	f245 50a4 	movw	r0, #21924	; 0x55a4
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002ce4:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ce6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002cea:	f7fe fb49 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002cee:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002cf2:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 8002cf6:	f241 2324 	movw	r3, #4644	; 0x1224
 8002cfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002cfe:	6851      	ldr	r1, [r2, #4]
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 8002d00:	6a1c      	ldr	r4, [r3, #32]
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002d02:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8002d06:	60d1      	str	r1, [r2, #12]
  if (dma_isr_redir[4].dma_func)
 8002d08:	b10c      	cbz	r4, 8002d0e <Vector7C+0x2e>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8002d0a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002d0c:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002d0e:	f245 50a4 	movw	r0, #21924	; 0x55a4
 8002d12:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002d16:	f7fe fb4b 	bl	80013b0 <_trace_isr_leave>
}
 8002d1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002d1e:	f7fe bf47 	b.w	8001bb0 <_port_irq_epilogue>
 8002d22:	bf00      	nop
 8002d24:	f3af 8000 	nop.w
 8002d28:	f3af 8000 	nop.w
 8002d2c:	f3af 8000 	nop.w

08002d30 <Vector80>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d30:	f245 60ac 	movw	r0, #22188	; 0x56ac
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002d34:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d36:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002d3a:	f7fe fb21 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002d3e:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002d42:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 8002d46:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002d4a:	6851      	ldr	r1, [r2, #4]
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 8002d4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002d50:	0989      	lsrs	r1, r1, #6
 8002d52:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 8002d56:	6a9c      	ldr	r4, [r3, #40]	; 0x28
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6U;
 8002d58:	0188      	lsls	r0, r1, #6
 8002d5a:	60d0      	str	r0, [r2, #12]
  if (dma_isr_redir[5].dma_func)
 8002d5c:	b10c      	cbz	r4, 8002d62 <Vector80+0x32>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8002d5e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8002d60:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002d62:	f245 60ac 	movw	r0, #22188	; 0x56ac
 8002d66:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002d6a:	f7fe fb21 	bl	80013b0 <_trace_isr_leave>
}
 8002d6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002d72:	f7fe bf1d 	b.w	8001bb0 <_port_irq_epilogue>
 8002d76:	bf00      	nop
 8002d78:	f3af 8000 	nop.w
 8002d7c:	f3af 8000 	nop.w

08002d80 <Vector84>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d80:	f245 50c8 	movw	r0, #21960	; 0x55c8
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8002d84:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d86:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002d8a:	f7fe faf9 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002d8e:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002d92:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 8002d96:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002d9a:	6851      	ldr	r1, [r2, #4]
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 8002d9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002da0:	0c09      	lsrs	r1, r1, #16
 8002da2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 8002da6:	6b1c      	ldr	r4, [r3, #48]	; 0x30
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16U;
 8002da8:	0408      	lsls	r0, r1, #16
 8002daa:	60d0      	str	r0, [r2, #12]
  if (dma_isr_redir[6].dma_func)
 8002dac:	b10c      	cbz	r4, 8002db2 <Vector84+0x32>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8002dae:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8002db0:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002db2:	f245 50c8 	movw	r0, #21960	; 0x55c8
 8002db6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002dba:	f7fe faf9 	bl	80013b0 <_trace_isr_leave>
}
 8002dbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002dc2:	f7fe bef5 	b.w	8001bb0 <_port_irq_epilogue>
 8002dc6:	bf00      	nop
 8002dc8:	f3af 8000 	nop.w
 8002dcc:	f3af 8000 	nop.w

08002dd0 <VectorFC>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002dd0:	f245 50d4 	movw	r0, #21972	; 0x55d4
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002dd4:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002dd6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002dda:	f7fe fad1 	bl	8001380 <_trace_isr_enter>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002dde:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8002de2:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 8002de6:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002dea:	6851      	ldr	r1, [r2, #4]
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 8002dec:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002df0:	0d89      	lsrs	r1, r1, #22
 8002df2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 8002df6:	6b9c      	ldr	r4, [r3, #56]	; 0x38
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22U;
 8002df8:	0588      	lsls	r0, r1, #22
 8002dfa:	60d0      	str	r0, [r2, #12]
  if (dma_isr_redir[7].dma_func)
 8002dfc:	b10c      	cbz	r4, 8002e02 <VectorFC+0x32>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8002dfe:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8002e00:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002e02:	f245 50d4 	movw	r0, #21972	; 0x55d4
 8002e06:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002e0a:	f7fe fad1 	bl	80013b0 <_trace_isr_leave>
}
 8002e0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002e12:	f7fe becd 	b.w	8001bb0 <_port_irq_epilogue>
 8002e16:	bf00      	nop
 8002e18:	f3af 8000 	nop.w
 8002e1c:	f3af 8000 	nop.w

08002e20 <Vector120>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002e20:	f245 5050 	movw	r0, #21840	; 0x5550
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8002e24:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002e26:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002e2a:	f7fe faa9 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002e2e:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8002e32:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 8002e36:	f241 2324 	movw	r3, #4644	; 0x1224
 8002e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002e3e:	6811      	ldr	r1, [r2, #0]
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 8002e40:	6c1c      	ldr	r4, [r3, #64]	; 0x40
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002e42:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8002e46:	6091      	str	r1, [r2, #8]
  if (dma_isr_redir[8].dma_func)
 8002e48:	b10c      	cbz	r4, 8002e4e <Vector120+0x2e>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8002e4a:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8002e4c:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002e4e:	f245 5050 	movw	r0, #21840	; 0x5550
 8002e52:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002e56:	f7fe faab 	bl	80013b0 <_trace_isr_leave>
}
 8002e5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002e5e:	f7fe bea7 	b.w	8001bb0 <_port_irq_epilogue>
 8002e62:	bf00      	nop
 8002e64:	f3af 8000 	nop.w
 8002e68:	f3af 8000 	nop.w
 8002e6c:	f3af 8000 	nop.w

08002e70 <Vector124>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002e70:	f245 5068 	movw	r0, #21864	; 0x5568
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8002e74:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002e76:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002e7a:	f7fe fa81 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002e7e:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8002e82:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 8002e86:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002e8a:	6811      	ldr	r1, [r2, #0]
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 8002e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002e90:	0989      	lsrs	r1, r1, #6
 8002e92:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 8002e96:	6c9c      	ldr	r4, [r3, #72]	; 0x48
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6U;
 8002e98:	0188      	lsls	r0, r1, #6
 8002e9a:	6090      	str	r0, [r2, #8]
  if (dma_isr_redir[9].dma_func)
 8002e9c:	b10c      	cbz	r4, 8002ea2 <Vector124+0x32>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8002e9e:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 8002ea0:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002ea2:	f245 5068 	movw	r0, #21864	; 0x5568
 8002ea6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002eaa:	f7fe fa81 	bl	80013b0 <_trace_isr_leave>
}
 8002eae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002eb2:	f7fe be7d 	b.w	8001bb0 <_port_irq_epilogue>
 8002eb6:	bf00      	nop
 8002eb8:	f3af 8000 	nop.w
 8002ebc:	f3af 8000 	nop.w

08002ec0 <Vector128>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ec0:	f245 5098 	movw	r0, #21912	; 0x5598
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8002ec4:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ec6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002eca:	f7fe fa59 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002ece:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8002ed2:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 8002ed6:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002eda:	6811      	ldr	r1, [r2, #0]
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 8002edc:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002ee0:	0c09      	lsrs	r1, r1, #16
 8002ee2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 8002ee6:	6d1c      	ldr	r4, [r3, #80]	; 0x50
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16U;
 8002ee8:	0408      	lsls	r0, r1, #16
 8002eea:	6090      	str	r0, [r2, #8]
  if (dma_isr_redir[10].dma_func)
 8002eec:	b10c      	cbz	r4, 8002ef2 <Vector128+0x32>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8002eee:	6d58      	ldr	r0, [r3, #84]	; 0x54
 8002ef0:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002ef2:	f245 5098 	movw	r0, #21912	; 0x5598
 8002ef6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002efa:	f7fe fa59 	bl	80013b0 <_trace_isr_leave>
}
 8002efe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002f02:	f7fe be55 	b.w	8001bb0 <_port_irq_epilogue>
 8002f06:	bf00      	nop
 8002f08:	f3af 8000 	nop.w
 8002f0c:	f3af 8000 	nop.w

08002f10 <Vector12C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002f10:	f245 50bc 	movw	r0, #21948	; 0x55bc
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8002f14:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002f16:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002f1a:	f7fe fa31 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002f1e:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8002f22:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 8002f26:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002f2a:	6811      	ldr	r1, [r2, #0]
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 8002f2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002f30:	0d89      	lsrs	r1, r1, #22
 8002f32:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 8002f36:	6d9c      	ldr	r4, [r3, #88]	; 0x58
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22U;
 8002f38:	0588      	lsls	r0, r1, #22
 8002f3a:	6090      	str	r0, [r2, #8]
  if (dma_isr_redir[11].dma_func)
 8002f3c:	b10c      	cbz	r4, 8002f42 <Vector12C+0x32>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8002f3e:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8002f40:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002f42:	f245 50bc 	movw	r0, #21948	; 0x55bc
 8002f46:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002f4a:	f7fe fa31 	bl	80013b0 <_trace_isr_leave>
}
 8002f4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002f52:	f7fe be2d 	b.w	8001bb0 <_port_irq_epilogue>
 8002f56:	bf00      	nop
 8002f58:	f3af 8000 	nop.w
 8002f5c:	f3af 8000 	nop.w

08002f60 <Vector130>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002f60:	f245 60b8 	movw	r0, #22200	; 0x56b8
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8002f64:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002f66:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002f6a:	f7fe fa09 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002f6e:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8002f72:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 8002f76:	f241 2324 	movw	r3, #4644	; 0x1224
 8002f7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002f7e:	6851      	ldr	r1, [r2, #4]
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 8002f80:	6e1c      	ldr	r4, [r3, #96]	; 0x60
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002f82:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8002f86:	60d1      	str	r1, [r2, #12]
  if (dma_isr_redir[12].dma_func)
 8002f88:	b10c      	cbz	r4, 8002f8e <Vector130+0x2e>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8002f8a:	6e58      	ldr	r0, [r3, #100]	; 0x64
 8002f8c:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002f8e:	f245 60b8 	movw	r0, #22200	; 0x56b8
 8002f92:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002f96:	f7fe fa0b 	bl	80013b0 <_trace_isr_leave>
}
 8002f9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002f9e:	f7fe be07 	b.w	8001bb0 <_port_irq_epilogue>
 8002fa2:	bf00      	nop
 8002fa4:	f3af 8000 	nop.w
 8002fa8:	f3af 8000 	nop.w
 8002fac:	f3af 8000 	nop.w

08002fb0 <Vector150>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002fb0:	f245 505c 	movw	r0, #21852	; 0x555c
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8002fb4:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002fb6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002fba:	f7fe f9e1 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002fbe:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8002fc2:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 8002fc6:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002fca:	6851      	ldr	r1, [r2, #4]
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 8002fcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002fd0:	0989      	lsrs	r1, r1, #6
 8002fd2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 8002fd6:	6e9c      	ldr	r4, [r3, #104]	; 0x68
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6U;
 8002fd8:	0188      	lsls	r0, r1, #6
 8002fda:	60d0      	str	r0, [r2, #12]
  if (dma_isr_redir[13].dma_func)
 8002fdc:	b10c      	cbz	r4, 8002fe2 <Vector150+0x32>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8002fde:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8002fe0:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8002fe2:	f245 505c 	movw	r0, #21852	; 0x555c
 8002fe6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002fea:	f7fe f9e1 	bl	80013b0 <_trace_isr_leave>
}
 8002fee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002ff2:	f7fe bddd 	b.w	8001bb0 <_port_irq_epilogue>
 8002ff6:	bf00      	nop
 8002ff8:	f3af 8000 	nop.w
 8002ffc:	f3af 8000 	nop.w

08003000 <Vector154>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003000:	f245 5080 	movw	r0, #21888	; 0x5580
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8003004:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003006:	f6c0 0000 	movt	r0, #2048	; 0x800
 800300a:	f7fe f9b9 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800300e:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8003012:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 8003016:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800301a:	6851      	ldr	r1, [r2, #4]
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 800301c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003020:	0c09      	lsrs	r1, r1, #16
 8003022:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 8003026:	6f1c      	ldr	r4, [r3, #112]	; 0x70
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16U;
 8003028:	0408      	lsls	r0, r1, #16
 800302a:	60d0      	str	r0, [r2, #12]
  if (dma_isr_redir[14].dma_func)
 800302c:	b10c      	cbz	r4, 8003032 <Vector154+0x32>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 800302e:	6f58      	ldr	r0, [r3, #116]	; 0x74
 8003030:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8003032:	f245 5080 	movw	r0, #21888	; 0x5580
 8003036:	f6c0 0000 	movt	r0, #2048	; 0x800
 800303a:	f7fe f9b9 	bl	80013b0 <_trace_isr_leave>
}
 800303e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003042:	f7fe bdb5 	b.w	8001bb0 <_port_irq_epilogue>
 8003046:	bf00      	nop
 8003048:	f3af 8000 	nop.w
 800304c:	f3af 8000 	nop.w

08003050 <Vector158>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003050:	f245 50b0 	movw	r0, #21936	; 0x55b0
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8003054:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003056:	f6c0 0000 	movt	r0, #2048	; 0x800
 800305a:	f7fe f991 	bl	8001380 <_trace_isr_enter>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800305e:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
 8003062:	f2c4 0202 	movt	r2, #16386	; 0x4002
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 8003066:	f241 2324 	movw	r3, #4644	; 0x1224
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800306a:	6851      	ldr	r1, [r2, #4]
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 800306c:	f2c2 0300 	movt	r3, #8192	; 0x2000
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003070:	0d89      	lsrs	r1, r1, #22
 8003072:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 8003076:	6f9c      	ldr	r4, [r3, #120]	; 0x78
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22U;
 8003078:	0588      	lsls	r0, r1, #22
 800307a:	60d0      	str	r0, [r2, #12]
  if (dma_isr_redir[15].dma_func)
 800307c:	b10c      	cbz	r4, 8003082 <Vector158+0x32>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 800307e:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
 8003080:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 8003082:	f245 50b0 	movw	r0, #21936	; 0x55b0
 8003086:	f6c0 0000 	movt	r0, #2048	; 0x800
 800308a:	f7fe f991 	bl	80013b0 <_trace_isr_leave>
}
 800308e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003092:	f7fe bd8d 	b.w	8001bb0 <_port_irq_epilogue>
 8003096:	bf00      	nop
 8003098:	f3af 8000 	nop.w
 800309c:	f3af 8000 	nop.w

080030a0 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 80030a0:	f241 23a4 	movw	r3, #4772	; 0x12a4
 80030a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 80030a8:	b430      	push	{r4, r5}
  unsigned i;

  dma_streams_mask = 0U;
 80030aa:	2100      	movs	r1, #0
 80030ac:	f245 55ec 	movw	r5, #21996	; 0x55ec
 80030b0:	f241 2424 	movw	r4, #4644	; 0x1224
 80030b4:	6019      	str	r1, [r3, #0]
 80030b6:	460a      	mov	r2, r1
 80030b8:	460b      	mov	r3, r1
 80030ba:	f6c0 0500 	movt	r5, #2048	; 0x800
 80030be:	f2c2 0400 	movt	r4, #8192	; 0x2000
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
 80030c2:	58e8      	ldr	r0, [r5, r3]
 80030c4:	330c      	adds	r3, #12
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80030c6:	2bc0      	cmp	r3, #192	; 0xc0
    _stm32_dma_streams[i].stream->CR = 0U;
 80030c8:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 80030ca:	50a1      	str	r1, [r4, r2]
 80030cc:	f102 0208 	add.w	r2, r2, #8
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80030d0:	d1f7      	bne.n	80030c2 <dmaInit+0x22>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80030d2:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 80030d6:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80030da:	f2c4 0102 	movt	r1, #16386	; 0x4002
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 80030de:	f2c4 0202 	movt	r2, #16386	; 0x4002
  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80030e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80030e6:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
  DMA2->HIFCR = 0xFFFFFFFFU;
}
 80030e8:	bc30      	pop	{r4, r5}
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
  DMA1->HIFCR = 0xFFFFFFFFU;
 80030ea:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 80030ec:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 80030ee:	60d3      	str	r3, [r2, #12]
}
 80030f0:	4770      	bx	lr
 80030f2:	bf00      	nop
 80030f4:	f3af 8000 	nop.w
 80030f8:	f3af 8000 	nop.w
 80030fc:	f3af 8000 	nop.w

08003100 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8003100:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8003104:	f241 24a4 	movw	r4, #4772	; 0x12a4
 8003108:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800310c:	7a46      	ldrb	r6, [r0, #9]
 800310e:	6825      	ldr	r5, [r4, #0]
 8003110:	2701      	movs	r7, #1
 8003112:	fa07 fc06 	lsl.w	ip, r7, r6
 8003116:	ea1c 0f05 	tst.w	ip, r5
 800311a:	d13c      	bne.n	8003196 <dmaStreamAllocate+0x96>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800311c:	f241 2724 	movw	r7, #4644	; 0x1224
 8003120:	f2c2 0700 	movt	r7, #8192	; 0x2000
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 8003124:	ea4c 0505 	orr.w	r5, ip, r5
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8003128:	eb07 08c6 	add.w	r8, r7, r6, lsl #3
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 800312c:	f015 0fff 	tst.w	r5, #255	; 0xff
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8003130:	f847 2036 	str.w	r2, [r7, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8003134:	f8c8 3004 	str.w	r3, [r8, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
    rccEnableDMA1(false);
 8003138:	bf1c      	itt	ne
 800313a:	f44f 5360 	movne.w	r3, #14336	; 0x3800
 800313e:	f2c4 0302 	movtne	r3, #16386	; 0x4002
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 8003142:	6025      	str	r5, [r4, #0]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
    rccEnableDMA1(false);
 8003144:	bf1e      	ittt	ne
 8003146:	6b1c      	ldrne	r4, [r3, #48]	; 0x30
 8003148:	f444 1400 	orrne.w	r4, r4, #2097152	; 0x200000
 800314c:	631c      	strne	r4, [r3, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 800314e:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
    rccEnableDMA2(false);
 8003152:	bf1f      	itttt	ne
 8003154:	f44f 5360 	movne.w	r3, #14336	; 0x3800
 8003158:	f2c4 0302 	movtne	r3, #16386	; 0x4002
 800315c:	6b1c      	ldrne	r4, [r3, #48]	; 0x30
 800315e:	f444 0480 	orrne.w	r4, r4, #4194304	; 0x400000
 8003162:	bf18      	it	ne
 8003164:	631c      	strne	r4, [r3, #48]	; 0x30
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8003166:	6804      	ldr	r4, [r0, #0]
 8003168:	6823      	ldr	r3, [r4, #0]
 800316a:	f023 031f 	bic.w	r3, r3, #31
 800316e:	6023      	str	r3, [r4, #0]
 8003170:	6823      	ldr	r3, [r4, #0]
 8003172:	f013 0501 	ands.w	r5, r3, #1
 8003176:	d1fb      	bne.n	8003170 <dmaStreamAllocate+0x70>
 8003178:	7a06      	ldrb	r6, [r0, #8]
 800317a:	6843      	ldr	r3, [r0, #4]
 800317c:	273d      	movs	r7, #61	; 0x3d
 800317e:	40b7      	lsls	r7, r6
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8003180:	2621      	movs	r6, #33	; 0x21
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8003182:	601f      	str	r7, [r3, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8003184:	6025      	str	r5, [r4, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8003186:	6166      	str	r6, [r4, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 8003188:	b142      	cbz	r2, 800319c <dmaStreamAllocate+0x9c>
    nvicEnableVector(dmastp->vector, priority);
 800318a:	7a80      	ldrb	r0, [r0, #10]
 800318c:	f7ff fbf0 	bl	8002970 <nvicEnableVector>
  }

  return false;
 8003190:	4628      	mov	r0, r5
 8003192:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 8003196:	4638      	mov	r0, r7
 8003198:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
    nvicEnableVector(dmastp->vector, priority);
  }

  return false;
 800319c:	4610      	mov	r0, r2
}
 800319e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80031a2:	bf00      	nop
 80031a4:	f3af 8000 	nop.w
 80031a8:	f3af 8000 	nop.w
 80031ac:	f3af 8000 	nop.w

080031b0 <VectorB0>:
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 80031b0:	f245 60c4 	movw	r0, #22212	; 0x56c4
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80031b4:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80031b6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80031ba:	f7fe f8e1 	bl	8001380 <_trace_isr_enter>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80031be:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80031c2:	691a      	ldr	r2, [r3, #16]
 80031c4:	0792      	lsls	r2, r2, #30
 80031c6:	d509      	bpl.n	80031dc <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
 80031c8:	2200      	movs	r2, #0
 80031ca:	611a      	str	r2, [r3, #16]
 80031cc:	2320      	movs	r3, #32
 80031ce:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 80031d2:	f7fe f81d 	bl	8001210 <chSysTimerHandlerI>
 80031d6:	2300      	movs	r3, #0
 80031d8:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80031dc:	f245 60c4 	movw	r0, #22212	; 0x56c4
 80031e0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80031e4:	f7fe f8e4 	bl	80013b0 <_trace_isr_leave>
}
 80031e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80031ec:	f7fe bce0 	b.w	8001bb0 <_port_irq_epilogue>

080031f0 <st_lld_init>:

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80031f0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80031f4:	f2c4 0302 	movt	r3, #16386	; 0x4002

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80031f8:	f44f 5100 	mov.w	r1, #8192	; 0x2000

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80031fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80031fe:	b470      	push	{r4, r5, r6}

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8003200:	f2ce 0104 	movt	r1, #57348	; 0xe004

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8003204:	f042 0201 	orr.w	r2, r2, #1
 8003208:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800320a:	6888      	ldr	r0, [r1, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800320c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8003210:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8003212:	2401      	movs	r4, #1

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8003214:	f040 0001 	orr.w	r0, r0, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8003218:	f242 06cf 	movw	r6, #8399	; 0x20cf
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800321c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8003220:	6088      	str	r0, [r1, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8003222:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8003224:	201c      	movs	r0, #28
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8003226:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8003228:	2108      	movs	r1, #8
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 800322a:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 800322c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800322e:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8003230:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8003232:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8003234:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8003236:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8003238:	f7ff bb9a 	b.w	8002970 <nvicEnableVector>
 800323c:	f3af 8000 	nop.w

08003240 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8003240:	b538      	push	{r3, r4, r5, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8003242:	f241 24a8 	movw	r4, #4776	; 0x12a8
 8003246:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800324a:	4620      	mov	r0, r4
 800324c:	f7fe fd28 	bl	8001ca0 <adcObjectInit>
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8003250:	4d08      	ldr	r5, [pc, #32]	; (8003274 <adc_lld_init+0x34>)
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 8003252:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8003256:	f642 4316 	movw	r3, #11286	; 0x2c16
 800325a:	f2c0 0302 	movt	r3, #2
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 800325e:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8003262:	62a2      	str	r2, [r4, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8003264:	62e5      	str	r5, [r4, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8003266:	6323      	str	r3, [r4, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled because sharing.*/
  nvicEnableVector(STM32_ADC_NUMBER, STM32_ADC_IRQ_PRIORITY);
 8003268:	2012      	movs	r0, #18
 800326a:	2106      	movs	r1, #6
}
 800326c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled because sharing.*/
  nvicEnableVector(STM32_ADC_NUMBER, STM32_ADC_IRQ_PRIORITY);
 8003270:	f7ff bb7e 	b.w	8002970 <nvicEnableVector>
 8003274:	0800567c 	.word	0x0800567c
 8003278:	f3af 8000 	nop.w
 800327c:	f3af 8000 	nop.w

08003280 <adc_lld_start>:
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8003280:	7803      	ldrb	r3, [r0, #0]
 8003282:	2b01      	cmp	r3, #1
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8003284:	b510      	push	{r4, lr}
 8003286:	4604      	mov	r4, r0

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8003288:	d000      	beq.n	800328c <adc_lld_start+0xc>
 800328a:	bd10      	pop	{r4, pc}
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 800328c:	f241 23a8 	movw	r3, #4776	; 0x12a8
 8003290:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003294:	4298      	cmp	r0, r3
 8003296:	d010      	beq.n	80032ba <adc_lld_start+0x3a>
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 8003298:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 800329c:	f2c4 0201 	movt	r2, #16385	; 0x4001
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 80032a0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 80032a2:	6854      	ldr	r4, [r2, #4]
 80032a4:	f404 0440 	and.w	r4, r4, #12582912	; 0xc00000
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 80032a8:	2100      	movs	r1, #0
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 80032aa:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
    adcp->adc->CR2 = 0;
    adcp->adc->CR2 = ADC_CR2_ADON;
 80032ae:	2001      	movs	r0, #1
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 80032b0:	6054      	str	r4, [r2, #4]
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 80032b2:	6059      	str	r1, [r3, #4]
    adcp->adc->CR2 = 0;
 80032b4:	6099      	str	r1, [r3, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 80032b6:	6098      	str	r0, [r3, #8]
 80032b8:	bd10      	pop	{r4, pc}
  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
 80032ba:	f243 4261 	movw	r2, #13409	; 0x3461
 80032be:	f6c0 0200 	movt	r2, #2048	; 0x800
 80032c2:	2106      	movs	r1, #6
 80032c4:	4623      	mov	r3, r4
 80032c6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80032c8:	f7ff ff1a 	bl	8003100 <dmaStreamAllocate>
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80032cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80032ce:	f242 024c 	movw	r2, #8268	; 0x204c
 80032d2:	6819      	ldr	r1, [r3, #0]
      rccEnableADC1(FALSE);
 80032d4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80032d8:	f2c4 0201 	movt	r2, #16385	; 0x4001
      rccEnableADC1(FALSE);
 80032dc:	f2c4 0302 	movt	r3, #16386	; 0x4002
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80032e0:	608a      	str	r2, [r1, #8]
      rccEnableADC1(FALSE);
 80032e2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80032e4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80032e8:	645a      	str	r2, [r3, #68]	; 0x44
 80032ea:	e7d5      	b.n	8003298 <adc_lld_start+0x18>
 80032ec:	f3af 8000 	nop.w

080032f0 <adc_lld_start_conversion>:
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
  uint32_t mode;
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;
 80032f0:	6903      	ldr	r3, [r0, #16]

  /* DMA setup.*/
  mode = adcp->dmamode;
 80032f2:	6b02      	ldr	r2, [r0, #48]	; 0x30
  if (grpp->circular) {
 80032f4:	7819      	ldrb	r1, [r3, #0]
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 80032f6:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
    mode |= STM32_DMA_CR_CIRC;
    if (adcp->depth > 1) {
 80032fa:	68c5      	ldr	r5, [r0, #12]
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
 80032fc:	b129      	cbz	r1, 800330a <adc_lld_start_conversion+0x1a>
    mode |= STM32_DMA_CR_CIRC;
    if (adcp->depth > 1) {
 80032fe:	2d01      	cmp	r5, #1
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
    mode |= STM32_DMA_CR_CIRC;
 8003300:	bf94      	ite	ls
 8003302:	f442 7280 	orrls.w	r2, r2, #256	; 0x100
    if (adcp->depth > 1) {
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
 8003306:	f442 7284 	orrhi.w	r2, r2, #264	; 0x108
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800330a:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800330c:	885e      	ldrh	r6, [r3, #2]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800330e:	6809      	ldr	r1, [r1, #0]
 8003310:	6884      	ldr	r4, [r0, #8]
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8003312:	f8d3 800c 	ldr.w	r8, [r3, #12]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8003316:	60cc      	str	r4, [r1, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8003318:	fb06 f405 	mul.w	r4, r6, r5
 800331c:	604c      	str	r4, [r1, #4]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
 800331e:	600a      	str	r2, [r1, #0]
  dmaStreamEnable(adcp->dmastp);
 8003320:	f8d1 9000 	ldr.w	r9, [r1]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
 8003324:	699f      	ldr	r7, [r3, #24]
  adcp->adc->SQR1  = grpp->sqr1;
 8003326:	69de      	ldr	r6, [r3, #28]
  adcp->adc->SQR2  = grpp->sqr2;
 8003328:	6a1d      	ldr	r5, [r3, #32]
  adcp->adc->SQR3  = grpp->sqr3;
 800332a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
 800332c:	f8d3 c014 	ldr.w	ip, [r3, #20]

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;

  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 8003330:	691b      	ldr	r3, [r3, #16]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 8003332:	6a82      	ldr	r2, [r0, #40]	; 0x28
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 8003334:	f049 0901 	orr.w	r9, r9, #1
 8003338:	f8c1 9000 	str.w	r9, [r1]
  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
 800333c:	0059      	lsls	r1, r3, #1
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800333e:	bf44      	itt	mi
 8003340:	f023 4180 	bicmi.w	r1, r3, #1073741824	; 0x40000000
 8003344:	f021 0102 	bicmi.w	r1, r1, #2
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8003348:	f048 6080 	orr.w	r0, r8, #67108864	; 0x4000000

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800334c:	bf46      	itte	mi
 800334e:	f441 7140 	orrmi.w	r1, r1, #768	; 0x300

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 8003352:	f443 7340 	orrmi.w	r3, r3, #768	; 0x300

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;

  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 8003356:	f443 7340 	orrpl.w	r3, r3, #768	; 0x300
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800335a:	f04f 0800 	mov.w	r8, #0
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800335e:	f440 7080 	orr.w	r0, r0, #256	; 0x100

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 8003362:	bf46      	itte	mi
 8003364:	f041 0103 	orrmi.w	r1, r1, #3

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 8003368:	f043 0303 	orrmi.w	r3, r3, #3

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;

  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 800336c:	f043 0301 	orrpl.w	r3, r3, #1
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 8003370:	f8c2 8000 	str.w	r8, [r2]
  adcp->adc->SMPR1 = grpp->smpr1;
 8003374:	f8c2 c00c 	str.w	ip, [r2, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
 8003378:	6117      	str	r7, [r2, #16]
  adcp->adc->SQR1  = grpp->sqr1;
 800337a:	62d6      	str	r6, [r2, #44]	; 0x2c
  adcp->adc->SQR2  = grpp->sqr2;
 800337c:	6315      	str	r5, [r2, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
 800337e:	6354      	str	r4, [r2, #52]	; 0x34

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8003380:	6050      	str	r0, [r2, #4]
    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
  }
  else
    adcp->adc->CR2 = cr2;
}
 8003382:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 8003386:	bf48      	it	mi
 8003388:	6091      	strmi	r1, [r2, #8]

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
  }
  else
    adcp->adc->CR2 = cr2;
 800338a:	6093      	str	r3, [r2, #8]
}
 800338c:	4770      	bx	lr
 800338e:	bf00      	nop

08003390 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8003390:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8003392:	680a      	ldr	r2, [r1, #0]
 8003394:	6813      	ldr	r3, [r2, #0]
 8003396:	f023 031f 	bic.w	r3, r3, #31
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 800339a:	b410      	push	{r4}

  dmaStreamDisable(adcp->dmastp);
 800339c:	6013      	str	r3, [r2, #0]
 800339e:	6813      	ldr	r3, [r2, #0]
 80033a0:	f013 0301 	ands.w	r3, r3, #1
 80033a4:	d1fb      	bne.n	800339e <adc_lld_stop_conversion+0xe>
 80033a6:	7a0c      	ldrb	r4, [r1, #8]
  adcp->adc->CR1 = 0;
 80033a8:	6a82      	ldr	r2, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80033aa:	6848      	ldr	r0, [r1, #4]
 80033ac:	213d      	movs	r1, #61	; 0x3d
 80033ae:	fa01 f404 	lsl.w	r4, r1, r4
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 80033b2:	2101      	movs	r1, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80033b4:	6004      	str	r4, [r0, #0]
  adcp->adc->CR1 = 0;
 80033b6:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
}
 80033b8:	f85d 4b04 	ldr.w	r4, [sp], #4
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
 80033bc:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 80033be:	6091      	str	r1, [r2, #8]
}
 80033c0:	4770      	bx	lr
 80033c2:	bf00      	nop
 80033c4:	f3af 8000 	nop.w
 80033c8:	f3af 8000 	nop.w
 80033cc:	f3af 8000 	nop.w

080033d0 <Vector88>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
 80033d0:	f245 60d0 	movw	r0, #22224	; 0x56d0
 80033d4:	f6c0 0000 	movt	r0, #2048	; 0x800
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
 80033d8:	b510      	push	{r4, lr}
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
 80033da:	f7fd ffd1 	bl	8001380 <_trace_isr_enter>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 80033de:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80033e2:	f2c4 0301 	movt	r3, #16385	; 0x4001
  ADC1->SR = 0;
 80033e6:	2100      	movs	r1, #0
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 80033e8:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 80033ea:	6019      	str	r1, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 80033ec:	0690      	lsls	r0, r2, #26
 80033ee:	d526      	bpl.n	800343e <Vector88+0x6e>
 80033f0:	f241 24a8 	movw	r4, #4776	; 0x12a8
 80033f4:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80033f8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80033fa:	681b      	ldr	r3, [r3, #0]
 80033fc:	685b      	ldr	r3, [r3, #4]
 80033fe:	b1f3      	cbz	r3, 800343e <Vector88+0x6e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 8003400:	6923      	ldr	r3, [r4, #16]
 8003402:	b1e3      	cbz	r3, 800343e <Vector88+0x6e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8003404:	4620      	mov	r0, r4
 8003406:	f7ff ffc3 	bl	8003390 <adc_lld_stop_conversion>
 800340a:	6923      	ldr	r3, [r4, #16]
 800340c:	689b      	ldr	r3, [r3, #8]
 800340e:	b14b      	cbz	r3, 8003424 <Vector88+0x54>
 8003410:	2205      	movs	r2, #5
 8003412:	7022      	strb	r2, [r4, #0]
 8003414:	4620      	mov	r0, r4
 8003416:	2101      	movs	r1, #1
 8003418:	4798      	blx	r3
 800341a:	7823      	ldrb	r3, [r4, #0]
 800341c:	2b05      	cmp	r3, #5
 800341e:	bf04      	itt	eq
 8003420:	2302      	moveq	r3, #2
 8003422:	7023      	strbeq	r3, [r4, #0]
 8003424:	2300      	movs	r3, #0
 8003426:	6123      	str	r3, [r4, #16]
 8003428:	2320      	movs	r3, #32
 800342a:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800342e:	4809      	ldr	r0, [pc, #36]	; (8003454 <Vector88+0x84>)
 8003430:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003434:	f7fe faf4 	bl	8001a20 <chThdResumeI>
 8003438:	2300      	movs	r3, #0
 800343a:	f383 8811 	msr	BASEPRI, r3
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 800343e:	f245 60d0 	movw	r0, #22224	; 0x56d0
 8003442:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003446:	f7fd ffb3 	bl	80013b0 <_trace_isr_leave>
}
 800344a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 800344e:	f7fe bbaf 	b.w	8001bb0 <_port_irq_epilogue>
 8003452:	bf00      	nop
 8003454:	200012bc 	.word	0x200012bc
 8003458:	f3af 8000 	nop.w
 800345c:	f3af 8000 	nop.w

08003460 <adc_lld_serve_rx_interrupt>:
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8003460:	f011 0f0c 	tst.w	r1, #12
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 8003464:	b538      	push	{r3, r4, r5, lr}
 8003466:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8003468:	d11e      	bne.n	80034a8 <adc_lld_serve_rx_interrupt+0x48>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 800346a:	6903      	ldr	r3, [r0, #16]
 800346c:	b1db      	cbz	r3, 80034a6 <adc_lld_serve_rx_interrupt+0x46>

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 800346e:	068a      	lsls	r2, r1, #26
 8003470:	d511      	bpl.n	8003496 <adc_lld_serve_rx_interrupt+0x36>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8003472:	781d      	ldrb	r5, [r3, #0]
 8003474:	2d00      	cmp	r5, #0
 8003476:	d035      	beq.n	80034e4 <adc_lld_serve_rx_interrupt+0x84>
 8003478:	685d      	ldr	r5, [r3, #4]
 800347a:	b1a5      	cbz	r5, 80034a6 <adc_lld_serve_rx_interrupt+0x46>
 800347c:	68c2      	ldr	r2, [r0, #12]
 800347e:	2a01      	cmp	r2, #1
 8003480:	bf85      	ittet	hi
 8003482:	8859      	ldrhhi	r1, [r3, #2]
 8003484:	6883      	ldrhi	r3, [r0, #8]
 8003486:	6881      	ldrls	r1, [r0, #8]
 8003488:	0852      	lsrhi	r2, r2, #1
 800348a:	bf84      	itt	hi
 800348c:	4351      	mulhi	r1, r2
 800348e:	eb03 0141 	addhi.w	r1, r3, r1, lsl #1
 8003492:	47a8      	blx	r5
 8003494:	bd38      	pop	{r3, r4, r5, pc}
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8003496:	06cd      	lsls	r5, r1, #27
 8003498:	d505      	bpl.n	80034a6 <adc_lld_serve_rx_interrupt+0x46>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800349a:	685b      	ldr	r3, [r3, #4]
 800349c:	b11b      	cbz	r3, 80034a6 <adc_lld_serve_rx_interrupt+0x46>
 800349e:	68c2      	ldr	r2, [r0, #12]
 80034a0:	6881      	ldr	r1, [r0, #8]
 80034a2:	0852      	lsrs	r2, r2, #1
 80034a4:	4798      	blx	r3
 80034a6:	bd38      	pop	{r3, r4, r5, pc}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80034a8:	f7ff ff72 	bl	8003390 <adc_lld_stop_conversion>
 80034ac:	6923      	ldr	r3, [r4, #16]
 80034ae:	689b      	ldr	r3, [r3, #8]
 80034b0:	b14b      	cbz	r3, 80034c6 <adc_lld_serve_rx_interrupt+0x66>
 80034b2:	2205      	movs	r2, #5
 80034b4:	7022      	strb	r2, [r4, #0]
 80034b6:	4620      	mov	r0, r4
 80034b8:	2100      	movs	r1, #0
 80034ba:	4798      	blx	r3
 80034bc:	7823      	ldrb	r3, [r4, #0]
 80034be:	2b05      	cmp	r3, #5
 80034c0:	bf04      	itt	eq
 80034c2:	2302      	moveq	r3, #2
 80034c4:	7023      	strbeq	r3, [r4, #0]
 80034c6:	2300      	movs	r3, #0
 80034c8:	6123      	str	r3, [r4, #16]
 80034ca:	2320      	movs	r3, #32
 80034cc:	f383 8811 	msr	BASEPRI, r3
 80034d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80034d4:	f104 0014 	add.w	r0, r4, #20
 80034d8:	f7fe faa2 	bl	8001a20 <chThdResumeI>
 80034dc:	2300      	movs	r3, #0
 80034de:	f383 8811 	msr	BASEPRI, r3
 80034e2:	bd38      	pop	{r3, r4, r5, pc}
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 80034e4:	f7ff ff54 	bl	8003390 <adc_lld_stop_conversion>
 80034e8:	6923      	ldr	r3, [r4, #16]
 80034ea:	685b      	ldr	r3, [r3, #4]
 80034ec:	b1c3      	cbz	r3, 8003520 <adc_lld_serve_rx_interrupt+0xc0>
 80034ee:	2204      	movs	r2, #4
 80034f0:	7022      	strb	r2, [r4, #0]
 80034f2:	4620      	mov	r0, r4
 80034f4:	68a1      	ldr	r1, [r4, #8]
 80034f6:	68e2      	ldr	r2, [r4, #12]
 80034f8:	4798      	blx	r3
 80034fa:	7823      	ldrb	r3, [r4, #0]
 80034fc:	2b04      	cmp	r3, #4
 80034fe:	d00b      	beq.n	8003518 <adc_lld_serve_rx_interrupt+0xb8>
 8003500:	2320      	movs	r3, #32
 8003502:	f383 8811 	msr	BASEPRI, r3
 8003506:	2100      	movs	r1, #0
 8003508:	f104 0014 	add.w	r0, r4, #20
 800350c:	f7fe fa88 	bl	8001a20 <chThdResumeI>
 8003510:	2300      	movs	r3, #0
 8003512:	f383 8811 	msr	BASEPRI, r3
 8003516:	bd38      	pop	{r3, r4, r5, pc}
 8003518:	2302      	movs	r3, #2
 800351a:	6125      	str	r5, [r4, #16]
 800351c:	7023      	strb	r3, [r4, #0]
 800351e:	e7ef      	b.n	8003500 <adc_lld_serve_rx_interrupt+0xa0>
 8003520:	2202      	movs	r2, #2
 8003522:	6123      	str	r3, [r4, #16]
 8003524:	7022      	strb	r2, [r4, #0]
 8003526:	e7eb      	b.n	8003500 <adc_lld_serve_rx_interrupt+0xa0>
 8003528:	f3af 8000 	nop.w
 800352c:	f3af 8000 	nop.w

08003530 <_pal_lld_init>:
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8003530:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003534:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003538:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800353a:	f042 021f 	orr.w	r2, r2, #31
 800353e:	631a      	str	r2, [r3, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8003540:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003542:	f042 021f 	orr.w	r2, r2, #31
 8003546:	651a      	str	r2, [r3, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003548:	2200      	movs	r2, #0
 800354a:	6841      	ldr	r1, [r0, #4]
 800354c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003550:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003554:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003556:	6881      	ldr	r1, [r0, #8]
 8003558:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800355a:	68c1      	ldr	r1, [r0, #12]
 800355c:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 800355e:	6901      	ldr	r1, [r0, #16]
 8003560:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8003562:	6941      	ldr	r1, [r0, #20]
 8003564:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8003566:	6981      	ldr	r1, [r0, #24]
 8003568:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800356a:	6801      	ldr	r1, [r0, #0]
 800356c:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800356e:	6a01      	ldr	r1, [r0, #32]
 8003570:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003574:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8003578:	6059      	str	r1, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800357a:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800357c:	6099      	str	r1, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800357e:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8003580:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8003582:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8003584:	6159      	str	r1, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8003586:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8003588:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800358a:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800358c:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800358e:	69c1      	ldr	r1, [r0, #28]
 8003590:	6019      	str	r1, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003592:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003596:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8003598:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800359a:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800359c:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800359e:	6c41      	ldr	r1, [r0, #68]	; 0x44
 80035a0:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80035a2:	6c81      	ldr	r1, [r0, #72]	; 0x48
 80035a4:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80035a6:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80035a8:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80035aa:	6d01      	ldr	r1, [r0, #80]	; 0x50
 80035ac:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80035ae:	6b81      	ldr	r1, [r0, #56]	; 0x38
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80035b0:	f44f 6340 	mov.w	r3, #3072	; 0xc00
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80035b4:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80035b6:	6d81      	ldr	r1, [r0, #88]	; 0x58
 80035b8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80035bc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80035c0:	6059      	str	r1, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80035c2:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 80035c4:	6099      	str	r1, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80035c6:	6e01      	ldr	r1, [r0, #96]	; 0x60
 80035c8:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 80035ca:	6e41      	ldr	r1, [r0, #100]	; 0x64
 80035cc:	6159      	str	r1, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80035ce:	6e81      	ldr	r1, [r0, #104]	; 0x68
 80035d0:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80035d2:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 80035d4:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80035d6:	6d41      	ldr	r1, [r0, #84]	; 0x54
 80035d8:	6019      	str	r1, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80035da:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80035de:	6f41      	ldr	r1, [r0, #116]	; 0x74
 80035e0:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80035e2:	6f81      	ldr	r1, [r0, #120]	; 0x78
 80035e4:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80035e6:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
 80035e8:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80035ea:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 80035ee:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80035f0:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
 80035f4:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80035f6:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 80035fa:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80035fc:	6f01      	ldr	r1, [r0, #112]	; 0x70
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80035fe:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8003602:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003604:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8003608:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800360c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800360e:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 8003612:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8003614:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
 8003618:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800361a:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 800361e:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8003620:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
 8003624:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8003626:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
 800362a:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800362c:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 8003630:	601a      	str	r2, [r3, #0]
 8003632:	4770      	bx	lr
 8003634:	f3af 8000 	nop.w
 8003638:	f3af 8000 	nop.w
 800363c:	f3af 8000 	nop.w

08003640 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8003640:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8003644:	2300      	movs	r3, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8003646:	f002 0403 	and.w	r4, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800364a:	f3c2 0780 	ubfx	r7, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800364e:	f3c2 06c1 	ubfx	r6, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8003652:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8003656:	f3c2 1bc3 	ubfx	fp, r2, #7, #4
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800365a:	f04f 0a0f 	mov.w	sl, #15
 800365e:	e01b      	b.n	8003698 <_pal_lld_setgroupmode+0x58>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8003660:	f8d0 9000 	ldr.w	r9, [r0]
 8003664:	ea02 0209 	and.w	r2, r2, r9
 8003668:	4322      	orrs	r2, r4
        if (bit < 8)
 800366a:	2b07      	cmp	r3, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800366c:	6002      	str	r2, [r0, #0]
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800366e:	bf95      	itete	ls
 8003670:	6a02      	ldrls	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003672:	6a42      	ldrhi	r2, [r0, #36]	; 0x24
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003674:	ea22 0c0c 	bicls.w	ip, r2, ip
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003678:	ea22 0c0c 	bichi.w	ip, r2, ip
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800367c:	bf95      	itete	ls
 800367e:	ea4c 0208 	orrls.w	r2, ip, r8
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003682:	ea4c 0208 	orrhi.w	r2, ip, r8
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003686:	6202      	strls	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003688:	6242      	strhi	r2, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 800368a:	0849      	lsrs	r1, r1, #1
 800368c:	d04c      	beq.n	8003728 <_pal_lld_setgroupmode+0xe8>
      return;
    otyper <<= 1;
 800368e:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
 8003690:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 8003692:	00ad      	lsls	r5, r5, #2
    moder <<= 2;
 8003694:	00a4      	lsls	r4, r4, #2
    bit++;
 8003696:	3301      	adds	r3, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8003698:	07ca      	lsls	r2, r1, #31
 800369a:	d5f6      	bpl.n	800368a <_pal_lld_setgroupmode+0x4a>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800369c:	6842      	ldr	r2, [r0, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 800369e:	f04f 0801 	mov.w	r8, #1
 80036a2:	fa08 fc03 	lsl.w	ip, r8, r3
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80036a6:	ea22 020c 	bic.w	r2, r2, ip
 80036aa:	433a      	orrs	r2, r7
 80036ac:	6042      	str	r2, [r0, #4]
 80036ae:	fa03 f208 	lsl.w	r2, r3, r8
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 80036b2:	f04f 0803 	mov.w	r8, #3
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80036b6:	f8d0 c008 	ldr.w	ip, [r0, #8]
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 80036ba:	fa08 f202 	lsl.w	r2, r8, r2
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80036be:	43d2      	mvns	r2, r2
 80036c0:	ea02 0c0c 	and.w	ip, r2, ip
 80036c4:	ea4c 0c06 	orr.w	ip, ip, r6
 80036c8:	f8c0 c008 	str.w	ip, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80036cc:	f8d0 800c 	ldr.w	r8, [r0, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80036d0:	f003 0c07 	and.w	ip, r3, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80036d4:	ea02 0808 	and.w	r8, r2, r8
 80036d8:	ea48 0805 	orr.w	r8, r8, r5
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80036dc:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 80036e0:	2c02      	cmp	r4, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80036e2:	f8c0 800c 	str.w	r8, [r0, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80036e6:	fa0b f80c 	lsl.w	r8, fp, ip
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80036ea:	fa0a fc0c 	lsl.w	ip, sl, ip
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 80036ee:	d1b7      	bne.n	8003660 <_pal_lld_setgroupmode+0x20>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80036f0:	2b07      	cmp	r3, #7
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80036f2:	bf95      	itete	ls
 80036f4:	f8d0 9020 	ldrls.w	r9, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80036f8:	f8d0 9024 	ldrhi.w	r9, [r0, #36]	; 0x24
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80036fc:	ea29 0c0c 	bicls.w	ip, r9, ip
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003700:	ea29 0c0c 	bichi.w	ip, r9, ip
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003704:	bf95      	itete	ls
 8003706:	ea4c 0808 	orrls.w	r8, ip, r8
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800370a:	ea4c 0808 	orrhi.w	r8, ip, r8
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800370e:	f8c0 8020 	strls.w	r8, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003712:	f8c0 8024 	strhi.w	r8, [r0, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8003716:	f8d0 c000 	ldr.w	ip, [r0]
 800371a:	ea02 020c 	and.w	r2, r2, ip
 800371e:	f042 0202 	orr.w	r2, r2, #2
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8003722:	0849      	lsrs	r1, r1, #1
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8003724:	6002      	str	r2, [r0, #0]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8003726:	d1b2      	bne.n	800368e <_pal_lld_setgroupmode+0x4e>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8003728:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800372c:	4770      	bx	lr
 800372e:	bf00      	nop

08003730 <rtc_lld_init>:
/**
 * @brief   Enable access to registers.
 *
 * @notapi
 */
void rtc_lld_init(void) {
 8003730:	b510      	push	{r4, lr}

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);
 8003732:	f241 24dc 	movw	r4, #4828	; 0x12dc
 8003736:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800373a:	4620      	mov	r0, r4
 800373c:	f7fe fb68 	bl	8001e10 <rtcObjectInit>

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 8003740:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8003744:	f2c4 0300 	movt	r3, #16384	; 0x4000

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
  RTCD1.rtc->WPR = 0x53;
 8003748:	2253      	movs	r2, #83	; 0x53

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 800374a:	21ca      	movs	r1, #202	; 0xca

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 800374c:	6023      	str	r3, [r4, #0]

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 800374e:	6259      	str	r1, [r3, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 8003750:	625a      	str	r2, [r3, #36]	; 0x24

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8003752:	68da      	ldr	r2, [r3, #12]
 8003754:	f012 0f10 	tst.w	r2, #16
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 8003758:	68da      	ldr	r2, [r3, #12]
  RTCD1.rtc->WPR = 0xCA;
  RTCD1.rtc->WPR = 0x53;

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 800375a:	d119      	bne.n	8003790 <rtc_lld_init+0x60>
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 800375c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003760:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 8003762:	4619      	mov	r1, r3
 8003764:	68ca      	ldr	r2, [r1, #12]
 8003766:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800376a:	0652      	lsls	r2, r2, #25
 800376c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8003770:	d5f8      	bpl.n	8003764 <rtc_lld_init+0x34>

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8003772:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8003776:	f2c0 021f 	movt	r2, #31
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 800377a:	2000      	movs	r0, #0
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 800377c:	2180      	movs	r1, #128	; 0x80
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 800377e:	6098      	str	r0, [r3, #8]
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8003780:	60d9      	str	r1, [r3, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8003782:	611a      	str	r2, [r3, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8003784:	611a      	str	r2, [r3, #16]
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8003786:	68da      	ldr	r2, [r3, #12]
 8003788:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800378c:	60da      	str	r2, [r3, #12]
 800378e:	bd10      	pop	{r4, pc}
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;

    rtc_exit_init();
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 8003790:	f022 0220 	bic.w	r2, r2, #32
 8003794:	60da      	str	r2, [r3, #12]
 8003796:	bd10      	pop	{r4, pc}
 8003798:	f3af 8000 	nop.w
 800379c:	f3af 8000 	nop.w

080037a0 <rtc_lld_set_time>:
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
  uint32_t n, tr = 0;

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 80037a0:	684a      	ldr	r2, [r1, #4]
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
 80037a2:	f891 c002 	ldrb.w	ip, [r1, #2]
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
  uint32_t n, tr = 0;

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 80037a6:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_set_time(RTCDriver *rtcp, const RTCDateTime *timespec) {
 80037aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
  uint32_t n, tr = 0;

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 80037ae:	f2c1 0362 	movt	r3, #4194	; 0x1062
 80037b2:	f3c2 091a 	ubfx	r9, r2, #0, #27
 80037b6:	fb83 6909 	smull	r6, r9, r3, r9

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
  n /= 10;
 80037ba:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 80037be:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
 80037c2:	784c      	ldrb	r4, [r1, #1]
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 80037c4:	f891 8000 	ldrb.w	r8, [r1]
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
  uint32_t n, tr = 0;

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 80037c8:	ea4f 1999 	mov.w	r9, r9, lsr #6

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
  n /= 10;
 80037cc:	fba3 a609 	umull	sl, r6, r3, r9
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 80037d0:	f64a 22ab 	movw	r2, #43691	; 0xaaab
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
 80037d4:	f004 070f 	and.w	r7, r4, #15
  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
  n /= 10;
 80037d8:	08f6      	lsrs	r6, r6, #3
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 80037da:	f6ca 22aa 	movt	r2, #43690	; 0xaaaa
 80037de:	fba2 b506 	umull	fp, r5, r2, r6
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 80037e2:	fba3 1e07 	umull	r1, lr, r3, r7
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_set_time(RTCDriver *rtcp, const RTCDateTime *timespec) {
 80037e6:	b083      	sub	sp, #12
  n = timespec->millisecond / 1000;

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 80037e8:	08ad      	lsrs	r5, r5, #2
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 80037ea:	ea4f 0ede 	mov.w	lr, lr, lsr #3
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
 80037ee:	9401      	str	r4, [sp, #4]
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 80037f0:	fba3 a405 	umull	sl, r4, r3, r5
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 80037f4:	ea4f 0a8e 	mov.w	sl, lr, lsl #2
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 80037f8:	08e4      	lsrs	r4, r4, #3
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
 80037fa:	f00c 0c1f 	and.w	ip, ip, #31
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 80037fe:	44f2      	add	sl, lr
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
 8003800:	fba3 b108 	umull	fp, r1, r3, r8
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 8003804:	fba2 b204 	umull	fp, r2, r2, r4
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 8003808:	eba7 0a4a 	sub.w	sl, r7, sl, lsl #1
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 800380c:	fba3 b70c 	umull	fp, r7, r3, ip

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
 8003810:	eb06 0b86 	add.w	fp, r6, r6, lsl #2
 8003814:	eba9 094b 	sub.w	r9, r9, fp, lsl #1
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 8003818:	eb05 0b45 	add.w	fp, r5, r5, lsl #1
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
 800381c:	08c9      	lsrs	r1, r1, #3
  n = timespec->millisecond / 1000;

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 800381e:	eba6 064b 	sub.w	r6, r6, fp, lsl #1
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 8003822:	08ff      	lsrs	r7, r7, #3
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
 8003824:	eb01 0b81 	add.w	fp, r1, r1, lsl #2
  n = timespec->millisecond / 1000;

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 8003828:	ea49 1906 	orr.w	r9, r9, r6, lsl #4
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 800382c:	eb04 0684 	add.w	r6, r4, r4, lsl #2
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
 8003830:	eba8 084b 	sub.w	r8, r8, fp, lsl #1
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 8003834:	eba5 0546 	sub.w	r5, r5, r6, lsl #1
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 8003838:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 800383c:	eb07 0687 	add.w	r6, r7, r7, lsl #2
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 8003840:	0892      	lsrs	r2, r2, #2
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 8003842:	ebac 0c46 	sub.w	ip, ip, r6, lsl #1

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);
 8003846:	ea4a 4a08 	orr.w	sl, sl, r8, lsl #16
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 800384a:	9e01      	ldr	r6, [sp, #4]

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);
 800384c:	fba3 b801 	umull	fp, r8, r3, r1
 8003850:	ea4f 08d8 	mov.w	r8, r8, lsr #3
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
 8003854:	fba3 b302 	umull	fp, r3, r3, r2
 8003858:	08db      	lsrs	r3, r3, #3
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 800385a:	ea4f 1b56 	mov.w	fp, r6, lsr #5
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 800385e:	ea4a 0a0c 	orr.w	sl, sl, ip
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 8003862:	eb02 0642 	add.w	r6, r2, r2, lsl #1

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);
 8003866:	eb08 0888 	add.w	r8, r8, r8, lsl #2
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 800386a:	ea49 2905 	orr.w	r9, r9, r5, lsl #8
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 800386e:	eba4 0446 	sub.w	r4, r4, r6, lsl #1

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);
 8003872:	eba1 0148 	sub.w	r1, r1, r8, lsl #1
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
 8003876:	eb03 0683 	add.w	r6, r3, r3, lsl #2

  /* Months conversion.*/
  n = timespec->month;
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);
 800387a:	ea4a 3a4b 	orr.w	sl, sl, fp, lsl #13
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
 800387e:	eba2 0546 	sub.w	r5, r2, r6, lsl #1
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 8003882:	ea4a 5101 	orr.w	r1, sl, r1, lsl #20
  n /= 6;

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 8003886:	ea49 3404 	orr.w	r4, r9, r4, lsl #12

  /* Days conversion.*/
  n = timespec->day;
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);
 800388a:	ea41 3e0e 	orr.w	lr, r1, lr, lsl #12
  n /= 10;
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
 800388e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8003892:	ea45 5503 	orr.w	r5, r5, r3, lsl #20
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_set_time(RTCDriver *rtcp, const RTCDateTime *timespec) {
 8003896:	4606      	mov	r6, r0
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8003898:	ea4e 1707 	orr.w	r7, lr, r7, lsl #4
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {

  return chSysGetStatusAndLockX();
 800389c:	f7fd fcf8 	bl	8001290 <chSysGetStatusAndLockX>
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 80038a0:	f241 21dc 	movw	r1, #4828	; 0x12dc
 80038a4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80038a8:	680c      	ldr	r4, [r1, #0]
 80038aa:	68e3      	ldr	r3, [r4, #12]
 80038ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80038b0:	60e3      	str	r3, [r4, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 80038b2:	68e3      	ldr	r3, [r4, #12]
 80038b4:	0659      	lsls	r1, r3, #25
 80038b6:	d5fc      	bpl.n	80038b2 <rtc_lld_set_time+0x112>
  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();

  /* Writing the registers.*/
  rtc_enter_init();
  rtcp->rtc->TR = tr;
 80038b8:	6831      	ldr	r1, [r6, #0]
 80038ba:	600d      	str	r5, [r1, #0]
  rtcp->rtc->DR = dr;
 80038bc:	604f      	str	r7, [r1, #4]
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 80038be:	68e3      	ldr	r3, [r4, #12]
 80038c0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80038c4:	60e3      	str	r3, [r4, #12]
  rtcp->rtc->DR = dr;
  rtc_exit_init();

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
}
 80038c6:	b003      	add	sp, #12
 80038c8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {

  chSysRestoreStatusX(sts);
 80038cc:	f7fd bcf0 	b.w	80012b0 <chSysRestoreStatusX>

080038d0 <rtc_lld_get_time>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_get_time(RTCDriver *rtcp, RTCDateTime *timespec) {
 80038d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80038d4:	4605      	mov	r5, r0
 80038d6:	460c      	mov	r4, r1
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {

  return chSysGetStatusAndLockX();
 80038d8:	f7fd fcda 	bl	8001290 <chSysGetStatusAndLockX>
 80038dc:	682a      	ldr	r2, [r5, #0]
  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();

  /* Synchronization with the RTC and reading the registers, note
     DR must be read last.*/
  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0)
 80038de:	68d3      	ldr	r3, [r2, #12]
 80038e0:	069d      	lsls	r5, r3, #26
 80038e2:	d5fc      	bpl.n	80038de <rtc_lld_get_time+0xe>
    ;
#if STM32_RTC_HAS_SUBSECONDS
  ssr = rtcp->rtc->SSR;
 80038e4:	6a97      	ldr	r7, [r2, #40]	; 0x28
#endif /* STM32_RTC_HAS_SUBSECONDS */
  tr  = rtcp->rtc->TR;
 80038e6:	6816      	ldr	r6, [r2, #0]
  dr  = rtcp->rtc->DR;
 80038e8:	6855      	ldr	r5, [r2, #4]
  rtcp->rtc->ISR &= ~RTC_ISR_RSF;
 80038ea:	68d3      	ldr	r3, [r2, #12]
 80038ec:	f023 0320 	bic.w	r3, r3, #32
 80038f0:	60d3      	str	r3, [r2, #12]
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {

  chSysRestoreStatusX(sts);
 80038f2:	f7fd fcdd 	bl	80012b0 <chSysRestoreStatusX>
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
 80038f6:	f64e 6180 	movw	r1, #61056	; 0xee80
 80038fa:	f3c6 4003 	ubfx	r0, r6, #16, #4
 80038fe:	f2c0 0136 	movt	r1, #54	; 0x36
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 8003902:	f44f 43a2 	mov.w	r3, #20736	; 0x5100
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
 8003906:	fb01 f100 	mul.w	r1, r1, r0
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 800390a:	f2c0 2325 	movt	r3, #549	; 0x225
 800390e:	f3c6 5001 	ubfx	r0, r6, #20, #2
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
 8003912:	fb03 1300 	mla	r3, r3, r0, r1
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
  n += ((tr >> RTC_TR_SU_OFFSET) & 15)  * 1000;
 8003916:	f44f 797a 	mov.w	r9, #1000	; 0x3e8
 800391a:	f006 000f 	and.w	r0, r6, #15
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
 800391e:	f44f 511f 	mov.w	r1, #10176	; 0x27c0
 8003922:	fb09 3000 	mla	r0, r9, r0, r3
  rtc_decode_time(tr, timespec);

  /* If the RTC is capable of sub-second counting then the value is
     normalized in milliseconds and added to the time.*/
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
 8003926:	f64f 4218 	movw	r2, #64536	; 0xfc18
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 800392a:	f3c5 3300 	ubfx	r3, r5, #12, #1
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
 800392e:	f3c6 3902 	ubfx	r9, r6, #12, #3
 8003932:	f2c0 0109 	movt	r1, #9
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
 8003936:	fb01 0109 	mla	r1, r1, r9, r0
  rtc_decode_time(tr, timespec);

  /* If the RTC is capable of sub-second counting then the value is
     normalized in milliseconds and added to the time.*/
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
 800393a:	f6cf 72ff 	movt	r2, #65535	; 0xffff
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
 800393e:	f3c6 2003 	ubfx	r0, r6, #8, #4
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8003942:	ea4f 0883 	mov.w	r8, r3, lsl #2
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
 8003946:	f64e 2960 	movw	r9, #60000	; 0xea60
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
 800394a:	fb09 1900 	mla	r9, r9, r0, r1
  rtc_decode_time(tr, timespec);

  /* If the RTC is capable of sub-second counting then the value is
     normalized in milliseconds and added to the time.*/
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
 800394e:	fb02 f707 	mul.w	r7, r2, r7
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8003952:	f3c5 2003 	ubfx	r0, r5, #8, #4

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
 8003956:	f3c6 1602 	ubfx	r6, r6, #4, #3
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 800395a:	4498      	add	r8, r3
 800395c:	7862      	ldrb	r2, [r4, #1]
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 800395e:	6861      	ldr	r1, [r4, #4]

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8003960:	78a3      	ldrb	r3, [r4, #2]

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
 8003962:	f242 7c10 	movw	ip, #10000	; 0x2710
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8003966:	eb00 0848 	add.w	r8, r0, r8, lsl #1
  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
  n += ((tr >> RTC_TR_SU_OFFSET) & 15)  * 1000;
 800396a:	fb0c 9c06 	mla	ip, ip, r6, r9

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 800396e:	f3c5 1001 	ubfx	r0, r5, #4, #2
  rtc_decode_time(tr, timespec);

  /* If the RTC is capable of sub-second counting then the value is
     normalized in milliseconds and added to the time.*/
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
 8003972:	f507 2779 	add.w	r7, r7, #1019904	; 0xf9000
 8003976:	f607 4718 	addw	r7, r7, #3096	; 0xc18
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 800397a:	f368 0203 	bfi	r2, r8, #0, #4
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 800397e:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8003982:	f005 080f 	and.w	r8, r5, #15
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8003986:	f3c5 5003 	ubfx	r0, r5, #20, #4
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 800398a:	f02c 4c78 	bic.w	ip, ip, #4160749568	; 0xf8000000
 800398e:	eb0c 2c97 	add.w	ip, ip, r7, lsr #10

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8003992:	eb08 0646 	add.w	r6, r8, r6, lsl #1
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 8003996:	0b6f      	lsrs	r7, r5, #13
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8003998:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800399c:	f3c5 4503 	ubfx	r5, r5, #16, #4
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 80039a0:	f36c 011a 	bfi	r1, ip, #0, #27
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 80039a4:	f367 1247 	bfi	r2, r7, #5, #3

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 80039a8:	f366 0304 	bfi	r3, r6, #0, #5
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 80039ac:	eb05 0040 	add.w	r0, r5, r0, lsl #1
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 80039b0:	6061      	str	r1, [r4, #4]
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 80039b2:	7062      	strb	r2, [r4, #1]

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 80039b4:	70a3      	strb	r3, [r4, #2]
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 80039b6:	7020      	strb	r0, [r4, #0]
 80039b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80039bc:	f3af 8000 	nop.w

080039c0 <rtcSTM32SetPeriodicWakeup>:
 * @param[in] rtcp       pointer to RTC driver structure
 * @param[in] wakeupspec pointer to a @p RTCWakeup structure
 *
 * @api
 */
void rtcSTM32SetPeriodicWakeup(RTCDriver *rtcp, const RTCWakeup *wakeupspec) {
 80039c0:	b538      	push	{r3, r4, r5, lr}
 80039c2:	460c      	mov	r4, r1
 80039c4:	4605      	mov	r5, r0
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {

  return chSysGetStatusAndLockX();
 80039c6:	f7fd fc63 	bl	8001290 <chSysGetStatusAndLockX>
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();

  if (wakeupspec != NULL) {
 80039ca:	b1cc      	cbz	r4, 8003a00 <rtcSTM32SetPeriodicWakeup+0x40>
    osalDbgCheck(wakeupspec->wutr != 0x30000);

    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 80039cc:	682a      	ldr	r2, [r5, #0]
 80039ce:	6893      	ldr	r3, [r2, #8]
 80039d0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80039d4:	6093      	str	r3, [r2, #8]
    while (!(rtcp->rtc->ISR & RTC_ISR_WUTWF))
 80039d6:	68d3      	ldr	r3, [r2, #12]
 80039d8:	0759      	lsls	r1, r3, #29
 80039da:	d5fc      	bpl.n	80039d6 <rtcSTM32SetPeriodicWakeup+0x16>
      ;
    rtcp->rtc->WUTR = wakeupspec->wutr & 0xFFFF;
 80039dc:	6823      	ldr	r3, [r4, #0]
 80039de:	b299      	uxth	r1, r3
    rtcp->rtc->CR   = (wakeupspec->wutr >> 16) & 0x7;
 80039e0:	f3c3 4302 	ubfx	r3, r3, #16, #3
    osalDbgCheck(wakeupspec->wutr != 0x30000);

    rtcp->rtc->CR &= ~RTC_CR_WUTE;
    while (!(rtcp->rtc->ISR & RTC_ISR_WUTWF))
      ;
    rtcp->rtc->WUTR = wakeupspec->wutr & 0xFFFF;
 80039e4:	6151      	str	r1, [r2, #20]
    rtcp->rtc->CR   = (wakeupspec->wutr >> 16) & 0x7;
 80039e6:	6093      	str	r3, [r2, #8]
    rtcp->rtc->CR |= RTC_CR_WUTIE;
 80039e8:	6893      	ldr	r3, [r2, #8]
 80039ea:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80039ee:	6093      	str	r3, [r2, #8]
    rtcp->rtc->CR |= RTC_CR_WUTE;
 80039f0:	6893      	ldr	r3, [r2, #8]
 80039f2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80039f6:	6093      	str	r3, [r2, #8]
    rtcp->rtc->CR &= ~RTC_CR_WUTE;
  }

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
}
 80039f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {

  chSysRestoreStatusX(sts);
 80039fc:	f7fd bc58 	b.w	80012b0 <chSysRestoreStatusX>
    rtcp->rtc->CR   = (wakeupspec->wutr >> 16) & 0x7;
    rtcp->rtc->CR |= RTC_CR_WUTIE;
    rtcp->rtc->CR |= RTC_CR_WUTE;
  }
  else {
    rtcp->rtc->CR &= ~RTC_CR_WUTIE;
 8003a00:	682b      	ldr	r3, [r5, #0]
 8003a02:	689a      	ldr	r2, [r3, #8]
 8003a04:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8003a08:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 8003a0a:	689a      	ldr	r2, [r3, #8]
 8003a0c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003a10:	609a      	str	r2, [r3, #8]
  }

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
}
 8003a12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003a16:	f7fd bc4b 	b.w	80012b0 <chSysRestoreStatusX>
 8003a1a:	bf00      	nop
 8003a1c:	f3af 8000 	nop.w

08003a20 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8003a20:	b570      	push	{r4, r5, r6, lr}

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 8003a22:	f241 25e0 	movw	r5, #4832	; 0x12e0
 8003a26:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8003a2a:	4628      	mov	r0, r5
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8003a2c:	f241 24fc 	movw	r4, #4860	; 0x12fc
 */
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 8003a30:	f7fe f976 	bl	8001d20 <pwmObjectInit>
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8003a34:	f2c2 0400 	movt	r4, #8192	; 0x2000

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8003a38:	2300      	movs	r3, #0
 8003a3a:	f2c4 0301 	movt	r3, #16385	; 0x4001
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8003a3e:	2604      	movs	r6, #4
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8003a40:	4620      	mov	r0, r4

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8003a42:	61ab      	str	r3, [r5, #24]
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8003a44:	742e      	strb	r6, [r5, #16]
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8003a46:	f7fe f96b 	bl	8001d20 <pwmObjectInit>
  PWMD3.channels = STM32_TIM3_CHANNELS;
  PWMD3.tim = STM32_TIM3;
 8003a4a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003a4e:	f2c4 0300 	movt	r3, #16384	; 0x4000
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8003a52:	7426      	strb	r6, [r4, #16]
  PWMD3.tim = STM32_TIM3;
 8003a54:	61a3      	str	r3, [r4, #24]
 8003a56:	bd70      	pop	{r4, r5, r6, pc}
 8003a58:	f3af 8000 	nop.w
 8003a5c:	f3af 8000 	nop.w

08003a60 <pwm_lld_start>:
 */
void pwm_lld_start(PWMDriver *pwmp) {
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 8003a60:	7803      	ldrb	r3, [r0, #0]
 8003a62:	2b01      	cmp	r3, #1
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 8003a64:	b570      	push	{r4, r5, r6, lr}
 8003a66:	4604      	mov	r4, r0
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 8003a68:	d04e      	beq.n	8003b08 <pwm_lld_start+0xa8>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8003a6a:	6983      	ldr	r3, [r0, #24]
 8003a6c:	2200      	movs	r2, #0
 8003a6e:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8003a70:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8003a72:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8003a74:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8003a76:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8003a78:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8003a7a:	6862      	ldr	r2, [r4, #4]
 8003a7c:	6966      	ldr	r6, [r4, #20]
 8003a7e:	6810      	ldr	r0, [r2, #0]
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8003a80:	68d1      	ldr	r1, [r2, #12]
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
 8003a82:	68a5      	ldr	r5, [r4, #8]
  pwmp->tim->CR2  = pwmp->config->cr2;
 8003a84:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8003a86:	fbb6 f0f0 	udiv	r0, r6, r0
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8003a8a:	f001 010f 	and.w	r1, r1, #15
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8003a8e:	3801      	subs	r0, #1
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
 8003a90:	3d01      	subs	r5, #1
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8003a92:	2901      	cmp	r1, #1
  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 8003a94:	6298      	str	r0, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8003a96:	62dd      	str	r5, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8003a98:	605c      	str	r4, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8003a9a:	d003      	beq.n	8003aa4 <pwm_lld_start+0x44>
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
 8003a9c:	2902      	cmp	r1, #2
 8003a9e:	bf0c      	ite	eq
 8003aa0:	2103      	moveq	r1, #3
 8003aa2:	2100      	movne	r1, #0
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8003aa4:	6950      	ldr	r0, [r2, #20]
 8003aa6:	f000 000f 	and.w	r0, r0, #15
 8003aaa:	2801      	cmp	r0, #1
 8003aac:	d029      	beq.n	8003b02 <pwm_lld_start+0xa2>
 8003aae:	2802      	cmp	r0, #2
 8003ab0:	d025      	beq.n	8003afe <pwm_lld_start+0x9e>
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8003ab2:	69d0      	ldr	r0, [r2, #28]
 8003ab4:	f000 000f 	and.w	r0, r0, #15
 8003ab8:	2801      	cmp	r0, #1
 8003aba:	d01d      	beq.n	8003af8 <pwm_lld_start+0x98>
 8003abc:	2802      	cmp	r0, #2
 8003abe:	d019      	beq.n	8003af4 <pwm_lld_start+0x94>
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8003ac0:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8003ac2:	f000 000f 	and.w	r0, r0, #15
 8003ac6:	2801      	cmp	r0, #1
 8003ac8:	d003      	beq.n	8003ad2 <pwm_lld_start+0x72>
 8003aca:	2802      	cmp	r0, #2
 8003acc:	d103      	bne.n	8003ad6 <pwm_lld_start+0x76>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 8003ace:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 8003ad2:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8003ad6:	6b10      	ldr	r0, [r2, #48]	; 0x30
      ;
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
 8003ad8:	6219      	str	r1, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8003ada:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8003ade:	2501      	movs	r5, #1
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8003ae0:	2400      	movs	r4, #0
                     ~STM32_TIM_DIER_IRQ_MASK;
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
#if STM32_PWM_USE_ADVANCED
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8003ae2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8003ae6:	2285      	movs	r2, #133	; 0x85
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8003ae8:	615d      	str	r5, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8003aea:	611c      	str	r4, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8003aec:	60d8      	str	r0, [r3, #12]
                     ~STM32_TIM_DIER_IRQ_MASK;
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
#if STM32_PWM_USE_ADVANCED
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8003aee:	6459      	str	r1, [r3, #68]	; 0x44
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8003af0:	601a      	str	r2, [r3, #0]
 8003af2:	bd70      	pop	{r4, r5, r6, pc}
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 8003af4:	f441 7100 	orr.w	r1, r1, #512	; 0x200
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 8003af8:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8003afc:	e7e0      	b.n	8003ac0 <pwm_lld_start+0x60>
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 8003afe:	f041 0120 	orr.w	r1, r1, #32
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 8003b02:	f041 0110 	orr.w	r1, r1, #16
 8003b06:	e7d4      	b.n	8003ab2 <pwm_lld_start+0x52>
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 8003b08:	f241 23e0 	movw	r3, #4832	; 0x12e0
 8003b0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003b10:	4298      	cmp	r0, r3
 8003b12:	d00b      	beq.n	8003b2c <pwm_lld_start+0xcc>
#endif
    }
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
 8003b14:	f241 23fc 	movw	r3, #4860	; 0x12fc
 8003b18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003b1c:	4298      	cmp	r0, r3
 8003b1e:	d021      	beq.n	8003b64 <pwm_lld_start+0x104>
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8003b20:	69a3      	ldr	r3, [r4, #24]
 8003b22:	f646 0268 	movw	r2, #26728	; 0x6868
 8003b26:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8003b28:	61da      	str	r2, [r3, #28]
 8003b2a:	e7a6      	b.n	8003a7a <pwm_lld_start+0x1a>

  if (pwmp->state == PWM_STOP) {
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
      rccEnableTIM1(FALSE);
 8003b2c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003b30:	f2c4 0302 	movt	r3, #16386	; 0x4002
      rccResetTIM1();
 8003b34:	2200      	movs	r2, #0

  if (pwmp->state == PWM_STOP) {
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
      rccEnableTIM1(FALSE);
 8003b36:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8003b38:	f041 0101 	orr.w	r1, r1, #1
 8003b3c:	6459      	str	r1, [r3, #68]	; 0x44
      rccResetTIM1();
 8003b3e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8003b40:	f041 0101 	orr.w	r1, r1, #1
 8003b44:	6259      	str	r1, [r3, #36]	; 0x24
#if !defined(STM32_TIM1_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 8003b46:	2019      	movs	r0, #25
  if (pwmp->state == PWM_STOP) {
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
      rccEnableTIM1(FALSE);
      rccResetTIM1();
 8003b48:	625a      	str	r2, [r3, #36]	; 0x24
#if !defined(STM32_TIM1_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 8003b4a:	2107      	movs	r1, #7
 8003b4c:	f7fe ff10 	bl	8002970 <nvicEnableVector>
      nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 8003b50:	201b      	movs	r0, #27
#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
      rccEnableTIM3(FALSE);
      rccResetTIM3();
#if !defined(STM32_TIM3_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_PWM_TIM3_IRQ_PRIORITY);
 8003b52:	2107      	movs	r1, #7
 8003b54:	f7fe ff0c 	bl	8002970 <nvicEnableVector>
#endif
#if defined(STM32_TIM3CLK)
      pwmp->clock = STM32_TIM3CLK;
#else
      pwmp->clock = STM32_TIMCLK1;
 8003b58:	f44f 433d 	mov.w	r3, #48384	; 0xbd00
 8003b5c:	f2c0 5301 	movt	r3, #1281	; 0x501
 8003b60:	6163      	str	r3, [r4, #20]
 8003b62:	e7dd      	b.n	8003b20 <pwm_lld_start+0xc0>
    }
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
      rccEnableTIM3(FALSE);
 8003b64:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003b68:	f2c4 0302 	movt	r3, #16386	; 0x4002
      rccResetTIM3();
 8003b6c:	2200      	movs	r2, #0
    }
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
      rccEnableTIM3(FALSE);
 8003b6e:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8003b70:	f041 0102 	orr.w	r1, r1, #2
 8003b74:	6419      	str	r1, [r3, #64]	; 0x40
      rccResetTIM3();
 8003b76:	6a19      	ldr	r1, [r3, #32]
 8003b78:	f041 0102 	orr.w	r1, r1, #2
 8003b7c:	6219      	str	r1, [r3, #32]
#if !defined(STM32_TIM3_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_PWM_TIM3_IRQ_PRIORITY);
 8003b7e:	201d      	movs	r0, #29
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
      rccEnableTIM3(FALSE);
      rccResetTIM3();
 8003b80:	621a      	str	r2, [r3, #32]
 8003b82:	e7e6      	b.n	8003b52 <pwm_lld_start+0xf2>
 8003b84:	f3af 8000 	nop.w
 8003b88:	f3af 8000 	nop.w
 8003b8c:	f3af 8000 	nop.w

08003b90 <pwm_lld_stop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_stop(PWMDriver *pwmp) {
 8003b90:	b508      	push	{r3, lr}

  /* If in ready state then disables the PWM clock.*/
  if (pwmp->state == PWM_READY) {
 8003b92:	7803      	ldrb	r3, [r0, #0]
 8003b94:	2b02      	cmp	r3, #2
 8003b96:	d000      	beq.n	8003b9a <pwm_lld_stop+0xa>
 8003b98:	bd08      	pop	{r3, pc}
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
    pwmp->tim->BDTR  = 0;
#endif

#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 8003b9a:	f241 21e0 	movw	r1, #4832	; 0x12e0
 */
void pwm_lld_stop(PWMDriver *pwmp) {

  /* If in ready state then disables the PWM clock.*/
  if (pwmp->state == PWM_READY) {
    pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
 8003b9e:	6983      	ldr	r3, [r0, #24]
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
    pwmp->tim->BDTR  = 0;
#endif

#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 8003ba0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 */
void pwm_lld_stop(PWMDriver *pwmp) {

  /* If in ready state then disables the PWM clock.*/
  if (pwmp->state == PWM_READY) {
    pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
 8003ba4:	2200      	movs	r2, #0
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
    pwmp->tim->BDTR  = 0;
#endif

#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 8003ba6:	4288      	cmp	r0, r1
 */
void pwm_lld_stop(PWMDriver *pwmp) {

  /* If in ready state then disables the PWM clock.*/
  if (pwmp->state == PWM_READY) {
    pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
 8003ba8:	601a      	str	r2, [r3, #0]
    pwmp->tim->DIER = 0;                    /* All IRQs disabled.           */
 8003baa:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 8003bac:	611a      	str	r2, [r3, #16]
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
    pwmp->tim->BDTR  = 0;
 8003bae:	645a      	str	r2, [r3, #68]	; 0x44
#endif

#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 8003bb0:	d011      	beq.n	8003bd6 <pwm_lld_stop+0x46>
      rccDisableTIM2(FALSE);
    }
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
 8003bb2:	f241 23fc 	movw	r3, #4860	; 0x12fc
 8003bb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bba:	4298      	cmp	r0, r3
 8003bbc:	d1ec      	bne.n	8003b98 <pwm_lld_stop+0x8>
#if !defined(STM32_TIM3_SUPPRESS_ISR)
      nvicDisableVector(STM32_TIM3_NUMBER);
 8003bbe:	201d      	movs	r0, #29
 8003bc0:	f7fe fef6 	bl	80029b0 <nvicDisableVector>
#endif
      rccDisableTIM3(FALSE);
 8003bc4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003bc8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003bcc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003bce:	f022 0202 	bic.w	r2, r2, #2
 8003bd2:	641a      	str	r2, [r3, #64]	; 0x40
 8003bd4:	e7e0      	b.n	8003b98 <pwm_lld_stop+0x8>
#endif

#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
#if !defined(STM32_TIM1_SUPPRESS_ISR)
      nvicDisableVector(STM32_TIM1_UP_NUMBER);
 8003bd6:	2019      	movs	r0, #25
 8003bd8:	f7fe feea 	bl	80029b0 <nvicDisableVector>
      nvicDisableVector(STM32_TIM1_CC_NUMBER);
 8003bdc:	201b      	movs	r0, #27
 8003bde:	f7fe fee7 	bl	80029b0 <nvicDisableVector>
#endif
      rccDisableTIM1(FALSE);
 8003be2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003be6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003bea:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003bec:	f022 0201 	bic.w	r2, r2, #1
 8003bf0:	645a      	str	r2, [r3, #68]	; 0x44
 8003bf2:	bd08      	pop	{r3, pc}
 8003bf4:	f3af 8000 	nop.w
 8003bf8:	f3af 8000 	nop.w
 8003bfc:	f3af 8000 	nop.w

08003c00 <pwm_lld_enable_channel>:
                            pwmchannel_t channel,
                            pwmcnt_t width) {

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 8003c00:	6983      	ldr	r3, [r0, #24]
 8003c02:	310c      	adds	r1, #12
 8003c04:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8003c08:	605a      	str	r2, [r3, #4]
 8003c0a:	4770      	bx	lr
 8003c0c:	f3af 8000 	nop.w

08003c10 <pwm_lld_disable_channel>:
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel) {

#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = 0;
 8003c10:	6983      	ldr	r3, [r0, #24]
 8003c12:	f101 020c 	add.w	r2, r1, #12
 8003c16:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8003c1a:	2000      	movs	r0, #0
 8003c1c:	6050      	str	r0, [r2, #4]
  pwmp->tim->DIER &= ~(2 << channel);
 8003c1e:	68da      	ldr	r2, [r3, #12]
 8003c20:	2002      	movs	r0, #2
 8003c22:	fa00 f101 	lsl.w	r1, r0, r1
 8003c26:	ea22 0101 	bic.w	r1, r2, r1
 8003c2a:	60d9      	str	r1, [r3, #12]
 8003c2c:	4770      	bx	lr
 8003c2e:	bf00      	nop

08003c30 <pwm_lld_enable_periodic_notification>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_enable_periodic_notification(PWMDriver *pwmp) {
  uint32_t dier = pwmp->tim->DIER;
 8003c30:	6983      	ldr	r3, [r0, #24]
 8003c32:	68da      	ldr	r2, [r3, #12]

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & STM32_TIM_DIER_UIE) == 0) {
 8003c34:	07d1      	lsls	r1, r2, #31
    pwmp->tim->DIER = dier | STM32_TIM_DIER_UIE;
 8003c36:	bf5f      	itttt	pl
 8003c38:	f042 0201 	orrpl.w	r2, r2, #1
 8003c3c:	60da      	strpl	r2, [r3, #12]
    pwmp->tim->SR &= STM32_TIM_SR_UIF;
 8003c3e:	691a      	ldrpl	r2, [r3, #16]
 8003c40:	f002 0201 	andpl.w	r2, r2, #1
 8003c44:	bf58      	it	pl
 8003c46:	611a      	strpl	r2, [r3, #16]
 8003c48:	4770      	bx	lr
 8003c4a:	bf00      	nop
 8003c4c:	f3af 8000 	nop.w

08003c50 <pwm_lld_disable_periodic_notification>:
 *
 * @notapi
 */
void pwm_lld_disable_periodic_notification(PWMDriver *pwmp) {

  pwmp->tim->DIER &= ~STM32_TIM_DIER_UIE;
 8003c50:	6983      	ldr	r3, [r0, #24]
 8003c52:	68da      	ldr	r2, [r3, #12]
 8003c54:	f022 0201 	bic.w	r2, r2, #1
 8003c58:	60da      	str	r2, [r3, #12]
 8003c5a:	4770      	bx	lr
 8003c5c:	f3af 8000 	nop.w

08003c60 <pwm_lld_enable_channel_notification>:
 *
 * @notapi
 */
void pwm_lld_enable_channel_notification(PWMDriver *pwmp,
                                         pwmchannel_t channel) {
  uint32_t dier = pwmp->tim->DIER;
 8003c60:	6983      	ldr	r3, [r0, #24]
  osalDbgAssert(channel < 4, "callback not supported");
#endif

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & (2 << channel)) == 0) {
 8003c62:	2002      	movs	r0, #2
 *
 * @notapi
 */
void pwm_lld_enable_channel_notification(PWMDriver *pwmp,
                                         pwmchannel_t channel) {
  uint32_t dier = pwmp->tim->DIER;
 8003c64:	68da      	ldr	r2, [r3, #12]
  osalDbgAssert(channel < 4, "callback not supported");
#endif

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & (2 << channel)) == 0) {
 8003c66:	fa00 f101 	lsl.w	r1, r0, r1
 8003c6a:	4211      	tst	r1, r2
    pwmp->tim->DIER = dier | (2 << channel);
 8003c6c:	bf01      	itttt	eq
 8003c6e:	430a      	orreq	r2, r1
    pwmp->tim->SR   = ~(2 << channel);
 8003c70:	43c9      	mvneq	r1, r1
#endif

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & (2 << channel)) == 0) {
    pwmp->tim->DIER = dier | (2 << channel);
 8003c72:	60da      	streq	r2, [r3, #12]
    pwmp->tim->SR   = ~(2 << channel);
 8003c74:	6119      	streq	r1, [r3, #16]
 8003c76:	4770      	bx	lr
 8003c78:	f3af 8000 	nop.w
 8003c7c:	f3af 8000 	nop.w

08003c80 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8003c80:	b538      	push	{r3, r4, r5, lr}
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8003c82:	6983      	ldr	r3, [r0, #24]
 8003c84:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8003c86:	68dc      	ldr	r4, [r3, #12]
 8003c88:	4014      	ands	r4, r2
 8003c8a:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 8003c8c:	43d2      	mvns	r2, r2
 8003c8e:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8003c90:	07a3      	lsls	r3, r4, #30
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8003c92:	4605      	mov	r5, r0
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8003c94:	d503      	bpl.n	8003c9e <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
 8003c96:	6843      	ldr	r3, [r0, #4]
 8003c98:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8003c9a:	b103      	cbz	r3, 8003c9e <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 8003c9c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8003c9e:	0761      	lsls	r1, r4, #29
 8003ca0:	d504      	bpl.n	8003cac <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
 8003ca2:	686b      	ldr	r3, [r5, #4]
 8003ca4:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8003ca6:	b10b      	cbz	r3, 8003cac <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 8003ca8:	4628      	mov	r0, r5
 8003caa:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8003cac:	0722      	lsls	r2, r4, #28
 8003cae:	d504      	bpl.n	8003cba <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
 8003cb0:	686b      	ldr	r3, [r5, #4]
 8003cb2:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8003cb4:	b10b      	cbz	r3, 8003cba <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8003cb6:	4628      	mov	r0, r5
 8003cb8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8003cba:	06e3      	lsls	r3, r4, #27
 8003cbc:	d504      	bpl.n	8003cc8 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
 8003cbe:	686b      	ldr	r3, [r5, #4]
 8003cc0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8003cc2:	b10b      	cbz	r3, 8003cc8 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8003cc4:	4628      	mov	r0, r5
 8003cc6:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8003cc8:	07e0      	lsls	r0, r4, #31
 8003cca:	d504      	bpl.n	8003cd6 <pwm_lld_serve_interrupt+0x56>
 8003ccc:	686b      	ldr	r3, [r5, #4]
 8003cce:	689b      	ldr	r3, [r3, #8]
 8003cd0:	b10b      	cbz	r3, 8003cd6 <pwm_lld_serve_interrupt+0x56>
    pwmp->config->callback(pwmp);
 8003cd2:	4628      	mov	r0, r5
 8003cd4:	4798      	blx	r3
 8003cd6:	bd38      	pop	{r3, r4, r5, pc}
 8003cd8:	f3af 8000 	nop.w
 8003cdc:	f3af 8000 	nop.w

08003ce0 <VectorA4>:
 *          pointer is not equal to @p NULL in order to not perform an extra
 *          check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8003ce0:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8003ce2:	f245 64e8 	movw	r4, #22248	; 0x56e8
 8003ce6:	f6c0 0400 	movt	r4, #2048	; 0x800
 8003cea:	4620      	mov	r0, r4
 8003cec:	f7fd fb48 	bl	8001380 <_trace_isr_enter>

  pwm_lld_serve_interrupt(&PWMD1);
 8003cf0:	f241 20e0 	movw	r0, #4832	; 0x12e0
 8003cf4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003cf8:	f7ff ffc2 	bl	8003c80 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8003cfc:	4620      	mov	r0, r4
 8003cfe:	f7fd fb57 	bl	80013b0 <_trace_isr_leave>
}
 8003d02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 8003d06:	f7fd bf53 	b.w	8001bb0 <_port_irq_epilogue>
 8003d0a:	bf00      	nop
 8003d0c:	f3af 8000 	nop.w

08003d10 <VectorAC>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8003d10:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8003d12:	f245 64f4 	movw	r4, #22260	; 0x56f4
 8003d16:	f6c0 0400 	movt	r4, #2048	; 0x800
 8003d1a:	4620      	mov	r0, r4
 8003d1c:	f7fd fb30 	bl	8001380 <_trace_isr_enter>

  pwm_lld_serve_interrupt(&PWMD1);
 8003d20:	f241 20e0 	movw	r0, #4832	; 0x12e0
 8003d24:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003d28:	f7ff ffaa 	bl	8003c80 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8003d2c:	4620      	mov	r0, r4
 8003d2e:	f7fd fb3f 	bl	80013b0 <_trace_isr_leave>
}
 8003d32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 8003d36:	f7fd bf3b 	b.w	8001bb0 <_port_irq_epilogue>
 8003d3a:	bf00      	nop
 8003d3c:	f3af 8000 	nop.w

08003d40 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8003d40:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8003d42:	f245 64dc 	movw	r4, #22236	; 0x56dc
 8003d46:	f6c0 0400 	movt	r4, #2048	; 0x800
 8003d4a:	4620      	mov	r0, r4
 8003d4c:	f7fd fb18 	bl	8001380 <_trace_isr_enter>

  pwm_lld_serve_interrupt(&PWMD3);
 8003d50:	f241 20fc 	movw	r0, #4860	; 0x12fc
 8003d54:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003d58:	f7ff ff92 	bl	8003c80 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8003d5c:	4620      	mov	r0, r4
 8003d5e:	f7fd fb27 	bl	80013b0 <_trace_isr_leave>
}
 8003d62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
 8003d66:	f7fd bf23 	b.w	8001bb0 <_port_irq_epilogue>
 8003d6a:	bf00      	nop
 8003d6c:	f3af 8000 	nop.w

08003d70 <usart_stop>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {
 8003d70:	b430      	push	{r4, r5}

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8003d72:	6904      	ldr	r4, [r0, #16]
 8003d74:	6822      	ldr	r2, [r4, #0]
 8003d76:	6813      	ldr	r3, [r2, #0]
 8003d78:	f023 031f 	bic.w	r3, r3, #31
 8003d7c:	6013      	str	r3, [r2, #0]
 8003d7e:	6813      	ldr	r3, [r2, #0]
 8003d80:	07db      	lsls	r3, r3, #31
 8003d82:	d4fc      	bmi.n	8003d7e <usart_stop+0xe>
 8003d84:	7a25      	ldrb	r5, [r4, #8]
  dmaStreamDisable(uartp->dmatx);
 8003d86:	6941      	ldr	r1, [r0, #20]
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8003d88:	6863      	ldr	r3, [r4, #4]
  dmaStreamDisable(uartp->dmatx);
 8003d8a:	680a      	ldr	r2, [r1, #0]
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8003d8c:	243d      	movs	r4, #61	; 0x3d
 8003d8e:	40ac      	lsls	r4, r5
 8003d90:	601c      	str	r4, [r3, #0]
  dmaStreamDisable(uartp->dmatx);
 8003d92:	6813      	ldr	r3, [r2, #0]
 8003d94:	f023 031f 	bic.w	r3, r3, #31
 8003d98:	6013      	str	r3, [r2, #0]
 8003d9a:	6813      	ldr	r3, [r2, #0]
 8003d9c:	f013 0301 	ands.w	r3, r3, #1
 8003da0:	d1fb      	bne.n	8003d9a <usart_stop+0x2a>
 8003da2:	7a0c      	ldrb	r4, [r1, #8]
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
 8003da4:	6882      	ldr	r2, [r0, #8]
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
 8003da6:	6849      	ldr	r1, [r1, #4]
 8003da8:	203d      	movs	r0, #61	; 0x3d
 8003daa:	40a0      	lsls	r0, r4
 8003dac:	6008      	str	r0, [r1, #0]
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
  uartp->usart->CR2 = 0;
  uartp->usart->CR3 = 0;
}
 8003dae:	bc30      	pop	{r4, r5}
  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
 8003db0:	60d3      	str	r3, [r2, #12]
  uartp->usart->CR2 = 0;
 8003db2:	6113      	str	r3, [r2, #16]
  uartp->usart->CR3 = 0;
 8003db4:	6153      	str	r3, [r2, #20]
}
 8003db6:	4770      	bx	lr
 8003db8:	f3af 8000 	nop.w
 8003dbc:	f3af 8000 	nop.w

08003dc0 <uart_lld_serve_tx_end_irq>:
 */
static void uart_lld_serve_tx_end_irq(UARTDriver *uartp, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8003dc0:	f011 0f0c 	tst.w	r1, #12
 * @brief   TX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_tx_end_irq(UARTDriver *uartp, uint32_t flags) {
 8003dc4:	b510      	push	{r4, lr}
 8003dc6:	4604      	mov	r4, r0

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8003dc8:	d11b      	bne.n	8003e02 <uart_lld_serve_tx_end_irq+0x42>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8003dca:	6961      	ldr	r1, [r4, #20]
 8003dcc:	680a      	ldr	r2, [r1, #0]
 8003dce:	6813      	ldr	r3, [r2, #0]
 8003dd0:	f023 031f 	bic.w	r3, r3, #31
 8003dd4:	6013      	str	r3, [r2, #0]
 8003dd6:	6813      	ldr	r3, [r2, #0]
 8003dd8:	07d8      	lsls	r0, r3, #31
 8003dda:	d4fc      	bmi.n	8003dd6 <uart_lld_serve_tx_end_irq+0x16>

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8003ddc:	6863      	ldr	r3, [r4, #4]
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8003dde:	7a0a      	ldrb	r2, [r1, #8]

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8003de0:	681b      	ldr	r3, [r3, #0]
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8003de2:	6849      	ldr	r1, [r1, #4]
 8003de4:	203d      	movs	r0, #61	; 0x3d
 8003de6:	4090      	lsls	r0, r2

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8003de8:	2202      	movs	r2, #2
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8003dea:	6008      	str	r0, [r1, #0]

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8003dec:	7062      	strb	r2, [r4, #1]
 8003dee:	b12b      	cbz	r3, 8003dfc <uart_lld_serve_tx_end_irq+0x3c>
 8003df0:	4620      	mov	r0, r4
 8003df2:	4798      	blx	r3
 8003df4:	7863      	ldrb	r3, [r4, #1]
 8003df6:	2b02      	cmp	r3, #2
 8003df8:	d000      	beq.n	8003dfc <uart_lld_serve_tx_end_irq+0x3c>
 8003dfa:	bd10      	pop	{r4, pc}
 8003dfc:	2300      	movs	r3, #0
 8003dfe:	7063      	strb	r3, [r4, #1]
 8003e00:	bd10      	pop	{r4, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8003e02:	f245 7000 	movw	r0, #22272	; 0x5700
 8003e06:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003e0a:	f7fd f9f1 	bl	80011f0 <chSysHalt>
 8003e0e:	e7dc      	b.n	8003dca <uart_lld_serve_tx_end_irq+0xa>

08003e10 <uart_lld_serve_rx_end_irq>:
 */
static void uart_lld_serve_rx_end_irq(UARTDriver *uartp, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8003e10:	f011 0f0c 	tst.w	r1, #12
 * @brief   RX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_rx_end_irq(UARTDriver *uartp, uint32_t flags) {
 8003e14:	b570      	push	{r4, r5, r6, lr}
 8003e16:	4604      	mov	r4, r0

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8003e18:	d13b      	bne.n	8003e92 <uart_lld_serve_rx_end_irq+0x82>
  }
#else
  (void)flags;
#endif

  if (uartp->rxstate == UART_RX_IDLE) {
 8003e1a:	78a3      	ldrb	r3, [r4, #2]
 8003e1c:	b943      	cbnz	r3, 8003e30 <uart_lld_serve_rx_end_irq+0x20>
    /* Receiver in idle state, a callback is generated, if enabled, for each
       received character and then the driver stays in the same state.*/
    _uart_rx_idle_code(uartp);
 8003e1e:	6863      	ldr	r3, [r4, #4]
 8003e20:	68db      	ldr	r3, [r3, #12]
 8003e22:	2b00      	cmp	r3, #0
 8003e24:	d034      	beq.n	8003e90 <uart_lld_serve_rx_end_irq+0x80>
 8003e26:	8b21      	ldrh	r1, [r4, #24]
 8003e28:	4620      	mov	r0, r4
 8003e2a:	b289      	uxth	r1, r1
 8003e2c:	4798      	blx	r3
 8003e2e:	bd70      	pop	{r4, r5, r6, pc}
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8003e30:	6921      	ldr	r1, [r4, #16]
 8003e32:	680a      	ldr	r2, [r1, #0]
 8003e34:	6813      	ldr	r3, [r2, #0]
 8003e36:	f023 031f 	bic.w	r3, r3, #31
 8003e3a:	6013      	str	r3, [r2, #0]
 8003e3c:	6813      	ldr	r3, [r2, #0]
 8003e3e:	07dd      	lsls	r5, r3, #31
 8003e40:	d4fc      	bmi.n	8003e3c <uart_lld_serve_rx_end_irq+0x2c>
    _uart_rx_complete_isr_code(uartp);
 8003e42:	6860      	ldr	r0, [r4, #4]
    _uart_rx_idle_code(uartp);
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8003e44:	7a0e      	ldrb	r6, [r1, #8]
 8003e46:	684d      	ldr	r5, [r1, #4]
    _uart_rx_complete_isr_code(uartp);
 8003e48:	6883      	ldr	r3, [r0, #8]
    _uart_rx_idle_code(uartp);
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8003e4a:	213d      	movs	r1, #61	; 0x3d
 8003e4c:	fa01 f606 	lsl.w	r6, r1, r6
    _uart_rx_complete_isr_code(uartp);
 8003e50:	2102      	movs	r1, #2
    _uart_rx_idle_code(uartp);
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8003e52:	602e      	str	r6, [r5, #0]
    _uart_rx_complete_isr_code(uartp);
 8003e54:	70a1      	strb	r1, [r4, #2]
 8003e56:	b13b      	cbz	r3, 8003e68 <uart_lld_serve_rx_end_irq+0x58>
 8003e58:	4620      	mov	r0, r4
 8003e5a:	4798      	blx	r3
 8003e5c:	78a3      	ldrb	r3, [r4, #2]
 8003e5e:	2b02      	cmp	r3, #2
 8003e60:	d116      	bne.n	8003e90 <uart_lld_serve_rx_end_irq+0x80>
 8003e62:	6923      	ldr	r3, [r4, #16]
 8003e64:	6860      	ldr	r0, [r4, #4]
 8003e66:	681a      	ldr	r2, [r3, #0]
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8003e68:	68c1      	ldr	r1, [r0, #12]
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8003e6a:	68e3      	ldr	r3, [r4, #12]
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 8003e6c:	2900      	cmp	r1, #0
 8003e6e:	bf14      	ite	ne
 8003e70:	f44f 7188 	movne.w	r1, #272	; 0x110
 8003e74:	f44f 7180 	moveq.w	r1, #256	; 0x100
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8003e78:	430b      	orrs	r3, r1
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
    _uart_rx_complete_isr_code(uartp);
 8003e7a:	2500      	movs	r5, #0
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8003e7c:	2101      	movs	r1, #1
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8003e7e:	f104 0018 	add.w	r0, r4, #24
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
    _uart_rx_complete_isr_code(uartp);
 8003e82:	70a5      	strb	r5, [r4, #2]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8003e84:	60d0      	str	r0, [r2, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8003e86:	6051      	str	r1, [r2, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8003e88:	6013      	str	r3, [r2, #0]
  dmaStreamEnable(uartp->dmarx);
 8003e8a:	6813      	ldr	r3, [r2, #0]
 8003e8c:	430b      	orrs	r3, r1
 8003e8e:	6013      	str	r3, [r2, #0]
 8003e90:	bd70      	pop	{r4, r5, r6, pc}
 8003e92:	f245 7000 	movw	r0, #22272	; 0x5700
 8003e96:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003e9a:	f7fd f9a9 	bl	80011f0 <chSysHalt>
 8003e9e:	e7bc      	b.n	8003e1a <uart_lld_serve_rx_end_irq+0xa>

08003ea0 <VectorD4>:
/**
 * @brief   USART1 IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8003ea0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {
  uint16_t sr;
  USART_TypeDef *u = uartp->usart;
 8003ea2:	f241 3518 	movw	r5, #4888	; 0x1318
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8003ea6:	f245 700c 	movw	r0, #22284	; 0x570c
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {
  uint16_t sr;
  USART_TypeDef *u = uartp->usart;
 8003eaa:	f2c2 0500 	movt	r5, #8192	; 0x2000
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8003eae:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003eb2:	f7fd fa65 	bl	8001380 <_trace_isr_enter>
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {
  uint16_t sr;
  USART_TypeDef *u = uartp->usart;
 8003eb6:	68ac      	ldr	r4, [r5, #8]
  uint32_t cr1 = u->CR1;
 8003eb8:	68e7      	ldr	r7, [r4, #12]

  sr = u->SR;   /* SR reset step 1.*/
 8003eba:	6826      	ldr	r6, [r4, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8003ebc:	6863      	ldr	r3, [r4, #4]

  if (sr & (USART_SR_LBD | USART_SR_ORE | USART_SR_NE |
 8003ebe:	f240 130f 	movw	r3, #271	; 0x10f
 8003ec2:	4033      	ands	r3, r6
 8003ec4:	b303      	cbz	r3, 8003f08 <VectorD4+0x68>
            USART_SR_FE  | USART_SR_PE)) {
    u->SR = ~USART_SR_LBD;
    _uart_rx_error_isr_code(uartp, translate_errors(sr));
 8003ec6:	686b      	ldr	r3, [r5, #4]
 8003ec8:	691a      	ldr	r2, [r3, #16]
  sr = u->SR;   /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/

  if (sr & (USART_SR_LBD | USART_SR_ORE | USART_SR_NE |
            USART_SR_FE  | USART_SR_PE)) {
    u->SR = ~USART_SR_LBD;
 8003eca:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8003ece:	6023      	str	r3, [r4, #0]
    _uart_rx_error_isr_code(uartp, translate_errors(sr));
 8003ed0:	b1d2      	cbz	r2, 8003f08 <VectorD4+0x68>
static void serve_usart_irq(UARTDriver *uartp) {
  uint16_t sr;
  USART_TypeDef *u = uartp->usart;
  uint32_t cr1 = u->CR1;

  sr = u->SR;   /* SR reset step 1.*/
 8003ed2:	b2b3      	uxth	r3, r6
 * @param[in] sr        USART SR register value
 *
 * @return  The error flags.
 */
static uartflags_t translate_errors(uint16_t sr) {
  uartflags_t sts = 0;
 8003ed4:	f013 0f08 	tst.w	r3, #8
 8003ed8:	bf14      	ite	ne
 8003eda:	2110      	movne	r1, #16
 8003edc:	2100      	moveq	r1, #0

  if (sr & USART_SR_ORE)
    sts |= UART_OVERRUN_ERROR;
  if (sr & USART_SR_PE)
 8003ede:	07d8      	lsls	r0, r3, #31
    sts |= UART_PARITY_ERROR;
 8003ee0:	bf48      	it	mi
 8003ee2:	f041 0104 	orrmi.w	r1, r1, #4
  if (sr & USART_SR_FE)
 8003ee6:	0798      	lsls	r0, r3, #30
    sts |= UART_FRAMING_ERROR;
 8003ee8:	bf48      	it	mi
 8003eea:	f041 0108 	orrmi.w	r1, r1, #8
  if (sr & USART_SR_NE)
 8003eee:	0758      	lsls	r0, r3, #29
    sts |= UART_NOISE_ERROR;
 8003ef0:	bf48      	it	mi
 8003ef2:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_LBD)
 8003ef6:	05d8      	lsls	r0, r3, #23
  (void)u->DR;  /* SR reset step 2.*/

  if (sr & (USART_SR_LBD | USART_SR_ORE | USART_SR_NE |
            USART_SR_FE  | USART_SR_PE)) {
    u->SR = ~USART_SR_LBD;
    _uart_rx_error_isr_code(uartp, translate_errors(sr));
 8003ef8:	f241 3018 	movw	r0, #4888	; 0x1318
  if (sr & USART_SR_FE)
    sts |= UART_FRAMING_ERROR;
  if (sr & USART_SR_NE)
    sts |= UART_NOISE_ERROR;
  if (sr & USART_SR_LBD)
    sts |= UART_BREAK_DETECTED;
 8003efc:	bf48      	it	mi
 8003efe:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  (void)u->DR;  /* SR reset step 2.*/

  if (sr & (USART_SR_LBD | USART_SR_ORE | USART_SR_NE |
            USART_SR_FE  | USART_SR_PE)) {
    u->SR = ~USART_SR_LBD;
    _uart_rx_error_isr_code(uartp, translate_errors(sr));
 8003f02:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003f06:	4790      	blx	r2
  }

  if ((sr & USART_SR_TC) && (cr1 & USART_CR1_TCIE)) {
 8003f08:	0673      	lsls	r3, r6, #25
 8003f0a:	d50f      	bpl.n	8003f2c <VectorD4+0x8c>
 8003f0c:	067e      	lsls	r6, r7, #25
 8003f0e:	d50d      	bpl.n	8003f2c <VectorD4+0x8c>
    /* TC interrupt cleared and disabled.*/
    u->SR = ~USART_SR_TC;
    u->CR1 = cr1 & ~USART_CR1_TCIE;

    /* End of transmission, a callback is generated.*/
    _uart_tx2_isr_code(uartp);
 8003f10:	686b      	ldr	r3, [r5, #4]
 8003f12:	685b      	ldr	r3, [r3, #4]
  }

  if ((sr & USART_SR_TC) && (cr1 & USART_CR1_TCIE)) {
    /* TC interrupt cleared and disabled.*/
    u->SR = ~USART_SR_TC;
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003f14:	f027 0740 	bic.w	r7, r7, #64	; 0x40
    _uart_rx_error_isr_code(uartp, translate_errors(sr));
  }

  if ((sr & USART_SR_TC) && (cr1 & USART_CR1_TCIE)) {
    /* TC interrupt cleared and disabled.*/
    u->SR = ~USART_SR_TC;
 8003f18:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8003f1c:	6022      	str	r2, [r4, #0]
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003f1e:	60e7      	str	r7, [r4, #12]

    /* End of transmission, a callback is generated.*/
    _uart_tx2_isr_code(uartp);
 8003f20:	b123      	cbz	r3, 8003f2c <VectorD4+0x8c>
 8003f22:	f241 3018 	movw	r0, #4888	; 0x1318
 8003f26:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003f2a:	4798      	blx	r3

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD1);

  OSAL_IRQ_EPILOGUE();
 8003f2c:	f245 700c 	movw	r0, #22284	; 0x570c
 8003f30:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003f34:	f7fd fa3c 	bl	80013b0 <_trace_isr_leave>
}
 8003f38:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD1);

  OSAL_IRQ_EPILOGUE();
 8003f3c:	f7fd be38 	b.w	8001bb0 <_port_irq_epilogue>

08003f40 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
 8003f40:	b510      	push	{r4, lr}

#if STM32_UART_USE_USART1
  uartObjectInit(&UARTD1);
 8003f42:	f241 3418 	movw	r4, #4888	; 0x1318
 8003f46:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8003f4a:	4620      	mov	r0, r4
 8003f4c:	f7fe f810 	bl	8001f70 <uartObjectInit>
  UARTD1.usart   = USART1;
  UARTD1.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
  UARTD1.dmarx   = STM32_DMA_STREAM(STM32_UART_USART1_RX_DMA_STREAM);
 8003f50:	4b06      	ldr	r3, [pc, #24]	; (8003f6c <uart_lld_init+0x2c>)
 */
void uart_lld_init(void) {

#if STM32_UART_USE_USART1
  uartObjectInit(&UARTD1);
  UARTD1.usart   = USART1;
 8003f52:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003f56:	f2c4 0201 	movt	r2, #16385	; 0x4001
  UARTD1.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 8003f5a:	2006      	movs	r0, #6
  UARTD1.dmarx   = STM32_DMA_STREAM(STM32_UART_USART1_RX_DMA_STREAM);
  UARTD1.dmatx   = STM32_DMA_STREAM(STM32_UART_USART1_TX_DMA_STREAM);
 8003f5c:	f103 0118 	add.w	r1, r3, #24
 */
void uart_lld_init(void) {

#if STM32_UART_USE_USART1
  uartObjectInit(&UARTD1);
  UARTD1.usart   = USART1;
 8003f60:	60a2      	str	r2, [r4, #8]
  UARTD1.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 8003f62:	60e0      	str	r0, [r4, #12]
  UARTD1.dmarx   = STM32_DMA_STREAM(STM32_UART_USART1_RX_DMA_STREAM);
 8003f64:	6123      	str	r3, [r4, #16]
  UARTD1.dmatx   = STM32_DMA_STREAM(STM32_UART_USART1_TX_DMA_STREAM);
 8003f66:	6161      	str	r1, [r4, #20]
 8003f68:	bd10      	pop	{r4, pc}
 8003f6a:	bf00      	nop
 8003f6c:	08005688 	.word	0x08005688

08003f70 <uart_lld_start>:
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {

  if (uartp->state == UART_STOP) {
 8003f70:	7803      	ldrb	r3, [r0, #0]
 8003f72:	2b01      	cmp	r3, #1
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
 8003f74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003f78:	4604      	mov	r4, r0

  if (uartp->state == UART_STOP) {
 8003f7a:	d051      	beq.n	8004020 <uart_lld_start+0xb0>
 8003f7c:	6885      	ldr	r5, [r0, #8]
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
    uartp->rxbuf = 0;
  }

  uartp->rxstate = UART_RX_IDLE;
 8003f7e:	2300      	movs	r3, #0
 8003f80:	70a3      	strb	r3, [r4, #2]
  uartp->txstate = UART_TX_IDLE;
 8003f82:	7063      	strb	r3, [r4, #1]
static void usart_start(UARTDriver *uartp) {
  uint16_t cr1;
  USART_TypeDef *u = uartp->usart;

  /* Defensive programming, starting from a clean state.*/
  usart_stop(uartp);
 8003f84:	4620      	mov	r0, r4
 8003f86:	f7ff fef3 	bl	8003d70 <usart_stop>

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((uartp->usart == USART1) || (uartp->usart == USART6))
 8003f8a:	68a2      	ldr	r2, [r4, #8]
 8003f8c:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
 8003f90:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003f94:	f2c4 0101 	movt	r1, #16385	; 0x4001
 8003f98:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003f9c:	429a      	cmp	r2, r3
 8003f9e:	bf18      	it	ne
 8003fa0:	428a      	cmpne	r2, r1
#else
  if (uartp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / uartp->config->speed;
 8003fa2:	6863      	ldr	r3, [r4, #4]
 8003fa4:	bf06      	itte	eq
 8003fa6:	f44f 423d 	moveq.w	r2, #48384	; 0xbd00
 8003faa:	6959      	ldreq	r1, [r3, #20]
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;
 8003fac:	6959      	ldrne	r1, [r3, #20]
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8003fae:	68d8      	ldr	r0, [r3, #12]
  (void)u->DR;  /* SR reset step 2.*/
  u->SR = 0;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8003fb0:	8b5f      	ldrh	r7, [r3, #26]
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 8003fb2:	8b9e      	ldrh	r6, [r3, #28]
#else
  if (uartp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / uartp->config->speed;
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;
 8003fb4:	bf16      	itet	ne
 8003fb6:	f64d 6280 	movwne	r2, #56960	; 0xde80
#if STM32_HAS_USART6
  if ((uartp->usart == USART1) || (uartp->usart == USART6))
#else
  if (uartp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / uartp->config->speed;
 8003fba:	f2c0 5201 	movteq	r2, #1281	; 0x501
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;
 8003fbe:	f2c0 2280 	movtne	r2, #640	; 0x280
 8003fc2:	fbb2 f2f1 	udiv	r2, r2, r1
 8003fc6:	60aa      	str	r2, [r5, #8]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
  u->CR1 = uartp->config->cr1 | cr1;
 8003fc8:	8b1a      	ldrh	r2, [r3, #24]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8003fca:	6923      	ldr	r3, [r4, #16]
    u->BRR = STM32_PCLK2 / uartp->config->speed;
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;

  /* Resetting eventual pending status flags.*/
  (void)u->SR;  /* SR reset step 1.*/
 8003fcc:	6829      	ldr	r1, [r5, #0]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8003fce:	681b      	ldr	r3, [r3, #0]
  else
    u->BRR = STM32_PCLK1 / uartp->config->speed;

  /* Resetting eventual pending status flags.*/
  (void)u->SR;  /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/
 8003fd0:	6869      	ldr	r1, [r5, #4]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
  u->CR1 = uartp->config->cr1 | cr1;
 8003fd2:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
 8003fd6:	f042 020c 	orr.w	r2, r2, #12
 8003fda:	fa1f f882 	uxth.w	r8, r2
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8003fde:	68e2      	ldr	r2, [r4, #12]
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 8003fe0:	2800      	cmp	r0, #0
 8003fe2:	bf14      	ite	ne
 8003fe4:	f44f 7088 	movne.w	r0, #272	; 0x110
 8003fe8:	f44f 7080 	moveq.w	r0, #256	; 0x100
  (void)u->DR;  /* SR reset step 2.*/
  u->SR = 0;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8003fec:	f047 0740 	orr.w	r7, r7, #64	; 0x40
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 8003ff0:	f046 06c1 	orr.w	r6, r6, #193	; 0xc1
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8003ff4:	ea40 0102 	orr.w	r1, r0, r2
  (void)u->DR;  /* SR reset step 2.*/
  u->SR = 0;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8003ff8:	b2bf      	uxth	r7, r7
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8003ffa:	2001      	movs	r0, #1
    u->BRR = STM32_PCLK1 / uartp->config->speed;

  /* Resetting eventual pending status flags.*/
  (void)u->SR;  /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/
  u->SR = 0;
 8003ffc:	f04f 0c00 	mov.w	ip, #0

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 8004000:	b2b6      	uxth	r6, r6
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8004002:	3418      	adds	r4, #24
    u->BRR = STM32_PCLK1 / uartp->config->speed;

  /* Resetting eventual pending status flags.*/
  (void)u->SR;  /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/
  u->SR = 0;
 8004004:	f8c5 c000 	str.w	ip, [r5]

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8004008:	612f      	str	r7, [r5, #16]
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 800400a:	616e      	str	r6, [r5, #20]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
  u->CR1 = uartp->config->cr1 | cr1;
 800400c:	f8c5 800c 	str.w	r8, [r5, #12]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8004010:	60dc      	str	r4, [r3, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8004012:	6058      	str	r0, [r3, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8004014:	6019      	str	r1, [r3, #0]
  dmaStreamEnable(uartp->dmarx);
 8004016:	681a      	ldr	r2, [r3, #0]
 8004018:	4302      	orrs	r2, r0
 800401a:	601a      	str	r2, [r3, #0]
 800401c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 */
void uart_lld_start(UARTDriver *uartp) {

  if (uartp->state == UART_STOP) {
#if STM32_UART_USE_USART1
    if (&UARTD1 == uartp) {
 8004020:	f241 3318 	movw	r3, #4888	; 0x1318
 8004024:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004028:	4298      	cmp	r0, r3
 800402a:	d015      	beq.n	8004058 <uart_lld_start+0xe8>
    }
#endif

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
 800402c:	6863      	ldr	r3, [r4, #4]
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
 800402e:	6922      	ldr	r2, [r4, #16]
    }
#endif

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
 8004030:	8b1b      	ldrh	r3, [r3, #24]
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
 8004032:	68a5      	ldr	r5, [r4, #8]
 8004034:	6810      	ldr	r0, [r2, #0]
    }
#endif

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
 8004036:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 800403a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800403e:	bf02      	ittt	eq
 8004040:	68e3      	ldreq	r3, [r4, #12]
 8004042:	f443 5320 	orreq.w	r3, r3, #10240	; 0x2800
 8004046:	60e3      	streq	r3, [r4, #12]
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
 8004048:	6963      	ldr	r3, [r4, #20]
 800404a:	6819      	ldr	r1, [r3, #0]
    uartp->rxbuf = 0;
 800404c:	2200      	movs	r2, #0

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
 800404e:	1d2b      	adds	r3, r5, #4
 8004050:	6083      	str	r3, [r0, #8]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
 8004052:	608b      	str	r3, [r1, #8]
    uartp->rxbuf = 0;
 8004054:	8322      	strh	r2, [r4, #24]
 8004056:	e792      	b.n	8003f7e <uart_lld_start+0xe>

  if (uartp->state == UART_STOP) {
#if STM32_UART_USE_USART1
    if (&UARTD1 == uartp) {
      bool b;
      b = dmaStreamAllocate(uartp->dmarx,
 8004058:	f643 6211 	movw	r2, #15889	; 0x3e11
 800405c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8004060:	210c      	movs	r1, #12
 8004062:	4623      	mov	r3, r4
 8004064:	6900      	ldr	r0, [r0, #16]
 8004066:	f7ff f84b 	bl	8003100 <dmaStreamAllocate>
                            STM32_UART_USART1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_rx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(uartp->dmatx,
 800406a:	f643 52c1 	movw	r2, #15809	; 0x3dc1
 800406e:	f6c0 0200 	movt	r2, #2048	; 0x800
 8004072:	210c      	movs	r1, #12
 8004074:	4623      	mov	r3, r4
 8004076:	6960      	ldr	r0, [r4, #20]
 8004078:	f7ff f842 	bl	8003100 <dmaStreamAllocate>
                            STM32_UART_USART1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_tx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableUSART1(FALSE);
 800407c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004080:	f2c4 0302 	movt	r3, #16386	; 0x4002
      nvicEnableVector(STM32_USART1_NUMBER, STM32_UART_USART1_IRQ_PRIORITY);
 8004084:	2025      	movs	r0, #37	; 0x25
      b = dmaStreamAllocate(uartp->dmatx,
                            STM32_UART_USART1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_tx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableUSART1(FALSE);
 8004086:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004088:	f042 0210 	orr.w	r2, r2, #16
 800408c:	645a      	str	r2, [r3, #68]	; 0x44
      nvicEnableVector(STM32_USART1_NUMBER, STM32_UART_USART1_IRQ_PRIORITY);
 800408e:	210c      	movs	r1, #12
 8004090:	f7fe fc6e 	bl	8002970 <nvicEnableVector>
      uartp->dmamode |= STM32_DMA_CR_CHSEL(USART1_RX_DMA_CHANNEL) |
 8004094:	68e3      	ldr	r3, [r4, #12]
 8004096:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800409a:	60e3      	str	r3, [r4, #12]
 800409c:	e7c6      	b.n	800402c <uart_lld_start+0xbc>
 800409e:	bf00      	nop

080040a0 <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
 80040a0:	b430      	push	{r4, r5}

  /* TX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
 80040a2:	6943      	ldr	r3, [r0, #20]
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
                                 STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE);

  /* Only enable TC interrupt if there's a callback attached to it.
     Also we need to clear TC flag which could be set before. */
  if (uartp->config->txend2_cb != NULL) {
 80040a4:	6844      	ldr	r4, [r0, #4]
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {

  /* TX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
  dmaStreamSetTransactionSize(uartp->dmatx, n);
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
 80040a6:	68c5      	ldr	r5, [r0, #12]
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {

  /* TX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
 80040a8:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
                                 STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE);

  /* Only enable TC interrupt if there's a callback attached to it.
     Also we need to clear TC flag which could be set before. */
  if (uartp->config->txend2_cb != NULL) {
 80040aa:	6864      	ldr	r4, [r4, #4]
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {

  /* TX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
 80040ac:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(uartp->dmatx, n);
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
 80040ae:	f445 658a 	orr.w	r5, r5, #1104	; 0x450
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {

  /* TX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
  dmaStreamSetTransactionSize(uartp->dmatx, n);
 80040b2:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
 80040b4:	601d      	str	r5, [r3, #0]
                                 STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE);

  /* Only enable TC interrupt if there's a callback attached to it.
     Also we need to clear TC flag which could be set before. */
  if (uartp->config->txend2_cb != NULL) {
 80040b6:	b13c      	cbz	r4, 80040c8 <uart_lld_start_send+0x28>
    uartp->usart->SR = ~USART_SR_TC;
 80040b8:	6882      	ldr	r2, [r0, #8]
 80040ba:	f06f 0140 	mvn.w	r1, #64	; 0x40
 80040be:	6011      	str	r1, [r2, #0]
    uartp->usart->CR1 |= USART_CR1_TCIE;
 80040c0:	68d1      	ldr	r1, [r2, #12]
 80040c2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 80040c6:	60d1      	str	r1, [r2, #12]
  }

  /* Starting transfer.*/
  dmaStreamEnable(uartp->dmatx);
 80040c8:	681a      	ldr	r2, [r3, #0]
 80040ca:	f042 0201 	orr.w	r2, r2, #1
 80040ce:	601a      	str	r2, [r3, #0]
}
 80040d0:	bc30      	pop	{r4, r5}
 80040d2:	4770      	bx	lr
 80040d4:	f3af 8000 	nop.w
 80040d8:	f3af 8000 	nop.w
 80040dc:	f3af 8000 	nop.w

080040e0 <uart_lld_stop_send>:
 *
 * @notapi
 */
size_t uart_lld_stop_send(UARTDriver *uartp) {

  dmaStreamDisable(uartp->dmatx);
 80040e0:	6941      	ldr	r1, [r0, #20]
 80040e2:	680a      	ldr	r2, [r1, #0]
 80040e4:	6813      	ldr	r3, [r2, #0]
 80040e6:	f023 031f 	bic.w	r3, r3, #31
 80040ea:	6013      	str	r3, [r2, #0]
 80040ec:	6813      	ldr	r3, [r2, #0]
 80040ee:	07db      	lsls	r3, r3, #31
 80040f0:	d4fc      	bmi.n	80040ec <uart_lld_stop_send+0xc>
 80040f2:	7a08      	ldrb	r0, [r1, #8]
 80040f4:	684b      	ldr	r3, [r1, #4]
 80040f6:	213d      	movs	r1, #61	; 0x3d
 80040f8:	4081      	lsls	r1, r0
 80040fa:	6019      	str	r1, [r3, #0]

  return dmaStreamGetTransactionSize(uartp->dmatx);
 80040fc:	6850      	ldr	r0, [r2, #4]
}
 80040fe:	4770      	bx	lr

08004100 <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
 8004100:	b470      	push	{r4, r5, r6}

  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);
 8004102:	6905      	ldr	r5, [r0, #16]
 8004104:	682c      	ldr	r4, [r5, #0]
 8004106:	6823      	ldr	r3, [r4, #0]
 8004108:	f023 031f 	bic.w	r3, r3, #31
 800410c:	6023      	str	r3, [r4, #0]
 800410e:	6823      	ldr	r3, [r4, #0]
 8004110:	07de      	lsls	r6, r3, #31
 8004112:	d4fc      	bmi.n	800410e <uart_lld_start_receive+0xe>
 8004114:	7a2e      	ldrb	r6, [r5, #8]
 8004116:	686b      	ldr	r3, [r5, #4]
 8004118:	253d      	movs	r5, #61	; 0x3d
 800411a:	40b5      	lsls	r5, r6
 800411c:	601d      	str	r5, [r3, #0]

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, n);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode    | STM32_DMA_CR_DIR_P2M |
 800411e:	68c3      	ldr	r3, [r0, #12]

  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
 8004120:	60e2      	str	r2, [r4, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, n);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode    | STM32_DMA_CR_DIR_P2M |
 8004122:	f443 6382 	orr.w	r3, r3, #1040	; 0x410
  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, n);
 8004126:	6061      	str	r1, [r4, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode    | STM32_DMA_CR_DIR_P2M |
 8004128:	6023      	str	r3, [r4, #0]
                                 STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE);

  /* Starting transfer.*/
  dmaStreamEnable(uartp->dmarx);
 800412a:	6823      	ldr	r3, [r4, #0]
 800412c:	f043 0301 	orr.w	r3, r3, #1
 8004130:	6023      	str	r3, [r4, #0]
}
 8004132:	bc70      	pop	{r4, r5, r6}
 8004134:	4770      	bx	lr
 8004136:	bf00      	nop
 8004138:	f3af 8000 	nop.w
 800413c:	f3af 8000 	nop.w

08004140 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
 8004140:	4601      	mov	r1, r0
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 8004142:	6900      	ldr	r0, [r0, #16]
 8004144:	6802      	ldr	r2, [r0, #0]
 8004146:	6813      	ldr	r3, [r2, #0]
 8004148:	f023 031f 	bic.w	r3, r3, #31
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
 800414c:	b430      	push	{r4, r5}
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 800414e:	6013      	str	r3, [r2, #0]
 8004150:	6813      	ldr	r3, [r2, #0]
 8004152:	07db      	lsls	r3, r3, #31
 8004154:	d4fc      	bmi.n	8004150 <uart_lld_stop_receive+0x10>
 8004156:	7a04      	ldrb	r4, [r0, #8]
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8004158:	684b      	ldr	r3, [r1, #4]
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 800415a:	6840      	ldr	r0, [r0, #4]
 800415c:	253d      	movs	r5, #61	; 0x3d
 800415e:	fa05 f404 	lsl.w	r4, r5, r4
 8004162:	6004      	str	r4, [r0, #0]
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8004164:	68dc      	ldr	r4, [r3, #12]
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8004166:	68cb      	ldr	r3, [r1, #12]
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
  n = dmaStreamGetTransactionSize(uartp->dmarx);
 8004168:	6850      	ldr	r0, [r2, #4]
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 800416a:	2c00      	cmp	r4, #0
 800416c:	bf14      	ite	ne
 800416e:	f44f 7488 	movne.w	r4, #272	; 0x110
 8004172:	f44f 7480 	moveq.w	r4, #256	; 0x100
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8004176:	4323      	orrs	r3, r4
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8004178:	3118      	adds	r1, #24
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 800417a:	2401      	movs	r4, #1
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 800417c:	60d1      	str	r1, [r2, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 800417e:	6054      	str	r4, [r2, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8004180:	6013      	str	r3, [r2, #0]
  dmaStreamEnable(uartp->dmarx);
 8004182:	6813      	ldr	r3, [r2, #0]
 8004184:	4323      	orrs	r3, r4
 8004186:	6013      	str	r3, [r2, #0]
  dmaStreamDisable(uartp->dmarx);
  n = dmaStreamGetTransactionSize(uartp->dmarx);
  uart_enter_rx_idle_loop(uartp);

  return n;
}
 8004188:	bc30      	pop	{r4, r5}
 800418a:	4770      	bx	lr
 800418c:	f3af 8000 	nop.w

08004190 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 8004190:	f7fe bc6e 	b.w	8002a70 <stm32_clock_init>
 8004194:	f3af 8000 	nop.w
 8004198:	f3af 8000 	nop.w
 800419c:	f3af 8000 	nop.w

080041a0 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 80041a0:	4770      	bx	lr
 80041a2:	bf00      	nop
 80041a4:	f3af 8000 	nop.w
 80041a8:	f3af 8000 	nop.w
 80041ac:	f3af 8000 	nop.w

080041b0 <pwmpcb>:
 */


static void pwmpcb(PWMDriver *pwmp) {
  (void)pwmp;
    if(rrojo)
 80041b0:	f241 6324 	movw	r3, #5668	; 0x1624
 80041b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041b8:	881b      	ldrh	r3, [r3, #0]
 80041ba:	b133      	cbz	r3, 80041ca <pwmpcb+0x1a>
      palClearPad(GPIOB, 13);
 80041bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80041c0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80041c4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80041c8:	835a      	strh	r2, [r3, #26]
    if(rverde)
 80041ca:	f241 6322 	movw	r3, #5666	; 0x1622
 80041ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041d2:	881b      	ldrh	r3, [r3, #0]
 80041d4:	b133      	cbz	r3, 80041e4 <pwmpcb+0x34>
      palClearPad(GPIOB, 14);
 80041d6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80041da:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80041de:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80041e2:	835a      	strh	r2, [r3, #26]
    if(razul)
 80041e4:	f241 6350 	movw	r3, #5712	; 0x1650
 80041e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041ec:	881b      	ldrh	r3, [r3, #0]
 80041ee:	b133      	cbz	r3, 80041fe <pwmpcb+0x4e>
      palClearPad(GPIOB, 15);
 80041f0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80041f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80041f8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80041fc:	835a      	strh	r2, [r3, #26]
 80041fe:	4770      	bx	lr

08004200 <pwmc1cb>:
}

static void pwmc1cb(PWMDriver *pwmp) {

  (void)pwmp;
  palSetPad(GPIOB, 13);
 8004200:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004204:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004208:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800420c:	831a      	strh	r2, [r3, #24]
 800420e:	4770      	bx	lr

08004210 <pwmc2cb>:
}

static void pwmc2cb(PWMDriver *pwmp) {

  (void)pwmp;
  palSetPad(GPIOB, 14);
 8004210:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004214:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004218:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800421c:	831a      	strh	r2, [r3, #24]
 800421e:	4770      	bx	lr

08004220 <pwmc3cb>:
}

static void pwmc3cb(PWMDriver *pwmp) {

  (void)pwmp;
  palSetPad(GPIOB, 15);
 8004220:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004224:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004228:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800422c:	831a      	strh	r2, [r3, #24]
 800422e:	4770      	bx	lr

08004230 <Thd1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8004230:	f640 1258 	movw	r2, #2392	; 0x958
 8004234:	f2c2 0200 	movt	r2, #8192	; 0x2000
 * Tarea para el coeficiente de PH.
 */


static THD_WORKING_AREA(waThd1, 512);
static THD_FUNCTION(Thd1, arg) {
 8004238:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800423a:	6992      	ldr	r2, [r2, #24]
 800423c:	4c30      	ldr	r4, [pc, #192]	; (8004300 <Thd1+0xd0>)
 800423e:	f245 73e8 	movw	r3, #22504	; 0x57e8
 8004242:	f6c0 0300 	movt	r3, #2048	; 0x800
  (void) arg;
  chRegSetThreadName("ADC handler");
  /*
   * Activa el ADC.
   */
  adcStart(&ADCD1, NULL);
 8004246:	f241 20a8 	movw	r0, #4776	; 0x12a8
 800424a:	6193      	str	r3, [r2, #24]
 800424c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004250:	2100      	movs	r1, #0
 8004252:	f7fd fd35 	bl	8001cc0 <adcStart>
 8004256:	f241 374c 	movw	r7, #4940	; 0x134c
 800425a:	f241 664c 	movw	r6, #5708	; 0x164c
 800425e:	f241 3548 	movw	r5, #4936	; 0x1348
 8004262:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004266:	f2c2 0600 	movt	r6, #8192	; 0x2000
 800426a:	f2c2 0500 	movt	r5, #8192	; 0x2000
  while(TRUE) {
    adcConvert(&ADCD1, &my_conversion_group, sample_buff, MY_SAMPLING_NUMBER);
 800426e:	f241 20a8 	movw	r0, #4776	; 0x12a8
 8004272:	f245 71c0 	movw	r1, #22464	; 0x57c0
 8004276:	f241 622c 	movw	r2, #5676	; 0x162c
 800427a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800427e:	230a      	movs	r3, #10
 8004280:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004284:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004288:	f7fd fd2a 	bl	8001ce0 <adcConvert>
 800428c:	4b1d      	ldr	r3, [pc, #116]	; (8004304 <Thd1+0xd4>)
 800428e:	2200      	movs	r2, #0

    /* Haciendo el promedio de los valores del ADC.*/
    mean = 0;
    for (ii = 0; ii < MY_NUM_CH * MY_SAMPLING_NUMBER; ii++) {
      mean += sample_buff[ii];
 8004290:	f833 1f02 	ldrh.w	r1, [r3, #2]!
  while(TRUE) {
    adcConvert(&ADCD1, &my_conversion_group, sample_buff, MY_SAMPLING_NUMBER);

    /* Haciendo el promedio de los valores del ADC.*/
    mean = 0;
    for (ii = 0; ii < MY_NUM_CH * MY_SAMPLING_NUMBER; ii++) {
 8004294:	42a3      	cmp	r3, r4
      mean += sample_buff[ii];
 8004296:	440a      	add	r2, r1
  while(TRUE) {
    adcConvert(&ADCD1, &my_conversion_group, sample_buff, MY_SAMPLING_NUMBER);

    /* Haciendo el promedio de los valores del ADC.*/
    mean = 0;
    for (ii = 0; ii < MY_NUM_CH * MY_SAMPLING_NUMBER; ii++) {
 8004298:	d1fa      	bne.n	8004290 <Thd1+0x60>
      mean += sample_buff[ii];
    }
    mean /= MY_NUM_CH * MY_SAMPLING_NUMBER;
 800429a:	f246 6367 	movw	r3, #26215	; 0x6667
 800429e:	f2c6 6366 	movt	r3, #26214	; 0x6666
 80042a2:	fb83 1302 	smull	r1, r3, r3, r2
 80042a6:	17d2      	asrs	r2, r2, #31
 80042a8:	ebc2 02a3 	rsb	r2, r2, r3, asr #2
    lastvalue = (float)mean * 3.3 / 4096;
 80042ac:	4610      	mov	r0, r2
    /* Haciendo el promedio de los valores del ADC.*/
    mean = 0;
    for (ii = 0; ii < MY_NUM_CH * MY_SAMPLING_NUMBER; ii++) {
      mean += sample_buff[ii];
    }
    mean /= MY_NUM_CH * MY_SAMPLING_NUMBER;
 80042ae:	603a      	str	r2, [r7, #0]
    lastvalue = (float)mean * 3.3 / 4096;
 80042b0:	f7fc fd28 	bl	8000d04 <__aeabi_i2f>
 80042b4:	f7fc f990 	bl	80005d8 <__aeabi_f2d>
 80042b8:	a30d      	add	r3, pc, #52	; (adr r3, 80042f0 <Thd1+0xc0>)
 80042ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80042be:	f7fc f9df 	bl	8000680 <__aeabi_dmul>
 80042c2:	2300      	movs	r3, #0
 80042c4:	2200      	movs	r2, #0
 80042c6:	f6c3 7330 	movt	r3, #16176	; 0x3f30
 80042ca:	f7fc f9d9 	bl	8000680 <__aeabi_dmul>
 80042ce:	f7fc fc0f 	bl	8000af0 <__aeabi_d2f>
 80042d2:	6030      	str	r0, [r6, #0]

    /* pH */
    pH = lastvalue * 4.24;
 80042d4:	f7fc f980 	bl	80005d8 <__aeabi_f2d>
 80042d8:	a307      	add	r3, pc, #28	; (adr r3, 80042f8 <Thd1+0xc8>)
 80042da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80042de:	f7fc f9cf 	bl	8000680 <__aeabi_dmul>
 80042e2:	f7fc fc05 	bl	8000af0 <__aeabi_d2f>
 80042e6:	6028      	str	r0, [r5, #0]
  }
 80042e8:	e7c1      	b.n	800426e <Thd1+0x3e>
 80042ea:	bf00      	nop
 80042ec:	f3af 8000 	nop.w
 80042f0:	66666666 	.word	0x66666666
 80042f4:	400a6666 	.word	0x400a6666
 80042f8:	8f5c28f6 	.word	0x8f5c28f6
 80042fc:	4010f5c2 	.word	0x4010f5c2
 8004300:	2000163e 	.word	0x2000163e
 8004304:	2000162a 	.word	0x2000162a
 8004308:	f3af 8000 	nop.w
 800430c:	f3af 8000 	nop.w

08004310 <Thd2>:
 8004310:	f640 1258 	movw	r2, #2392	; 0x958
 8004314:	f2c2 0200 	movt	r2, #8192	; 0x2000
/*
 * Tarea PWM para la iluminación.
 */

static THD_WORKING_AREA(waThd2, 256);
static THD_FUNCTION(Thd2, arg) {
 8004318:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800431c:	6992      	ldr	r2, [r2, #24]
 800431e:	f245 73f4 	movw	r3, #22516	; 0x57f4
 8004322:	f6c0 0300 	movt	r3, #2048	; 0x800


  (void) arg;
  chRegSetThreadName("Led handler");
  pwmStart(&PWMD1, &pwmcfg);
 8004326:	f241 20e0 	movw	r0, #4832	; 0x12e0
 800432a:	f640 0144 	movw	r1, #2116	; 0x844
 800432e:	6193      	str	r3, [r2, #24]
 8004330:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004334:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8004338:	f7fd fcfa 	bl	8001d30 <pwmStart>
 800433c:	f241 6924 	movw	r9, #5668	; 0x1624
 8004340:	f241 353c 	movw	r5, #4924	; 0x133c
 8004344:	f241 24e0 	movw	r4, #4832	; 0x12e0
 8004348:	f241 6822 	movw	r8, #5666	; 0x1622
 800434c:	f241 6750 	movw	r7, #5712	; 0x1650



  while(TRUE) {            
	      aux = rrojo*39.2;
	      pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 8004350:	f241 7659 	movw	r6, #5977	; 0x1759
 8004354:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8004358:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800435c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8004360:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8004364:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004368:	f2cd 16b7 	movt	r6, #53687	; 0xd1b7
  pwmStart(&PWMD1, &pwmcfg);



  while(TRUE) {            
	      aux = rrojo*39.2;
 800436c:	f8b9 0000 	ldrh.w	r0, [r9]
 8004370:	f7fc f920 	bl	80005b4 <__aeabi_i2d>
 8004374:	a33c      	add	r3, pc, #240	; (adr r3, 8004468 <Thd2+0x158>)
 8004376:	e9d3 2300 	ldrd	r2, r3, [r3]
 800437a:	f7fc f981 	bl	8000680 <__aeabi_dmul>
 800437e:	f7fc fb97 	bl	8000ab0 <__aeabi_d2uiz>
	      pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 8004382:	68a2      	ldr	r2, [r4, #8]
  pwmStart(&PWMD1, &pwmcfg);



  while(TRUE) {            
	      aux = rrojo*39.2;
 8004384:	b283      	uxth	r3, r0
	      pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 8004386:	fb02 f203 	mul.w	r2, r2, r3
 800438a:	fba6 1202 	umull	r1, r2, r6, r2
 800438e:	f241 20e0 	movw	r0, #4832	; 0x12e0
 8004392:	0b52      	lsrs	r2, r2, #13
 8004394:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004398:	2100      	movs	r1, #0
  pwmStart(&PWMD1, &pwmcfg);



  while(TRUE) {            
	      aux = rrojo*39.2;
 800439a:	802b      	strh	r3, [r5, #0]
	      pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 800439c:	f7fd fcf0 	bl	8001d80 <pwmEnableChannel>
	      pwmEnableChannelNotification(&PWMD1, 0);
 80043a0:	f241 20e0 	movw	r0, #4832	; 0x12e0
 80043a4:	2100      	movs	r1, #0
 80043a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80043aa:	f7fd fd19 	bl	8001de0 <pwmEnableChannelNotification>
	      pwmEnablePeriodicNotification(&PWMD1);
 80043ae:	f241 20e0 	movw	r0, #4832	; 0x12e0
 80043b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80043b6:	f7fd fcf3 	bl	8001da0 <pwmEnablePeriodicNotification>
              chThdSleepMilliseconds(10);
 80043ba:	2064      	movs	r0, #100	; 0x64
 80043bc:	f7fd fb10 	bl	80019e0 <chThdSleep>
	      aux= rverde*39.2;
 80043c0:	f8b8 0000 	ldrh.w	r0, [r8]
 80043c4:	f7fc f8f6 	bl	80005b4 <__aeabi_i2d>
 80043c8:	a327      	add	r3, pc, #156	; (adr r3, 8004468 <Thd2+0x158>)
 80043ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 80043ce:	f7fc f957 	bl	8000680 <__aeabi_dmul>
 80043d2:	f7fc fb6d 	bl	8000ab0 <__aeabi_d2uiz>
	      pwmEnableChannel(&PWMD1, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 80043d6:	68a2      	ldr	r2, [r4, #8]
	      aux = rrojo*39.2;
	      pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
	      pwmEnableChannelNotification(&PWMD1, 0);
	      pwmEnablePeriodicNotification(&PWMD1);
              chThdSleepMilliseconds(10);
	      aux= rverde*39.2;
 80043d8:	b283      	uxth	r3, r0
	      pwmEnableChannel(&PWMD1, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 80043da:	fb02 f203 	mul.w	r2, r2, r3
 80043de:	fba6 1202 	umull	r1, r2, r6, r2
 80043e2:	f241 20e0 	movw	r0, #4832	; 0x12e0
 80043e6:	0b52      	lsrs	r2, r2, #13
 80043e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80043ec:	2101      	movs	r1, #1
	      aux = rrojo*39.2;
	      pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
	      pwmEnableChannelNotification(&PWMD1, 0);
	      pwmEnablePeriodicNotification(&PWMD1);
              chThdSleepMilliseconds(10);
	      aux= rverde*39.2;
 80043ee:	802b      	strh	r3, [r5, #0]
	      pwmEnableChannel(&PWMD1, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 80043f0:	f7fd fcc6 	bl	8001d80 <pwmEnableChannel>
	      pwmEnableChannelNotification(&PWMD1, 1);
 80043f4:	f241 20e0 	movw	r0, #4832	; 0x12e0
 80043f8:	2101      	movs	r1, #1
 80043fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80043fe:	f7fd fcef 	bl	8001de0 <pwmEnableChannelNotification>
	      pwmEnablePeriodicNotification(&PWMD1);
 8004402:	f241 20e0 	movw	r0, #4832	; 0x12e0
 8004406:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800440a:	f7fd fcc9 	bl	8001da0 <pwmEnablePeriodicNotification>
	      chThdSleepMilliseconds(10);
 800440e:	2064      	movs	r0, #100	; 0x64
 8004410:	f7fd fae6 	bl	80019e0 <chThdSleep>
	      aux=razul*39.2;
 8004414:	8838      	ldrh	r0, [r7, #0]
 8004416:	f7fc f8cd 	bl	80005b4 <__aeabi_i2d>
 800441a:	a313      	add	r3, pc, #76	; (adr r3, 8004468 <Thd2+0x158>)
 800441c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004420:	f7fc f92e 	bl	8000680 <__aeabi_dmul>
 8004424:	f7fc fb44 	bl	8000ab0 <__aeabi_d2uiz>
	      pwmEnableChannel(&PWMD1, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 8004428:	68a2      	ldr	r2, [r4, #8]
	      aux= rverde*39.2;
	      pwmEnableChannel(&PWMD1, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
	      pwmEnableChannelNotification(&PWMD1, 1);
	      pwmEnablePeriodicNotification(&PWMD1);
	      chThdSleepMilliseconds(10);
	      aux=razul*39.2;
 800442a:	b283      	uxth	r3, r0
	      pwmEnableChannel(&PWMD1, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 800442c:	fb02 f203 	mul.w	r2, r2, r3
 8004430:	fba6 1202 	umull	r1, r2, r6, r2
 8004434:	f241 20e0 	movw	r0, #4832	; 0x12e0
 8004438:	0b52      	lsrs	r2, r2, #13
 800443a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800443e:	2102      	movs	r1, #2
	      aux= rverde*39.2;
	      pwmEnableChannel(&PWMD1, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
	      pwmEnableChannelNotification(&PWMD1, 1);
	      pwmEnablePeriodicNotification(&PWMD1);
	      chThdSleepMilliseconds(10);
	      aux=razul*39.2;
 8004440:	802b      	strh	r3, [r5, #0]
	      pwmEnableChannel(&PWMD1, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, aux));
 8004442:	f7fd fc9d 	bl	8001d80 <pwmEnableChannel>
	      pwmEnableChannelNotification(&PWMD1, 2);
 8004446:	f241 20e0 	movw	r0, #4832	; 0x12e0
 800444a:	2102      	movs	r1, #2
 800444c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004450:	f7fd fcc6 	bl	8001de0 <pwmEnableChannelNotification>
	      pwmEnablePeriodicNotification(&PWMD1);
 8004454:	f241 20e0 	movw	r0, #4832	; 0x12e0
 8004458:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800445c:	f7fd fca0 	bl	8001da0 <pwmEnablePeriodicNotification>
              chThdSleepMilliseconds(10);
 8004460:	2064      	movs	r0, #100	; 0x64
 8004462:	f7fd fabd 	bl	80019e0 <chThdSleep>
 8004466:	e781      	b.n	800436c <Thd2+0x5c>
 8004468:	9999999a 	.word	0x9999999a
 800446c:	40439999 	.word	0x40439999

08004470 <numero>:
  rtcGetTime(&RTCD1, &timespec);
  rtcConvertDateTimeToStructTm(&timespec, timp, NULL);
}


char *numero(int m ){
 8004470:	b082      	sub	sp, #8
	char *p;
	switch(m){
 8004472:	2809      	cmp	r0, #9
 8004474:	d809      	bhi.n	800448a <numero+0x1a>
 8004476:	e8df f000 	tbb	[pc, r0]
 800447a:	0f05      	.short	0x0f05
 800447c:	1f1b1713 	.word	0x1f1b1713
 8004480:	0b2b2723 	.word	0x0b2b2723
	case 5: memcpy(&p, "5", 1);break;
	case 6: memcpy(&p, "6", 1);break;
	case 7: memcpy(&p, "7", 1);break;
	case 8: memcpy(&p, "8", 1);break;
	case 9: memcpy(&p, "9", 1);break;
	case 0: memcpy(&p, "0", 1);break;
 8004484:	2330      	movs	r3, #48	; 0x30
 8004486:	f88d 3004 	strb.w	r3, [sp, #4]
	}
	return p;
}
 800448a:	9801      	ldr	r0, [sp, #4]
 800448c:	b002      	add	sp, #8
 800448e:	4770      	bx	lr
	case 4: memcpy(&p, "4", 1);break;
	case 5: memcpy(&p, "5", 1);break;
	case 6: memcpy(&p, "6", 1);break;
	case 7: memcpy(&p, "7", 1);break;
	case 8: memcpy(&p, "8", 1);break;
	case 9: memcpy(&p, "9", 1);break;
 8004490:	2339      	movs	r3, #57	; 0x39
 8004492:	f88d 3004 	strb.w	r3, [sp, #4]
 8004496:	e7f8      	b.n	800448a <numero+0x1a>


char *numero(int m ){
	char *p;
	switch(m){
	case 1: memcpy(&p, "1", 1);break;
 8004498:	2331      	movs	r3, #49	; 0x31
 800449a:	f88d 3004 	strb.w	r3, [sp, #4]
 800449e:	e7f4      	b.n	800448a <numero+0x1a>
	case 2: memcpy(&p, "2", 1);break;
 80044a0:	2332      	movs	r3, #50	; 0x32
 80044a2:	f88d 3004 	strb.w	r3, [sp, #4]
 80044a6:	e7f0      	b.n	800448a <numero+0x1a>
	case 3: memcpy(&p, "3", 1);break;
 80044a8:	2333      	movs	r3, #51	; 0x33
 80044aa:	f88d 3004 	strb.w	r3, [sp, #4]
 80044ae:	e7ec      	b.n	800448a <numero+0x1a>
	case 4: memcpy(&p, "4", 1);break;
 80044b0:	2334      	movs	r3, #52	; 0x34
 80044b2:	f88d 3004 	strb.w	r3, [sp, #4]
 80044b6:	e7e8      	b.n	800448a <numero+0x1a>
	case 5: memcpy(&p, "5", 1);break;
 80044b8:	2335      	movs	r3, #53	; 0x35
 80044ba:	f88d 3004 	strb.w	r3, [sp, #4]
 80044be:	e7e4      	b.n	800448a <numero+0x1a>
	case 6: memcpy(&p, "6", 1);break;
 80044c0:	2336      	movs	r3, #54	; 0x36
 80044c2:	f88d 3004 	strb.w	r3, [sp, #4]
 80044c6:	e7e0      	b.n	800448a <numero+0x1a>
	case 7: memcpy(&p, "7", 1);break;
 80044c8:	2337      	movs	r3, #55	; 0x37
 80044ca:	f88d 3004 	strb.w	r3, [sp, #4]
 80044ce:	e7dc      	b.n	800448a <numero+0x1a>
	case 8: memcpy(&p, "8", 1);break;
 80044d0:	2338      	movs	r3, #56	; 0x38
 80044d2:	f88d 3004 	strb.w	r3, [sp, #4]
 80044d6:	e7d8      	b.n	800448a <numero+0x1a>
 80044d8:	f3af 8000 	nop.w
 80044dc:	f3af 8000 	nop.w

080044e0 <main>:


/*
 * Application entry point.
 */
int main(void) {
 80044e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80044e4:	b0a5      	sub	sp, #148	; 0x94
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80044e6:	f7fd fb93 	bl	8001c10 <halInit>

  /* switch off wakeup */
  rtcSTM32SetPeriodicWakeup(&RTCD1, NULL);


  palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG);
 80044ea:	2700      	movs	r7, #0
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
  chSysInit();
 80044ec:	f7fc fe30 	bl	8001150 <chSysInit>


  /* switch off wakeup */
  rtcSTM32SetPeriodicWakeup(&RTCD1, NULL);
 80044f0:	f241 20dc 	movw	r0, #4828	; 0x12dc
 80044f4:	4639      	mov	r1, r7
 80044f6:	f2c2 0000 	movt	r0, #8192	; 0x2000


  palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG);
 80044fa:	f2c4 0702 	movt	r7, #16386	; 0x4002
  halInit();
  chSysInit();


  /* switch off wakeup */
  rtcSTM32SetPeriodicWakeup(&RTCD1, NULL);
 80044fe:	f7ff fa5f 	bl	80039c0 <rtcSTM32SetPeriodicWakeup>


  palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG);
 8004502:	4638      	mov	r0, r7
 8004504:	2101      	movs	r1, #1
 8004506:	2203      	movs	r2, #3
 8004508:	f7ff f89a 	bl	8003640 <_pal_lld_setgroupmode>

  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
 800450c:	4638      	mov	r0, r7
 800450e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004512:	f240 3282 	movw	r2, #898	; 0x382
 8004516:	f7ff f893 	bl	8003640 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
 800451a:	4638      	mov	r0, r7
 800451c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8004520:	f240 3282 	movw	r2, #898	; 0x382
 8004524:	f7ff f88c 	bl	8003640 <_pal_lld_setgroupmode>

  palSetGroupMode(GPIOB, PAL_PORT_BIT(13) | PAL_PORT_BIT(14) | PAL_PORT_BIT(15), 0, PAL_MODE_OUTPUT_PUSHPULL);
 8004528:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800452c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004530:	f44f 4160 	mov.w	r1, #57344	; 0xe000
 8004534:	2201      	movs	r2, #1
 8004536:	f7ff f883 	bl	8003640 <_pal_lld_setgroupmode>

  chThdCreateStatic(waThd2, sizeof(waThd2), NORMALPRIO , Thd2, NULL);
 800453a:	2400      	movs	r4, #0
 800453c:	f241 6058 	movw	r0, #5720	; 0x1658
 8004540:	f244 3311 	movw	r3, #17169	; 0x4311
 8004544:	9400      	str	r4, [sp, #0]
 8004546:	f6c0 0300 	movt	r3, #2048	; 0x800
 800454a:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 800454e:	2280      	movs	r2, #128	; 0x80
 8004550:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004554:	f7fd f9c4 	bl	80018e0 <chThdCreateStatic>
  chThdCreateStatic(waThd1, sizeof(waThd1), NORMALPRIO + 1, Thd1, NULL);
 8004558:	f241 3050 	movw	r0, #4944	; 0x1350
 800455c:	f244 2331 	movw	r3, #16945	; 0x4231
 8004560:	9400      	str	r4, [sp, #0]
 8004562:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004566:	f641 0a48 	movw	sl, #6216	; 0x1848
 800456a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800456e:	f44f 7132 	mov.w	r1, #712	; 0x2c8
 8004572:	2281      	movs	r2, #129	; 0x81
 8004574:	f7fd f9b4 	bl	80018e0 <chThdCreateStatic>
 8004578:	f8cd a01c 	str.w	sl, [sp, #28]
 800457c:	f641 0a24 	movw	sl, #6180	; 0x1824
 8004580:	f8cd a058 	str.w	sl, [sp, #88]	; 0x58
 8004584:	f641 0a34 	movw	sl, #6196	; 0x1834
 8004588:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
 800458c:	f641 0a3c 	movw	sl, #6204	; 0x183c
 8004590:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
 8004594:	f641 0a20 	movw	sl, #6176	; 0x1820
 8004598:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
 800459c:	f241 6a48 	movw	sl, #5704	; 0x1648
 80045a0:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
 80045a4:	f241 3a40 	movw	sl, #4928	; 0x1340
 80045a8:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
 80045ac:	f241 6a1c 	movw	sl, #5660	; 0x161c
 80045b0:	f8cd a060 	str.w	sl, [sp, #96]	; 0x60
 80045b4:	f641 0a28 	movw	sl, #6184	; 0x1828
 80045b8:	f8cd a064 	str.w	sl, [sp, #100]	; 0x64
 80045bc:	f241 6a1d 	movw	sl, #5661	; 0x161d
 80045c0:	f8cd a068 	str.w	sl, [sp, #104]	; 0x68
 80045c4:	f241 6a1e 	movw	sl, #5662	; 0x161e
 80045c8:	f8cd a06c 	str.w	sl, [sp, #108]	; 0x6c
 80045cc:	f241 6a1f 	movw	sl, #5663	; 0x161f
 80045d0:	f8cd a070 	str.w	sl, [sp, #112]	; 0x70
 80045d4:	f241 6a20 	movw	sl, #5664	; 0x1620
 80045d8:	f8cd a088 	str.w	sl, [sp, #136]	; 0x88
 80045dc:	f241 6a21 	movw	sl, #5665	; 0x1621
 80045e0:	f8cd a08c 	str.w	sl, [sp, #140]	; 0x8c
 80045e4:	f241 6a41 	movw	sl, #5697	; 0x1641
 80045e8:	f8cd a020 	str.w	sl, [sp, #32]
 80045ec:	f241 6a42 	movw	sl, #5698	; 0x1642
 80045f0:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
 80045f4:	f641 0a5c 	movw	sl, #6236	; 0x185c
 80045f8:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 80045fc:	f641 0a38 	movw	sl, #6200	; 0x1838
 8004600:	f8cd a084 	str.w	sl, [sp, #132]	; 0x84
 8004604:	f241 6a40 	movw	sl, #5696	; 0x1640
 8004608:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 800460c:	f241 6a43 	movw	sl, #5699	; 0x1643
 8004610:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 8004614:	f241 6a24 	movw	sl, #5668	; 0x1624
 8004618:	f8cd a078 	str.w	sl, [sp, #120]	; 0x78
 800461c:	f241 6a22 	movw	sl, #5666	; 0x1622
 8004620:	f8cd a07c 	str.w	sl, [sp, #124]	; 0x7c
 8004624:	f241 6a50 	movw	sl, #5712	; 0x1650
 8004628:	f8cd a080 	str.w	sl, [sp, #128]	; 0x80
 800462c:	f241 6a44 	movw	sl, #5700	; 0x1644
 8004630:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8004634:	f241 6a18 	movw	sl, #5656	; 0x1618
 8004638:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
 800463c:	f241 3a44 	movw	sl, #4932	; 0x1344
 8004640:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
 8004644:	f641 0a30 	movw	sl, #6192	; 0x1830
 8004648:	f8cd a018 	str.w	sl, [sp, #24]
	
		      		palClearPad(GPIOA, GPIOA_LED_GREEN);
 800464c:	2320      	movs	r3, #32
 800464e:	f241 3a48 	movw	sl, #4936	; 0x1348
 8004652:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 8004656:	837b      	strh	r3, [r7, #26]
 8004658:	9f07      	ldr	r7, [sp, #28]
 800465a:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
 800465e:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004662:	9707      	str	r7, [sp, #28]
 8004664:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 8004666:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 800466a:	f2c2 0700 	movt	r7, #8192	; 0x2000
 800466e:	f8cd a058 	str.w	sl, [sp, #88]	; 0x58
 8004672:	9717      	str	r7, [sp, #92]	; 0x5c
 8004674:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
 8004678:	9f11      	ldr	r7, [sp, #68]	; 0x44
 800467a:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 800467e:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
 8004682:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 8004686:	f2c2 0700 	movt	r7, #8192	; 0x2000
 800468a:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 800468e:	9711      	str	r7, [sp, #68]	; 0x44
 8004690:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
 8004694:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 8004696:	f8dd a060 	ldr.w	sl, [sp, #96]	; 0x60
 800469a:	f2c2 0700 	movt	r7, #8192	; 0x2000
 800469e:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80046a2:	9713      	str	r7, [sp, #76]	; 0x4c
 80046a4:	f8cd a060 	str.w	sl, [sp, #96]	; 0x60
 80046a8:	9f19      	ldr	r7, [sp, #100]	; 0x64
 80046aa:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
 80046ae:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80046b2:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80046b6:	9719      	str	r7, [sp, #100]	; 0x64
 80046b8:	f8cd a068 	str.w	sl, [sp, #104]	; 0x68
 80046bc:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 80046be:	f8dd a070 	ldr.w	sl, [sp, #112]	; 0x70
 80046c2:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80046c6:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80046ca:	971b      	str	r7, [sp, #108]	; 0x6c
 80046cc:	f8cd a070 	str.w	sl, [sp, #112]	; 0x70
 80046d0:	9f22      	ldr	r7, [sp, #136]	; 0x88
 80046d2:	f8dd a08c 	ldr.w	sl, [sp, #140]	; 0x8c
 80046d6:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80046da:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80046de:	9722      	str	r7, [sp, #136]	; 0x88
 80046e0:	f8cd a08c 	str.w	sl, [sp, #140]	; 0x8c
 80046e4:	9f08      	ldr	r7, [sp, #32]
 80046e6:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
 80046ea:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80046ee:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80046f2:	9708      	str	r7, [sp, #32]
 80046f4:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
 80046f8:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80046fa:	f8dd a084 	ldr.w	sl, [sp, #132]	; 0x84
 80046fe:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004702:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8004706:	9709      	str	r7, [sp, #36]	; 0x24
 8004708:	f8cd a084 	str.w	sl, [sp, #132]	; 0x84
 800470c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800470e:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 8004712:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004716:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 800471a:	970b      	str	r7, [sp, #44]	; 0x2c
 800471c:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 8004720:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 8004722:	f8dd a07c 	ldr.w	sl, [sp, #124]	; 0x7c
 8004726:	f2c2 0700 	movt	r7, #8192	; 0x2000
 800472a:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 800472e:	971e      	str	r7, [sp, #120]	; 0x78
 8004730:	f8cd a07c 	str.w	sl, [sp, #124]	; 0x7c
 8004734:	9f20      	ldr	r7, [sp, #128]	; 0x80
 8004736:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
 800473a:	f2c2 0700 	movt	r7, #8192	; 0x2000
 800473e:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8004742:	9720      	str	r7, [sp, #128]	; 0x80
 8004744:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8004748:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 800474a:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
 800474e:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004752:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8004756:	970e      	str	r7, [sp, #56]	; 0x38
 8004758:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
 800475c:	9f06      	ldr	r7, [sp, #24]
 800475e:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8004762:	f640 0600 	movw	r6, #2048	; 0x800
 8004766:	f641 052c 	movw	r5, #6188	; 0x182c
 800476a:	f241 6b28 	movw	fp, #5672	; 0x1628
 800476e:	f640 0478 	movw	r4, #2168	; 0x878
 8004772:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004776:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 800477a:	f2c2 0600 	movt	r6, #8192	; 0x2000
 800477e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004782:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8004786:	9706      	str	r7, [sp, #24]
 8004788:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800478c:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 8004790:	e129      	b.n	80049e6 <main+0x506>

/*
 * Obtiene el tiempo del RTC 
 */
static void GetTimeTm(struct tm *timp) {
  rtcGetTime(&RTCD1, &timespec);
 8004792:	f241 20dc 	movw	r0, #4828	; 0x12dc
 8004796:	f241 3134 	movw	r1, #4916	; 0x1334
 800479a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800479e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80047a2:	f7fd fb45 	bl	8001e30 <rtcGetTime>
  rtcConvertDateTimeToStructTm(&timespec, timp, NULL);
 80047a6:	f241 3034 	movw	r0, #4916	; 0x1334
 80047aa:	f640 0100 	movw	r1, #2048	; 0x800
 80047ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80047b2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80047b6:	2200      	movs	r2, #0
 80047b8:	f7fd fb42 	bl	8001e40 <rtcConvertDateTimeToStructTm>
	     	}

		// Si es el la hora de dosificar, el motor gira la cantidad de gramos que son enviados por el usuario

		GetTimeTm(&timx);
		c2 = rhora/rfrec;
 80047bc:	f8dd a020 	ldr.w	sl, [sp, #32]
		r2 = rhora-rfrec*(c2);
		if( r2 == timx.tm_hour%(rfrec) && timx.tm_min == rmin && timx.tm_sec == 0){
 80047c0:	68b0      	ldr	r0, [r6, #8]
	     	}

		// Si es el la hora de dosificar, el motor gira la cantidad de gramos que son enviados por el usuario

		GetTimeTm(&timx);
		c2 = rhora/rfrec;
 80047c2:	f89a 7000 	ldrb.w	r7, [sl]
 80047c6:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 80047ca:	f89a 1000 	ldrb.w	r1, [sl]
 80047ce:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 80047d2:	b24b      	sxtb	r3, r1
 80047d4:	b27a      	sxtb	r2, r7
 80047d6:	fb92 f2f3 	sdiv	r2, r2, r3
		r2 = rhora-rfrec*(c2);
 80047da:	fb02 7111 	mls	r1, r2, r1, r7
 80047de:	b2c9      	uxtb	r1, r1
		if( r2 == timx.tm_hour%(rfrec) && timx.tm_min == rmin && timx.tm_sec == 0){
 80047e0:	fb90 f7f3 	sdiv	r7, r0, r3
 80047e4:	fb03 0317 	mls	r3, r3, r7, r0
 80047e8:	b248      	sxtb	r0, r1

		// Si es el la hora de dosificar, el motor gira la cantidad de gramos que son enviados por el usuario

		GetTimeTm(&timx);
		c2 = rhora/rfrec;
		r2 = rhora-rfrec*(c2);
 80047ea:	9f0c      	ldr	r7, [sp, #48]	; 0x30
	     	}

		// Si es el la hora de dosificar, el motor gira la cantidad de gramos que son enviados por el usuario

		GetTimeTm(&timx);
		c2 = rhora/rfrec;
 80047ec:	f88a 2000 	strb.w	r2, [sl]
		r2 = rhora-rfrec*(c2);
		if( r2 == timx.tm_hour%(rfrec) && timx.tm_min == rmin && timx.tm_sec == 0){
 80047f0:	4298      	cmp	r0, r3

		// Si es el la hora de dosificar, el motor gira la cantidad de gramos que son enviados por el usuario

		GetTimeTm(&timx);
		c2 = rhora/rfrec;
		r2 = rhora-rfrec*(c2);
 80047f2:	7039      	strb	r1, [r7, #0]
		if( r2 == timx.tm_hour%(rfrec) && timx.tm_min == rmin && timx.tm_sec == 0){
 80047f4:	f000 8384 	beq.w	8004f00 <main+0xa20>
	//////*********************//////
	//////*****ILUMINACION*****//////
	//////*********************//////


		chThdSleepMilliseconds(10);
 80047f8:	2064      	movs	r0, #100	; 0x64
 80047fa:	f7fd f8f1 	bl	80019e0 <chThdSleep>
	     	if(strncmp(buffer,"L",1) == 0){
 80047fe:	9f07      	ldr	r7, [sp, #28]
 8004800:	783b      	ldrb	r3, [r7, #0]
 8004802:	2b4c      	cmp	r3, #76	; 0x4c
 8004804:	f000 8299 	beq.w	8004d3a <main+0x85a>

	//////*********************//////
	//////*****TEMPERATURA*****//////
	//////*********************//////

		chThdSleepMilliseconds(10);
 8004808:	2064      	movs	r0, #100	; 0x64
 800480a:	f7fd f8e9 	bl	80019e0 <chThdSleep>
	  	temp = onewireTest();
 800480e:	f000 fba7 	bl	8004f60 <onewireTest>
	  	temp1=temp/1000;
 8004812:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 8004816:	f2c1 0362 	movt	r3, #4194	; 0x1062
 800481a:	fb83 e300 	smull	lr, r3, r3, r0
 800481e:	17c7      	asrs	r7, r0, #31
	  	temp2=temp-temp1*1000;
	  
	 	p1 =temp1/10;
 8004820:	f246 6167 	movw	r1, #26215	; 0x6667
	//////*****TEMPERATURA*****//////
	//////*********************//////

		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
	  	temp1=temp/1000;
 8004824:	ebc7 13a3 	rsb	r3, r7, r3, asr #6
	  	temp2=temp-temp1*1000;
	  
	 	p1 =temp1/10;
 8004828:	f2c6 6166 	movt	r1, #26214	; 0x6666
 800482c:	fb81 a103 	smull	sl, r1, r1, r3
	//////*********************//////
	//////*****TEMPERATURA*****//////
	//////*********************//////

		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
 8004830:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
 8004834:	f64f 4218 	movw	r2, #64536	; 0xfc18
	//////*********************//////
	//////*****TEMPERATURA*****//////
	//////*********************//////

		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
 8004838:	f8ca 0000 	str.w	r0, [sl]
	  	temp1=temp/1000;
 800483c:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
	  	temp2=temp-temp1*1000;
 8004840:	f6cf 72ff 	movt	r2, #65535	; 0xffff
	  
	 	p1 =temp1/10;
	 	p2 =temp1-p1*10;
	 	p3 =temp2/100;
 8004844:	f248 571f 	movw	r7, #34079	; 0x851f
	//////*********************//////

		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
 8004848:	fb02 0203 	mla	r2, r2, r3, r0
	//////*****TEMPERATURA*****//////
	//////*********************//////

		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
	  	temp1=temp/1000;
 800484c:	f8ca 3000 	str.w	r3, [sl]
	  	temp2=temp-temp1*1000;
	  
	 	p1 =temp1/10;
	 	p2 =temp1-p1*10;
	 	p3 =temp2/100;
 8004850:	f2c5 17eb 	movt	r7, #20971	; 0x51eb
	//////*********************//////

		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
 8004854:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
	  
	 	p1 =temp1/10;
	 	p2 =temp1-p1*10;
	 	p3 =temp2/100;
 8004858:	fb87 e702 	smull	lr, r7, r7, r2
 800485c:	17d0      	asrs	r0, r2, #31
		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
	  
	 	p1 =temp1/10;
 800485e:	ea4f 7ee3 	mov.w	lr, r3, asr #31
 8004862:	ebce 01a1 	rsb	r1, lr, r1, asr #2
	//////*********************//////

		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
 8004866:	f8ca 2000 	str.w	r2, [sl]
	  
	 	p1 =temp1/10;
	 	p2 =temp1-p1*10;
	 	p3 =temp2/100;
 800486a:	ebc0 1e67 	rsb	lr, r0, r7, asr #5
 800486e:	f8dd a018 	ldr.w	sl, [sp, #24]
		chThdSleepMilliseconds(10);
	  	temp = onewireTest();
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
	  
	 	p1 =temp1/10;
 8004872:	6029      	str	r1, [r5, #0]
	 	p2 =temp1-p1*10;
 8004874:	f06f 0709 	mvn.w	r7, #9
 8004878:	fb07 3301 	mla	r3, r7, r1, r3
	 	p3 =temp2/100;


     		chThdSleepMilliseconds(10);
 800487c:	2064      	movs	r0, #100	; 0x64
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
	  
	 	p1 =temp1/10;
	 	p2 =temp1-p1*10;
	 	p3 =temp2/100;
 800487e:	f8ca e000 	str.w	lr, [sl]
	  	temp = onewireTest();
	  	temp1=temp/1000;
	  	temp2=temp-temp1*1000;
	  
	 	p1 =temp1/10;
	 	p2 =temp1-p1*10;
 8004882:	f8cb 3000 	str.w	r3, [fp]
	 	p3 =temp2/100;


     		chThdSleepMilliseconds(10);
 8004886:	f7fd f8ab 	bl	80019e0 <chThdSleep>
		uartStartSend(&UARTD1, 1, "t");
 800488a:	f241 3018 	movw	r0, #4888	; 0x1318
 800488e:	f645 0220 	movw	r2, #22560	; 0x5820
 8004892:	f6c0 0200 	movt	r2, #2048	; 0x800
 8004896:	2101      	movs	r1, #1
 8004898:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800489c:	f7fd fb80 	bl	8001fa0 <uartStartSend>

     		chThdSleepMilliseconds(10);
 80048a0:	2064      	movs	r0, #100	; 0x64
 80048a2:	f7fd f89d 	bl	80019e0 <chThdSleep>
		x=numero(p1);
 80048a6:	6828      	ldr	r0, [r5, #0]
 80048a8:	f7ff fde2 	bl	8004470 <numero>
		uartStartSend(&UARTD1, 1, &x);
 80048ac:	f640 0278 	movw	r2, #2168	; 0x878

     		chThdSleepMilliseconds(10);
		uartStartSend(&UARTD1, 1, "t");

     		chThdSleepMilliseconds(10);
		x=numero(p1);
 80048b0:	6020      	str	r0, [r4, #0]
		uartStartSend(&UARTD1, 1, &x);
 80048b2:	f241 3018 	movw	r0, #4888	; 0x1318
 80048b6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80048ba:	2101      	movs	r1, #1
 80048bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80048c0:	f7fd fb6e 	bl	8001fa0 <uartStartSend>

		x=numero(p2);
 80048c4:	f8db 0000 	ldr.w	r0, [fp]
 80048c8:	f7ff fdd2 	bl	8004470 <numero>
 80048cc:	6020      	str	r0, [r4, #0]
     		chThdSleepMilliseconds(10);
 80048ce:	2064      	movs	r0, #100	; 0x64
 80048d0:	f7fd f886 	bl	80019e0 <chThdSleep>
		uartStartSend(&UARTD1, 1, &x);
 80048d4:	f241 3018 	movw	r0, #4888	; 0x1318
 80048d8:	f640 0278 	movw	r2, #2168	; 0x878
 80048dc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80048e0:	2101      	movs	r1, #1
 80048e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80048e6:	f7fd fb5b 	bl	8001fa0 <uartStartSend>

     		chThdSleepMilliseconds(10);
 80048ea:	2064      	movs	r0, #100	; 0x64
 80048ec:	f7fd f878 	bl	80019e0 <chThdSleep>
		uartStartSend(&UARTD1, 1, ".");
 80048f0:	f241 3018 	movw	r0, #4888	; 0x1318
 80048f4:	f645 0224 	movw	r2, #22564	; 0x5824
 80048f8:	f6c0 0200 	movt	r2, #2048	; 0x800
 80048fc:	2101      	movs	r1, #1
 80048fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004902:	f7fd fb4d 	bl	8001fa0 <uartStartSend>

		x=numero(p3);
 8004906:	f8da 0000 	ldr.w	r0, [sl]
 800490a:	f7ff fdb1 	bl	8004470 <numero>
 800490e:	6020      	str	r0, [r4, #0]
     		chThdSleepMilliseconds(10);
 8004910:	2064      	movs	r0, #100	; 0x64
 8004912:	f7fd f865 	bl	80019e0 <chThdSleep>
		uartStartSend(&UARTD1, 1, &x);
 8004916:	f241 3018 	movw	r0, #4888	; 0x1318
 800491a:	f640 0278 	movw	r2, #2168	; 0x878
 800491e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004922:	2101      	movs	r1, #1
 8004924:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004928:	f7fd fb3a 	bl	8001fa0 <uartStartSend>

	//////*********************//////
	//////***COEFICIENTE PH****//////
	//////*********************//////

		chThdSleepMilliseconds(10);
 800492c:	2064      	movs	r0, #100	; 0x64
 800492e:	f7fd f857 	bl	80019e0 <chThdSleep>

		p1 = pH;
 8004932:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8004936:	f8da 9000 	ldr.w	r9, [sl]
 800493a:	4648      	mov	r0, r9
 800493c:	f7fc fb88 	bl	8001050 <__aeabi_f2iz>
		p2 = (int) (pH*10) - ((int) p1)*10;
 8004940:	2100      	movs	r1, #0
 8004942:	f2c4 1120 	movt	r1, #16672	; 0x4120
	//////***COEFICIENTE PH****//////
	//////*********************//////

		chThdSleepMilliseconds(10);

		p1 = pH;
 8004946:	4680      	mov	r8, r0
 8004948:	6028      	str	r0, [r5, #0]
		p2 = (int) (pH*10) - ((int) p1)*10;
 800494a:	4648      	mov	r0, r9
 800494c:	f7fc fa30 	bl	8000db0 <__aeabi_fmul>
 8004950:	f7fc fb7e 	bl	8001050 <__aeabi_f2iz>
 8004954:	fb07 0708 	mla	r7, r7, r8, r0

     		chThdSleepMilliseconds(10);
 8004958:	2064      	movs	r0, #100	; 0x64
	//////*********************//////

		chThdSleepMilliseconds(10);

		p1 = pH;
		p2 = (int) (pH*10) - ((int) p1)*10;
 800495a:	f8cb 7000 	str.w	r7, [fp]

     		chThdSleepMilliseconds(10);
 800495e:	f7fd f83f 	bl	80019e0 <chThdSleep>
		uartStartSend(&UARTD1, 1, "p");
 8004962:	f241 3018 	movw	r0, #4888	; 0x1318
 8004966:	f645 0228 	movw	r2, #22568	; 0x5828
 800496a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800496e:	2101      	movs	r1, #1
 8004970:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004974:	f7fd fb14 	bl	8001fa0 <uartStartSend>

     		chThdSleepMilliseconds(10);
 8004978:	2064      	movs	r0, #100	; 0x64
 800497a:	f7fd f831 	bl	80019e0 <chThdSleep>
		x=numero(p1);
 800497e:	6828      	ldr	r0, [r5, #0]
 8004980:	f7ff fd76 	bl	8004470 <numero>
		uartStartSend(&UARTD1, 1, &x);
 8004984:	f640 0278 	movw	r2, #2168	; 0x878

     		chThdSleepMilliseconds(10);
		uartStartSend(&UARTD1, 1, "p");

     		chThdSleepMilliseconds(10);
		x=numero(p1);
 8004988:	6020      	str	r0, [r4, #0]
		uartStartSend(&UARTD1, 1, &x);
 800498a:	f241 3018 	movw	r0, #4888	; 0x1318
 800498e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004992:	2101      	movs	r1, #1
 8004994:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004998:	f7fd fb02 	bl	8001fa0 <uartStartSend>

     		chThdSleepMilliseconds(10);
 800499c:	2064      	movs	r0, #100	; 0x64
 800499e:	f7fd f81f 	bl	80019e0 <chThdSleep>
		uartStartSend(&UARTD1, 1, ".");
 80049a2:	f241 3018 	movw	r0, #4888	; 0x1318
 80049a6:	f645 0224 	movw	r2, #22564	; 0x5824
 80049aa:	f6c0 0200 	movt	r2, #2048	; 0x800
 80049ae:	2101      	movs	r1, #1
 80049b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80049b4:	f7fd faf4 	bl	8001fa0 <uartStartSend>

		x=numero(p2);
 80049b8:	f8db 0000 	ldr.w	r0, [fp]
 80049bc:	f7ff fd58 	bl	8004470 <numero>
 80049c0:	6020      	str	r0, [r4, #0]
     		chThdSleepMilliseconds(10);
 80049c2:	2064      	movs	r0, #100	; 0x64
 80049c4:	f7fd f80c 	bl	80019e0 <chThdSleep>
		uartStartSend(&UARTD1, 1, &x);
 80049c8:	f241 3018 	movw	r0, #4888	; 0x1318
 80049cc:	f640 0278 	movw	r2, #2168	; 0x878
 80049d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80049d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80049d8:	2101      	movs	r1, #1
 80049da:	f7fd fae1 	bl	8001fa0 <uartStartSend>


    
    chThdSleepMilliseconds(350);
 80049de:	f640 50ac 	movw	r0, #3500	; 0xdac
 80049e2:	f7fc fffd 	bl	80019e0 <chThdSleep>


  while (TRUE) {


	uartStart(&UARTD1, &uart_cfg_1);
 80049e6:	f241 3018 	movw	r0, #4888	; 0x1318
 80049ea:	f640 0124 	movw	r1, #2084	; 0x824
 80049ee:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80049f2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80049f6:	f7fd fac3 	bl	8001f80 <uartStart>
	uartStopReceive(&UARTD1);
 80049fa:	f241 3018 	movw	r0, #4888	; 0x1318
 80049fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004a02:	f7fd fb05 	bl	8002010 <uartStopReceive>
	uartStopSend(&UARTD1);
 8004a06:	f241 3018 	movw	r0, #4888	; 0x1318
 8004a0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004a0e:	f7fd fad7 	bl	8001fc0 <uartStopSend>
	uartStartReceive(&UARTD1, 18, buffer);
 8004a12:	f241 3018 	movw	r0, #4888	; 0x1318
 8004a16:	f641 0248 	movw	r2, #6216	; 0x1848
 8004a1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004a1e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004a22:	2112      	movs	r1, #18
 8004a24:	f7fd fae4 	bl	8001ff0 <uartStartReceive>
	//////*********************//////
	//////****DOSIFICACIÓN*****//////
	//////*********************//////


		chThdSleepMilliseconds(10);
 8004a28:	2064      	movs	r0, #100	; 0x64
 8004a2a:	f7fc ffd9 	bl	80019e0 <chThdSleep>
	     	if(strncmp(buffer,"D",1) == 0){
 8004a2e:	9f07      	ldr	r7, [sp, #28]
 8004a30:	783b      	ldrb	r3, [r7, #0]
 8004a32:	2b44      	cmp	r3, #68	; 0x44
 8004a34:	f47f aead 	bne.w	8004792 <main+0x2b2>

		      	palClearPad(GPIOA, GPIOA_LED_GREEN);
 8004a38:	2300      	movs	r3, #0
 8004a3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004a3e:	2220      	movs	r2, #32

			pcharh = strchr(buffer, 'h');
 8004a40:	f641 0048 	movw	r0, #6216	; 0x1848


		chThdSleepMilliseconds(10);
	     	if(strncmp(buffer,"D",1) == 0){

		      	palClearPad(GPIOA, GPIOA_LED_GREEN);
 8004a44:	835a      	strh	r2, [r3, #26]

			pcharh = strchr(buffer, 'h');
 8004a46:	2168      	movs	r1, #104	; 0x68
 8004a48:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004a4c:	f000 fc00 	bl	8005250 <strchr>
 8004a50:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
 8004a54:	4681      	mov	r9, r0
			pcharm = strchr(buffer, 'm');
 8004a56:	f641 0048 	movw	r0, #6216	; 0x1848
 8004a5a:	216d      	movs	r1, #109	; 0x6d
 8004a5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
		chThdSleepMilliseconds(10);
	     	if(strncmp(buffer,"D",1) == 0){

		      	palClearPad(GPIOA, GPIOA_LED_GREEN);

			pcharh = strchr(buffer, 'h');
 8004a60:	f8ca 9000 	str.w	r9, [sl]
			pcharm = strchr(buffer, 'm');
 8004a64:	f000 fbf4 	bl	8005250 <strchr>
 8004a68:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 8004a6a:	4682      	mov	sl, r0
			pcharr = strchr(buffer, 'o');
 8004a6c:	f641 0048 	movw	r0, #6216	; 0x1848
 8004a70:	216f      	movs	r1, #111	; 0x6f
 8004a72:	f2c2 0000 	movt	r0, #8192	; 0x2000
	     	if(strncmp(buffer,"D",1) == 0){

		      	palClearPad(GPIOA, GPIOA_LED_GREEN);

			pcharh = strchr(buffer, 'h');
			pcharm = strchr(buffer, 'm');
 8004a76:	f8c7 a000 	str.w	sl, [r7]
			pcharr = strchr(buffer, 'o');
 8004a7a:	f000 fbe9 	bl	8005250 <strchr>
 8004a7e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8004a82:	4607      	mov	r7, r0
			pcharg = strchr(buffer, 'f');
 8004a84:	f641 0048 	movw	r0, #6216	; 0x1848
 8004a88:	2166      	movs	r1, #102	; 0x66
 8004a8a:	f2c2 0000 	movt	r0, #8192	; 0x2000

		      	palClearPad(GPIOA, GPIOA_LED_GREEN);

			pcharh = strchr(buffer, 'h');
			pcharm = strchr(buffer, 'm');
			pcharr = strchr(buffer, 'o');
 8004a8e:	f8ce 7000 	str.w	r7, [lr]
			pcharg = strchr(buffer, 'f');
 8004a92:	f000 fbdd 	bl	8005250 <strchr>
 8004a96:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8004a98:	4680      	mov	r8, r0
			pcharb = strchr(buffer, 'g');
 8004a9a:	f641 0048 	movw	r0, #6216	; 0x1848
 8004a9e:	2167      	movs	r1, #103	; 0x67
 8004aa0:	f2c2 0000 	movt	r0, #8192	; 0x2000
		      	palClearPad(GPIOA, GPIOA_LED_GREEN);

			pcharh = strchr(buffer, 'h');
			pcharm = strchr(buffer, 'm');
			pcharr = strchr(buffer, 'o');
			pcharg = strchr(buffer, 'f');
 8004aa4:	f8c2 8000 	str.w	r8, [r2]
			pcharb = strchr(buffer, 'g');
 8004aa8:	f000 fbd2 	bl	8005250 <strchr>
 8004aac:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8004aae:	4602      	mov	r2, r0
			pcharz = strchr(buffer, 'z');
 8004ab0:	f641 0048 	movw	r0, #6216	; 0x1848
 8004ab4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004ab8:	217a      	movs	r1, #122	; 0x7a

			pcharh = strchr(buffer, 'h');
			pcharm = strchr(buffer, 'm');
			pcharr = strchr(buffer, 'o');
			pcharg = strchr(buffer, 'f');
			pcharb = strchr(buffer, 'g');
 8004aba:	601a      	str	r2, [r3, #0]
			pcharz = strchr(buffer, 'z');
 8004abc:	9204      	str	r2, [sp, #16]
 8004abe:	f000 fbc7 	bl	8005250 <strchr>
 8004ac2:	f8dd e04c 	ldr.w	lr, [sp, #76]	; 0x4c

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0 && pcharh != 0 && pcharm != 0){
 8004ac6:	9a04      	ldr	r2, [sp, #16]
			pcharh = strchr(buffer, 'h');
			pcharm = strchr(buffer, 'm');
			pcharr = strchr(buffer, 'o');
			pcharg = strchr(buffer, 'f');
			pcharb = strchr(buffer, 'g');
			pcharz = strchr(buffer, 'z');
 8004ac8:	f8ce 0000 	str.w	r0, [lr]

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0 && pcharh != 0 && pcharm != 0){
 8004acc:	2f00      	cmp	r7, #0
 8004ace:	f000 822b 	beq.w	8004f28 <main+0xa48>
 8004ad2:	f1b8 0f00 	cmp.w	r8, #0
 8004ad6:	f000 8227 	beq.w	8004f28 <main+0xa48>
 8004ada:	2a00      	cmp	r2, #0
 8004adc:	f000 8224 	beq.w	8004f28 <main+0xa48>
 8004ae0:	2800      	cmp	r0, #0
 8004ae2:	f000 8221 	beq.w	8004f28 <main+0xa48>
 8004ae6:	f1b9 0f00 	cmp.w	r9, #0
 8004aea:	f000 821d 	beq.w	8004f28 <main+0xa48>
 8004aee:	f1ba 0f00 	cmp.w	sl, #0
 8004af2:	f000 8219 	beq.w	8004f28 <main+0xa48>

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
 8004af6:	f641 0048 	movw	r0, #6216	; 0x1848
 8004afa:	f645 0100 	movw	r1, #22528	; 0x5800
 8004afe:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b02:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004b06:	9204      	str	r2, [sp, #16]
 8004b08:	f000 fc22 	bl	8005350 <strcspn>
 8004b0c:	f645 0104 	movw	r1, #22532	; 0x5804
 8004b10:	4603      	mov	r3, r0
 8004b12:	f641 0048 	movw	r0, #6216	; 0x1848
 8004b16:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004b1e:	9305      	str	r3, [sp, #20]
 8004b20:	f000 fc16 	bl	8005350 <strcspn>
 8004b24:	9b05      	ldr	r3, [sp, #20]
 8004b26:	f8dd e068 	ldr.w	lr, [sp, #104]	; 0x68
 8004b2a:	3b01      	subs	r3, #1
 8004b2c:	1a1b      	subs	r3, r3, r0
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
 8004b2e:	f645 0108 	movw	r1, #22536	; 0x5808
 8004b32:	f641 0048 	movw	r0, #6216	; 0x1848
 8004b36:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b3a:	f2c2 0000 	movt	r0, #8192	; 0x2000
			pcharb = strchr(buffer, 'g');
			pcharz = strchr(buffer, 'z');

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0 && pcharh != 0 && pcharm != 0){

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
 8004b3e:	f88e 3000 	strb.w	r3, [lr]
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
 8004b42:	f000 fc05 	bl	8005350 <strcspn>
 8004b46:	f645 0100 	movw	r1, #22528	; 0x5800
 8004b4a:	4603      	mov	r3, r0
 8004b4c:	f641 0048 	movw	r0, #6216	; 0x1848
 8004b50:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b54:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004b58:	9305      	str	r3, [sp, #20]
 8004b5a:	f000 fbf9 	bl	8005350 <strcspn>
 8004b5e:	9b05      	ldr	r3, [sp, #20]
 8004b60:	f8dd e06c 	ldr.w	lr, [sp, #108]	; 0x6c
 8004b64:	3b01      	subs	r3, #1
 8004b66:	1a1b      	subs	r3, r3, r0
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
 8004b68:	f645 010c 	movw	r1, #22540	; 0x580c
 8004b6c:	f641 0048 	movw	r0, #6216	; 0x1848
 8004b70:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b74:	f2c2 0000 	movt	r0, #8192	; 0x2000
			pcharz = strchr(buffer, 'z');

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0 && pcharh != 0 && pcharm != 0){

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
 8004b78:	f88e 3000 	strb.w	r3, [lr]
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
 8004b7c:	f000 fbe8 	bl	8005350 <strcspn>
 8004b80:	f645 0108 	movw	r1, #22536	; 0x5808
 8004b84:	4603      	mov	r3, r0
 8004b86:	f641 0048 	movw	r0, #6216	; 0x1848
 8004b8a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b8e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004b92:	9305      	str	r3, [sp, #20]
 8004b94:	f000 fbdc 	bl	8005350 <strcspn>
 8004b98:	9b05      	ldr	r3, [sp, #20]
 8004b9a:	f8dd e070 	ldr.w	lr, [sp, #112]	; 0x70
 8004b9e:	3b01      	subs	r3, #1
 8004ba0:	1a1b      	subs	r3, r3, r0
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
 8004ba2:	f645 0110 	movw	r1, #22544	; 0x5810
 8004ba6:	f641 0048 	movw	r0, #6216	; 0x1848
 8004baa:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004bae:	f2c2 0000 	movt	r0, #8192	; 0x2000

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0 && pcharh != 0 && pcharm != 0){

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
 8004bb2:	f88e 3000 	strb.w	r3, [lr]
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
 8004bb6:	f000 fbcb 	bl	8005350 <strcspn>
 8004bba:	f645 010c 	movw	r1, #22540	; 0x580c
 8004bbe:	4603      	mov	r3, r0
 8004bc0:	f641 0048 	movw	r0, #6216	; 0x1848
 8004bc4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004bc8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004bcc:	9305      	str	r3, [sp, #20]
 8004bce:	f000 fbbf 	bl	8005350 <strcspn>
 8004bd2:	9b05      	ldr	r3, [sp, #20]
 8004bd4:	f8dd e088 	ldr.w	lr, [sp, #136]	; 0x88
 8004bd8:	3b01      	subs	r3, #1
 8004bda:	1a1b      	subs	r3, r3, r0
				k5=strcspn(buffer,"z")-strcspn(buffer,"g")-1;
 8004bdc:	f645 0114 	movw	r1, #22548	; 0x5814
 8004be0:	f641 0048 	movw	r0, #6216	; 0x1848
 8004be4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004be8:	f2c2 0000 	movt	r0, #8192	; 0x2000
			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0 && pcharh != 0 && pcharm != 0){

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
 8004bec:	f88e 3000 	strb.w	r3, [lr]
				k5=strcspn(buffer,"z")-strcspn(buffer,"g")-1;
 8004bf0:	f000 fbae 	bl	8005350 <strcspn>
 8004bf4:	f645 0110 	movw	r1, #22544	; 0x5810
 8004bf8:	9014      	str	r0, [sp, #80]	; 0x50
 8004bfa:	f641 0048 	movw	r0, #6216	; 0x1848
 8004bfe:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004c02:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004c06:	f000 fba3 	bl	8005350 <strcspn>
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
 8004c0a:	f89a e001 	ldrb.w	lr, [sl, #1]
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
 8004c0e:	9a04      	ldr	r2, [sp, #16]
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
 8004c10:	f89a a002 	ldrb.w	sl, [sl, #2]
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
 8004c14:	7852      	ldrb	r2, [r2, #1]
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004c16:	78fb      	ldrb	r3, [r7, #3]
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
 8004c18:	7879      	ldrb	r1, [r7, #1]
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
 8004c1a:	9203      	str	r2, [sp, #12]
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
 8004c1c:	f1ae 0e30 	sub.w	lr, lr, #48	; 0x30
 8004c20:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
 8004c24:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
				k5=strcspn(buffer,"z")-strcspn(buffer,"g")-1;
 8004c28:	9a14      	ldr	r2, [sp, #80]	; 0x50
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
 8004c2a:	f899 c001 	ldrb.w	ip, [r9, #1]
 8004c2e:	f899 9002 	ldrb.w	r9, [r9, #2]
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
 8004c32:	eb0a 0e4e 	add.w	lr, sl, lr, lsl #1
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004c36:	3b30      	subs	r3, #48	; 0x30
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
 8004c38:	f897 a002 	ldrb.w	sl, [r7, #2]
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004c3c:	793f      	ldrb	r7, [r7, #4]
 8004c3e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
 8004c42:	3930      	subs	r1, #48	; 0x30
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004c44:	931d      	str	r3, [sp, #116]	; 0x74

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
				k5=strcspn(buffer,"z")-strcspn(buffer,"g")-1;
 8004c46:	3a01      	subs	r2, #1
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
 8004c48:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
 8004c4c:	eb01 0181 	add.w	r1, r1, r1, lsl #2

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
				k5=strcspn(buffer,"z")-strcspn(buffer,"g")-1;
 8004c50:	1a13      	subs	r3, r2, r0
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
 8004c52:	eb0a 0141 	add.w	r1, sl, r1, lsl #1
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
 8004c56:	9803      	ldr	r0, [sp, #12]
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004c58:	f8dd a074 	ldr.w	sl, [sp, #116]	; 0x74
 8004c5c:	3f30      	subs	r7, #48	; 0x30
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
 8004c5e:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
 8004c62:	f1ac 0c30 	sub.w	ip, ip, #48	; 0x30
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004c66:	eb07 004a 	add.w	r0, r7, sl, lsl #1

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
				k5=strcspn(buffer,"z")-strcspn(buffer,"g")-1;
 8004c6a:	9f23      	ldr	r7, [sp, #140]	; 0x8c
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
 8004c6c:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
 8004c70:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
 8004c74:	eb09 0c4c 	add.w	ip, r9, ip, lsl #1
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
 8004c78:	f898 9001 	ldrb.w	r9, [r8, #1]
 8004c7c:	f898 8002 	ldrb.w	r8, [r8, #2]

				k1=strcspn(buffer,"m")-strcspn(buffer,"h")-1;
				k2=strcspn(buffer,"o")-strcspn(buffer,"m")-1;
				k3=strcspn(buffer,"f")-strcspn(buffer,"o")-1;
				k4=strcspn(buffer,"g")-strcspn(buffer,"f")-1;
				k5=strcspn(buffer,"z")-strcspn(buffer,"g")-1;
 8004c80:	703b      	strb	r3, [r7, #0]
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
 8004c82:	f8dd a084 	ldr.w	sl, [sp, #132]	; 0x84
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
 8004c86:	9f19      	ldr	r7, [sp, #100]	; 0x64
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
				rgram = (-48+(int) (pcharb+1)[0]);	
 8004c88:	f88a 2000 	strb.w	r2, [sl]
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
 8004c8c:	fa5f fc8c 	uxtb.w	ip, ip
 8004c90:	f887 c000 	strb.w	ip, [r7]
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
 8004c94:	f8dd a060 	ldr.w	sl, [sp, #96]	; 0x60
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
 8004c98:	9f08      	ldr	r7, [sp, #32]
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
 8004c9a:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
				rgram = (-48+(int) (pcharb+1)[0]);	
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
 8004c9e:	fa5f fe8e 	uxtb.w	lr, lr
 8004ca2:	f88a e000 	strb.w	lr, [sl]
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
 8004ca6:	7039      	strb	r1, [r7, #0]
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
 8004ca8:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 8004cac:	f1a8 0830 	sub.w	r8, r8, #48	; 0x30
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004cb0:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
 8004cb4:	9f09      	ldr	r7, [sp, #36]	; 0x24
				uartStartSend(&UARTD1, k5, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rhora = (-48+(int) (pcharr+1)[0])*10+(-48+(int) (pcharr+1)[1]);
				rmin  = (-48+(int) (pcharr+1)[2])*10+(-48+(int) (pcharr+1)[3]);
 8004cb6:	f88a 0000 	strb.w	r0, [sl]
				rfrec = (-48+(int) (pcharg+1)[0])*10+(-48+(int) (pcharg+1)[1]);
 8004cba:	eb08 0949 	add.w	r9, r8, r9, lsl #1
 8004cbe:	f887 9000 	strb.w	r9, [r7]
				rgram = (-48+(int) (pcharb+1)[0]);	
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
			}

			strcpy(buffer,"00000000000000000");	
 8004cc2:	f645 082c 	movw	r8, #22572	; 0x582c
 8004cc6:	f6c0 0800 	movt	r8, #2048	; 0x800
 8004cca:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 8004cce:	f641 0748 	movw	r7, #6216	; 0x1848
 8004cd2:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004cd6:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8004cd8:	f8d8 8000 	ldr.w	r8, [r8]
			//  timx = {segundos, minutos, hora, 32+dia, mes-1, año-1956, dia-semana(dom=0), (no se), (no se)};
			struct tm tim1 = {0, cmin, chora, 56, 4, 60, 3, 0, 0};
			timx = tim1;
 8004cdc:	2300      	movs	r3, #0
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
			}

			strcpy(buffer,"00000000000000000");	
			//  timx = {segundos, minutos, hora, 32+dia, mes-1, año-1956, dia-semana(dom=0), (no se), (no se)};
			struct tm tim1 = {0, cmin, chora, 56, 4, 60, 3, 0, 0};
 8004cde:	fa4f f18e 	sxtb.w	r1, lr
 8004ce2:	fa4f fc8c 	sxtb.w	ip, ip
			timx = tim1;
			rtcConvertStructTmToDateTime(&timx, 0, &tiempo);
 8004ce6:	f640 0000 	movw	r0, #2048	; 0x800
 8004cea:	f641 0240 	movw	r2, #6208	; 0x1840
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
			}

			strcpy(buffer,"00000000000000000");	
			//  timx = {segundos, minutos, hora, 32+dia, mes-1, año-1956, dia-semana(dom=0), (no se), (no se)};
			struct tm tim1 = {0, cmin, chora, 56, 4, 60, 3, 0, 0};
 8004cee:	6071      	str	r1, [r6, #4]
 8004cf0:	f8c6 c008 	str.w	ip, [r6, #8]
			timx = tim1;
			rtcConvertStructTmToDateTime(&timx, 0, &tiempo);
 8004cf4:	4619      	mov	r1, r3
			}

			strcpy(buffer,"00000000000000000");	
			//  timx = {segundos, minutos, hora, 32+dia, mes-1, año-1956, dia-semana(dom=0), (no se), (no se)};
			struct tm tim1 = {0, cmin, chora, 56, 4, 60, 3, 0, 0};
			timx = tim1;
 8004cf6:	f04f 0e38 	mov.w	lr, #56	; 0x38
				rgram = (-48+(int) (pcharb+1)[0]);	
				chora = (-48+(int) (pcharh+1)[0])*10+(-48+(int) (pcharh+1)[1]);
				cmin  = (-48+(int) (pcharm+1)[0])*10+(-48+(int) (pcharm+1)[1]);
			}

			strcpy(buffer,"00000000000000000");	
 8004cfa:	f8a7 8000 	strh.w	r8, [r7]
			//  timx = {segundos, minutos, hora, 32+dia, mes-1, año-1956, dia-semana(dom=0), (no se), (no se)};
			struct tm tim1 = {0, cmin, chora, 56, 4, 60, 3, 0, 0};
			timx = tim1;
 8004cfe:	f04f 0c04 	mov.w	ip, #4
 8004d02:	6033      	str	r3, [r6, #0]
 8004d04:	61f3      	str	r3, [r6, #28]
 8004d06:	6233      	str	r3, [r6, #32]
			rtcConvertStructTmToDateTime(&timx, 0, &tiempo);
 8004d08:	f2c2 0000 	movt	r0, #8192	; 0x2000
			}

			strcpy(buffer,"00000000000000000");	
			//  timx = {segundos, minutos, hora, 32+dia, mes-1, año-1956, dia-semana(dom=0), (no se), (no se)};
			struct tm tim1 = {0, cmin, chora, 56, 4, 60, 3, 0, 0};
			timx = tim1;
 8004d0c:	2303      	movs	r3, #3
			rtcConvertStructTmToDateTime(&timx, 0, &tiempo);
 8004d0e:	f2c2 0200 	movt	r2, #8192	; 0x2000
			}

			strcpy(buffer,"00000000000000000");	
			//  timx = {segundos, minutos, hora, 32+dia, mes-1, año-1956, dia-semana(dom=0), (no se), (no se)};
			struct tm tim1 = {0, cmin, chora, 56, 4, 60, 3, 0, 0};
			timx = tim1;
 8004d12:	273c      	movs	r7, #60	; 0x3c
 8004d14:	f8c6 e00c 	str.w	lr, [r6, #12]
 8004d18:	f8c6 c010 	str.w	ip, [r6, #16]
 8004d1c:	6177      	str	r7, [r6, #20]
 8004d1e:	61b3      	str	r3, [r6, #24]
			rtcConvertStructTmToDateTime(&timx, 0, &tiempo);
 8004d20:	f7fd f8e6 	bl	8001ef0 <rtcConvertStructTmToDateTime>
			rtcSetTime(&RTCD1, &tiempo);
 8004d24:	f241 20dc 	movw	r0, #4828	; 0x12dc
 8004d28:	f641 0140 	movw	r1, #6208	; 0x1840
 8004d2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d30:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8004d34:	f7fd f874 	bl	8001e20 <rtcSetTime>
 8004d38:	e52b      	b.n	8004792 <main+0x2b2>


		chThdSleepMilliseconds(10);
	     	if(strncmp(buffer,"L",1) == 0){

			pcharr = strchr(buffer, 'r');
 8004d3a:	f641 0048 	movw	r0, #6216	; 0x1848
 8004d3e:	2172      	movs	r1, #114	; 0x72
 8004d40:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d44:	f000 fa84 	bl	8005250 <strchr>
 8004d48:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
 8004d4c:	4607      	mov	r7, r0
			pcharg = strchr(buffer, 'g');
 8004d4e:	f641 0048 	movw	r0, #6216	; 0x1848
 8004d52:	2167      	movs	r1, #103	; 0x67
 8004d54:	f2c2 0000 	movt	r0, #8192	; 0x2000


		chThdSleepMilliseconds(10);
	     	if(strncmp(buffer,"L",1) == 0){

			pcharr = strchr(buffer, 'r');
 8004d58:	f8ca 7000 	str.w	r7, [sl]
			pcharg = strchr(buffer, 'g');
 8004d5c:	f000 fa78 	bl	8005250 <strchr>
 8004d60:	f8dd a044 	ldr.w	sl, [sp, #68]	; 0x44
 8004d64:	4680      	mov	r8, r0
			pcharb = strchr(buffer, 'b');
 8004d66:	f641 0048 	movw	r0, #6216	; 0x1848
 8004d6a:	2162      	movs	r1, #98	; 0x62
 8004d6c:	f2c2 0000 	movt	r0, #8192	; 0x2000

		chThdSleepMilliseconds(10);
	     	if(strncmp(buffer,"L",1) == 0){

			pcharr = strchr(buffer, 'r');
			pcharg = strchr(buffer, 'g');
 8004d70:	f8ca 8000 	str.w	r8, [sl]
			pcharb = strchr(buffer, 'b');
 8004d74:	f000 fa6c 	bl	8005250 <strchr>
 8004d78:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 8004d7c:	4681      	mov	r9, r0
			pcharz = strchr(buffer, 'z');
 8004d7e:	f641 0048 	movw	r0, #6216	; 0x1848
 8004d82:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d86:	217a      	movs	r1, #122	; 0x7a
		chThdSleepMilliseconds(10);
	     	if(strncmp(buffer,"L",1) == 0){

			pcharr = strchr(buffer, 'r');
			pcharg = strchr(buffer, 'g');
			pcharb = strchr(buffer, 'b');
 8004d88:	f8ca 9000 	str.w	r9, [sl]
			pcharz = strchr(buffer, 'z');
 8004d8c:	f000 fa60 	bl	8005250 <strchr>
 8004d90:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
 8004d94:	f8ca 0000 	str.w	r0, [sl]

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0){
 8004d98:	2f00      	cmp	r7, #0
 8004d9a:	f000 80a2 	beq.w	8004ee2 <main+0xa02>
 8004d9e:	f1b8 0f00 	cmp.w	r8, #0
 8004da2:	f000 809e 	beq.w	8004ee2 <main+0xa02>
 8004da6:	f1b9 0f00 	cmp.w	r9, #0
 8004daa:	f000 809a 	beq.w	8004ee2 <main+0xa02>
 8004dae:	2800      	cmp	r0, #0
 8004db0:	f000 8097 	beq.w	8004ee2 <main+0xa02>

				k1=strcspn(buffer,"g")-strcspn(buffer,"r")-1;
 8004db4:	f641 0048 	movw	r0, #6216	; 0x1848
 8004db8:	f645 0110 	movw	r1, #22544	; 0x5810
 8004dbc:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004dc0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004dc4:	f000 fac4 	bl	8005350 <strcspn>
 8004dc8:	f645 0118 	movw	r1, #22552	; 0x5818
 8004dcc:	4682      	mov	sl, r0
 8004dce:	f641 0048 	movw	r0, #6216	; 0x1848
 8004dd2:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004dd6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004dda:	f000 fab9 	bl	8005350 <strcspn>
 8004dde:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8004de2:	f8dd e068 	ldr.w	lr, [sp, #104]	; 0x68
 8004de6:	ebc0 0a0a 	rsb	sl, r0, sl
				k2=strcspn(buffer,"b")-strcspn(buffer,"g")-1;
 8004dea:	f645 011c 	movw	r1, #22556	; 0x581c
 8004dee:	f641 0048 	movw	r0, #6216	; 0x1848
 8004df2:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004df6:	f2c2 0000 	movt	r0, #8192	; 0x2000
			pcharb = strchr(buffer, 'b');
			pcharz = strchr(buffer, 'z');

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0){

				k1=strcspn(buffer,"g")-strcspn(buffer,"r")-1;
 8004dfa:	f88e a000 	strb.w	sl, [lr]
				k2=strcspn(buffer,"b")-strcspn(buffer,"g")-1;
 8004dfe:	f000 faa7 	bl	8005350 <strcspn>
 8004e02:	f645 0110 	movw	r1, #22544	; 0x5810
 8004e06:	4682      	mov	sl, r0
 8004e08:	f641 0048 	movw	r0, #6216	; 0x1848
 8004e0c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004e10:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004e14:	f000 fa9c 	bl	8005350 <strcspn>
 8004e18:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8004e1c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8004e1e:	ebc0 0a0a 	rsb	sl, r0, sl
				k3=strcspn(buffer,"z")-strcspn(buffer,"b")-1;
 8004e22:	f645 0114 	movw	r1, #22548	; 0x5814
 8004e26:	f641 0048 	movw	r0, #6216	; 0x1848
 8004e2a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004e2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
			pcharz = strchr(buffer, 'z');

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0){

				k1=strcspn(buffer,"g")-strcspn(buffer,"r")-1;
				k2=strcspn(buffer,"b")-strcspn(buffer,"g")-1;
 8004e32:	f882 a000 	strb.w	sl, [r2]
				k3=strcspn(buffer,"z")-strcspn(buffer,"b")-1;
 8004e36:	f000 fa8b 	bl	8005350 <strcspn>
 8004e3a:	f645 011c 	movw	r1, #22556	; 0x581c
 8004e3e:	4682      	mov	sl, r0
 8004e40:	f641 0048 	movw	r0, #6216	; 0x1848
 8004e44:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004e48:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004e4c:	f000 fa80 	bl	8005350 <strcspn>
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k3, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rrojo =  255-(-48+(int) (pcharr+1)[0])*100+(-48+(int) (pcharr+2)[0])*10+(-48+(int) (pcharr+3)[0]) ;
 8004e50:	787a      	ldrb	r2, [r7, #1]
 8004e52:	78fb      	ldrb	r3, [r7, #3]
 8004e54:	78b9      	ldrb	r1, [r7, #2]
 8004e56:	9f1e      	ldr	r7, [sp, #120]	; 0x78
				rverde = 255-(-48+(int) (pcharg+1)[0])*100+(-48+(int) (pcharg+2)[0])*10+(-48+(int) (pcharg+3)[0]) ;
 8004e58:	f8dd e07c 	ldr.w	lr, [sp, #124]	; 0x7c
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, k3, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rrojo =  255-(-48+(int) (pcharr+1)[0])*100+(-48+(int) (pcharr+2)[0])*10+(-48+(int) (pcharr+3)[0]) ;
 8004e5c:	f1c2 0230 	rsb	r2, r2, #48	; 0x30
 8004e60:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004e64:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004e68:	33cf      	adds	r3, #207	; 0xcf
 8004e6a:	3930      	subs	r1, #48	; 0x30
 8004e6c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8004e70:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8004e74:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 8004e78:	8039      	strh	r1, [r7, #0]
				rverde = 255-(-48+(int) (pcharg+1)[0])*100+(-48+(int) (pcharg+2)[0])*10+(-48+(int) (pcharg+3)[0]) ;
 8004e7a:	f898 1001 	ldrb.w	r1, [r8, #1]
 8004e7e:	f898 2003 	ldrb.w	r2, [r8, #3]
 8004e82:	f898 7002 	ldrb.w	r7, [r8, #2]
				razul =  255-(-48+(int) (pcharb+1)[0])*100+(-48+(int) (pcharb+2)[0])*10+(-48+(int) (pcharb+3)[0]) ;
 8004e86:	f899 3003 	ldrb.w	r3, [r9, #3]
				uartStartSend(&UARTD1, k3, pcharb+1);
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rrojo =  255-(-48+(int) (pcharr+1)[0])*100+(-48+(int) (pcharr+2)[0])*10+(-48+(int) (pcharr+3)[0]) ;
				rverde = 255-(-48+(int) (pcharg+1)[0])*100+(-48+(int) (pcharg+2)[0])*10+(-48+(int) (pcharg+3)[0]) ;
 8004e8a:	f1c1 0130 	rsb	r1, r1, #48	; 0x30
 8004e8e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8004e92:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8004e96:	32cf      	adds	r2, #207	; 0xcf
 8004e98:	3f30      	subs	r7, #48	; 0x30
 8004e9a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8004e9e:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8004ea2:	eb02 0747 	add.w	r7, r2, r7, lsl #1
 8004ea6:	f8ae 7000 	strh.w	r7, [lr]
				razul =  255-(-48+(int) (pcharb+1)[0])*100+(-48+(int) (pcharb+2)[0])*10+(-48+(int) (pcharb+3)[0]) ;
 8004eaa:	f899 1001 	ldrb.w	r1, [r9, #1]
 8004eae:	f899 2002 	ldrb.w	r2, [r9, #2]

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0){

				k1=strcspn(buffer,"g")-strcspn(buffer,"r")-1;
				k2=strcspn(buffer,"b")-strcspn(buffer,"g")-1;
				k3=strcspn(buffer,"z")-strcspn(buffer,"b")-1;
 8004eb2:	9f1c      	ldr	r7, [sp, #112]	; 0x70
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rrojo =  255-(-48+(int) (pcharr+1)[0])*100+(-48+(int) (pcharr+2)[0])*10+(-48+(int) (pcharr+3)[0]) ;
				rverde = 255-(-48+(int) (pcharg+1)[0])*100+(-48+(int) (pcharg+2)[0])*10+(-48+(int) (pcharg+3)[0]) ;
				razul =  255-(-48+(int) (pcharb+1)[0])*100+(-48+(int) (pcharb+2)[0])*10+(-48+(int) (pcharb+3)[0]) ;
 8004eb4:	f1c1 0130 	rsb	r1, r1, #48	; 0x30
 8004eb8:	eb01 0181 	add.w	r1, r1, r1, lsl #2

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0){

				k1=strcspn(buffer,"g")-strcspn(buffer,"r")-1;
				k2=strcspn(buffer,"b")-strcspn(buffer,"g")-1;
				k3=strcspn(buffer,"z")-strcspn(buffer,"b")-1;
 8004ebc:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rrojo =  255-(-48+(int) (pcharr+1)[0])*100+(-48+(int) (pcharr+2)[0])*10+(-48+(int) (pcharr+3)[0]) ;
				rverde = 255-(-48+(int) (pcharg+1)[0])*100+(-48+(int) (pcharg+2)[0])*10+(-48+(int) (pcharg+3)[0]) ;
				razul =  255-(-48+(int) (pcharb+1)[0])*100+(-48+(int) (pcharb+2)[0])*10+(-48+(int) (pcharb+3)[0]) ;
 8004ec0:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8004ec4:	33cf      	adds	r3, #207	; 0xcf
 8004ec6:	3a30      	subs	r2, #48	; 0x30

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0){

				k1=strcspn(buffer,"g")-strcspn(buffer,"r")-1;
				k2=strcspn(buffer,"b")-strcspn(buffer,"g")-1;
				k3=strcspn(buffer,"z")-strcspn(buffer,"b")-1;
 8004ec8:	ebc0 000a 	rsb	r0, r0, sl
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rrojo =  255-(-48+(int) (pcharr+1)[0])*100+(-48+(int) (pcharr+2)[0])*10+(-48+(int) (pcharr+3)[0]) ;
				rverde = 255-(-48+(int) (pcharg+1)[0])*100+(-48+(int) (pcharg+2)[0])*10+(-48+(int) (pcharg+3)[0]) ;
				razul =  255-(-48+(int) (pcharb+1)[0])*100+(-48+(int) (pcharb+2)[0])*10+(-48+(int) (pcharb+3)[0]) ;
 8004ecc:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004ed0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004ed4:	f8dd a080 	ldr.w	sl, [sp, #128]	; 0x80

			if(pcharr != 0 && pcharg != 0 && pcharb != 0 && pcharz != 0){

				k1=strcspn(buffer,"g")-strcspn(buffer,"r")-1;
				k2=strcspn(buffer,"b")-strcspn(buffer,"g")-1;
				k3=strcspn(buffer,"z")-strcspn(buffer,"b")-1;
 8004ed8:	7038      	strb	r0, [r7, #0]
				chThdSleepMilliseconds(10);
				uartStartSend(&UARTD1, 1, "\n");*/
				/*PRUEBA*/
				rrojo =  255-(-48+(int) (pcharr+1)[0])*100+(-48+(int) (pcharr+2)[0])*10+(-48+(int) (pcharr+3)[0]) ;
				rverde = 255-(-48+(int) (pcharg+1)[0])*100+(-48+(int) (pcharg+2)[0])*10+(-48+(int) (pcharg+3)[0]) ;
				razul =  255-(-48+(int) (pcharb+1)[0])*100+(-48+(int) (pcharb+2)[0])*10+(-48+(int) (pcharb+3)[0]) ;
 8004eda:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 8004ede:	f8aa 2000 	strh.w	r2, [sl]
			
			}
				strcpy(buffer,"00000000000000000");
 8004ee2:	f645 0e2c 	movw	lr, #22572	; 0x582c
 8004ee6:	f6c0 0e00 	movt	lr, #2048	; 0x800
 8004eea:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8004eee:	f641 0748 	movw	r7, #6216	; 0x1848
 8004ef2:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004ef6:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8004ef8:	f8de 3000 	ldr.w	r3, [lr]
 8004efc:	803b      	strh	r3, [r7, #0]
 8004efe:	e483      	b.n	8004808 <main+0x328>
		// Si es el la hora de dosificar, el motor gira la cantidad de gramos que son enviados por el usuario

		GetTimeTm(&timx);
		c2 = rhora/rfrec;
		r2 = rhora-rfrec*(c2);
		if( r2 == timx.tm_hour%(rfrec) && timx.tm_min == rmin && timx.tm_sec == 0){
 8004f00:	f640 0a00 	movw	sl, #2048	; 0x800
 8004f04:	9f15      	ldr	r7, [sp, #84]	; 0x54
 8004f06:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8004f0a:	f997 2000 	ldrsb.w	r2, [r7]
 8004f0e:	f8da 3004 	ldr.w	r3, [sl, #4]
 8004f12:	4293      	cmp	r3, r2
 8004f14:	f47f ac70 	bne.w	80047f8 <main+0x318>
 8004f18:	f8da 3000 	ldr.w	r3, [sl]
 8004f1c:	b963      	cbnz	r3, 8004f38 <main+0xa58>
			palSetPad(GPIOA, GPIOA_LED_GREEN);
 8004f1e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004f22:	2220      	movs	r2, #32
 8004f24:	831a      	strh	r2, [r3, #24]
 8004f26:	e467      	b.n	80047f8 <main+0x318>
 8004f28:	9f18      	ldr	r7, [sp, #96]	; 0x60
 8004f2a:	f8dd a064 	ldr.w	sl, [sp, #100]	; 0x64
 8004f2e:	f897 e000 	ldrb.w	lr, [r7]
 8004f32:	f89a c000 	ldrb.w	ip, [sl]
 8004f36:	e6c4      	b.n	8004cc2 <main+0x7e2>
		}
		else{
			if(r2 == timx.tm_hour%(rfrec)  && timx.tm_min == rmin && timx.tm_sec == 4*rgram){
 8004f38:	9f21      	ldr	r7, [sp, #132]	; 0x84
 8004f3a:	f997 2000 	ldrsb.w	r2, [r7]
 8004f3e:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8004f42:	f47f ac59 	bne.w	80047f8 <main+0x318>
		      		palClearPad(GPIOA, GPIOA_LED_GREEN);
 8004f46:	2300      	movs	r3, #0
 8004f48:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004f4c:	2220      	movs	r2, #32
 8004f4e:	835a      	strh	r2, [r3, #26]
 8004f50:	e452      	b.n	80047f8 <main+0x318>
 8004f52:	bf00      	nop
 8004f54:	f3af 8000 	nop.w
 8004f58:	f3af 8000 	nop.w
 8004f5c:	f3af 8000 	nop.w

08004f60 <onewireTest>:
 */

/**
 *
 */
int32_t onewireTest(void) {
 8004f60:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t rombuf[24];
  size_t devices_on_bus = 0;
  bool presence;
  bool x = true;

  onewireObjectInit(&OWD1);
 8004f62:	f241 2000 	movw	r0, #4608	; 0x1200
 */

/**
 *
 */
int32_t onewireTest(void) {
 8004f66:	b087      	sub	sp, #28
  uint8_t rombuf[24];
  size_t devices_on_bus = 0;
  bool presence;
  bool x = true;

  onewireObjectInit(&OWD1);
 8004f68:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f6c:	f7fd fa98 	bl	80024a0 <onewireObjectInit>
  onewireStart(&OWD1, &ow_cfg);
 8004f70:	f241 2000 	movw	r0, #4608	; 0x1200
 8004f74:	f645 0140 	movw	r1, #22592	; 0x5840
 8004f78:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f7c:	f6c0 0100 	movt	r1, #2048	; 0x800

#if ONEWIRE_SYNTH_SEARCH_TEST
  synthSearchRomTest(&OWD1);
#endif

    temperature = -666;
 8004f80:	f641 066c 	movw	r6, #6252	; 0x186c
  size_t devices_on_bus = 0;
  bool presence;
  bool x = true;

  onewireObjectInit(&OWD1);
  onewireStart(&OWD1, &ow_cfg);
 8004f84:	f7fd faa4 	bl	80024d0 <onewireStart>

#if ONEWIRE_SYNTH_SEARCH_TEST
  synthSearchRomTest(&OWD1);
#endif

    temperature = -666;
 8004f88:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8004f8c:	f64f 5366 	movw	r3, #64870	; 0xfd66

  while (x) {
    if (true == onewireReset(&OWD1)){
 8004f90:	f241 2000 	movw	r0, #4608	; 0x1200

#if ONEWIRE_SYNTH_SEARCH_TEST
  synthSearchRomTest(&OWD1);
#endif

    temperature = -666;
 8004f94:	f6cf 73ff 	movt	r3, #65535	; 0xffff

  while (x) {
    if (true == onewireReset(&OWD1)){
 8004f98:	f2c2 0000 	movt	r0, #8192	; 0x2000

#if ONEWIRE_SYNTH_SEARCH_TEST
  synthSearchRomTest(&OWD1);
#endif

    temperature = -666;
 8004f9c:	6033      	str	r3, [r6, #0]

  while (x) {
    if (true == onewireReset(&OWD1)){
 8004f9e:	f7fd facf 	bl	8002540 <onewireReset>
 8004fa2:	2800      	cmp	r0, #0
 8004fa4:	f000 80da 	beq.w	800515c <onewireTest+0x1fc>

      memset(rombuf, 0x55, sizeof(rombuf));
      search_led_on();
 8004fa8:	2400      	movs	r4, #0
    temperature = -666;

  while (x) {
    if (true == onewireReset(&OWD1)){

      memset(rombuf, 0x55, sizeof(rombuf));
 8004faa:	2155      	movs	r1, #85	; 0x55
 8004fac:	2218      	movs	r2, #24
      search_led_on();
 8004fae:	f2c4 0402 	movt	r4, #16386	; 0x4002
    temperature = -666;

  while (x) {
    if (true == onewireReset(&OWD1)){

      memset(rombuf, 0x55, sizeof(rombuf));
 8004fb2:	4668      	mov	r0, sp
 8004fb4:	f000 f8fc 	bl	80051b0 <memset>
      search_led_on();
 8004fb8:	2510      	movs	r5, #16
      devices_on_bus = onewireSearchRom(&OWD1, rombuf, 3); //Direccion en la que se verifican 
 8004fba:	f241 2000 	movw	r0, #4608	; 0x1200

  while (x) {
    if (true == onewireReset(&OWD1)){

      memset(rombuf, 0x55, sizeof(rombuf));
      search_led_on();
 8004fbe:	8325      	strh	r5, [r4, #24]
      devices_on_bus = onewireSearchRom(&OWD1, rombuf, 3); //Direccion en la que se verifican 
 8004fc0:	4669      	mov	r1, sp
 8004fc2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fc6:	2203      	movs	r2, #3
 8004fc8:	f7fd fbda 	bl	8002780 <onewireSearchRom>
      //los dispositivos conectados, y numero máximo de dispositivos que se van a conectar 
      search_led_off();
      osalDbgCheck(devices_on_bus <= 3);
      osalDbgCheck(devices_on_bus  > 0);

      if (1 == devices_on_bus){
 8004fcc:	2801      	cmp	r0, #1
  while (x) {
    if (true == onewireReset(&OWD1)){

      memset(rombuf, 0x55, sizeof(rombuf));
      search_led_on();
      devices_on_bus = onewireSearchRom(&OWD1, rombuf, 3); //Direccion en la que se verifican 
 8004fce:	4607      	mov	r7, r0
      //los dispositivos conectados, y numero máximo de dispositivos que se van a conectar 
      search_led_off();
 8004fd0:	8365      	strh	r5, [r4, #26]
      osalDbgCheck(devices_on_bus <= 3);
      osalDbgCheck(devices_on_bus  > 0);

      if (1 == devices_on_bus){
 8004fd2:	f000 80ca 	beq.w	800516a <onewireTest+0x20a>
 8004fd6:	f641 0560 	movw	r5, #6240	; 0x1860
 8004fda:	f2c2 0500 	movt	r5, #8192	; 0x2000
        osalDbgCheck(testbuf[7] == onewireCRC(testbuf, 7));
        osalDbgCheck(0 == memcmp(rombuf, testbuf, 8));
      }

      /* configure temperature measurement on the devices */
      presence = onewireReset(&OWD1);
 8004fde:	f241 2000 	movw	r0, #4608	; 0x1200
 8004fe2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fe6:	f7fd faab 	bl	8002540 <onewireReset>
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      onewireWrite(&OWD1, testbuf, 1, 0);
 8004fea:	f241 2000 	movw	r0, #4608	; 0x1200
 8004fee:	f641 0160 	movw	r1, #6240	; 0x1860
 8004ff2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004ff6:	f2c2 0100 	movt	r1, #8192	; 0x2000
      }

      /* configure temperature measurement on the devices */
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
 8004ffa:	27cc      	movs	r7, #204	; 0xcc
      onewireWrite(&OWD1, testbuf, 1, 0);
 8004ffc:	2201      	movs	r2, #1
 8004ffe:	2300      	movs	r3, #0
      }

      /* configure temperature measurement on the devices */
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
 8005000:	702f      	strb	r7, [r5, #0]
      onewireWrite(&OWD1, testbuf, 1, 0);
 8005002:	f7fd fb75 	bl	80026f0 <onewireWrite>
      testbuf[0] = ONEWIRE_CMD_WRITE_SCRATCHPAD;
      onewireWrite(&OWD1, testbuf, 1, 0);
 8005006:	f241 2000 	movw	r0, #4608	; 0x1200
 800500a:	f641 0160 	movw	r1, #6240	; 0x1860
 800500e:	2300      	movs	r3, #0
 8005010:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005014:	f2c2 0100 	movt	r1, #8192	; 0x2000
      /* configure temperature measurement on the devices */
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[0] = ONEWIRE_CMD_WRITE_SCRATCHPAD;
 8005018:	244e      	movs	r4, #78	; 0x4e
      onewireWrite(&OWD1, testbuf, 1, 0);
 800501a:	2201      	movs	r2, #1
      /* configure temperature measurement on the devices */
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[0] = ONEWIRE_CMD_WRITE_SCRATCHPAD;
 800501c:	702c      	strb	r4, [r5, #0]
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[1] = 0x00; //segundo bit de temperatura 0
 800501e:	461c      	mov	r4, r3
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[0] = ONEWIRE_CMD_WRITE_SCRATCHPAD;
      onewireWrite(&OWD1, testbuf, 1, 0);
 8005020:	f7fd fb66 	bl	80026f0 <onewireWrite>
      testbuf[1] = 0x00; //segundo bit de temperatura 0
      testbuf[2] = 0x64; //temperatura maxima
      testbuf[3] = 0x00; //temperatura minima
      testbuf[4] = 0x1F; //configuración de 9 bits
      onewireWrite(&OWD1, testbuf, 5, 0);
 8005024:	f241 2000 	movw	r0, #4608	; 0x1200
 8005028:	f641 0160 	movw	r1, #6240	; 0x1860
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[0] = ONEWIRE_CMD_WRITE_SCRATCHPAD;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[1] = 0x00; //segundo bit de temperatura 0
      testbuf[2] = 0x64; //temperatura maxima
 800502c:	f04f 0c64 	mov.w	ip, #100	; 0x64
      testbuf[3] = 0x00; //temperatura minima
      testbuf[4] = 0x1F; //configuración de 9 bits
 8005030:	f04f 0e1f 	mov.w	lr, #31
      onewireWrite(&OWD1, testbuf, 5, 0);
 8005034:	4623      	mov	r3, r4
 8005036:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800503a:	2205      	movs	r2, #5
 800503c:	f2c2 0000 	movt	r0, #8192	; 0x2000
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[0] = ONEWIRE_CMD_WRITE_SCRATCHPAD;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[1] = 0x00; //segundo bit de temperatura 0
      testbuf[2] = 0x64; //temperatura maxima
 8005040:	f885 c002 	strb.w	ip, [r5, #2]
      testbuf[3] = 0x00; //temperatura minima
      testbuf[4] = 0x1F; //configuración de 9 bits
 8005044:	f885 e004 	strb.w	lr, [r5, #4]
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[0] = ONEWIRE_CMD_WRITE_SCRATCHPAD;
      onewireWrite(&OWD1, testbuf, 1, 0);
      testbuf[1] = 0x00; //segundo bit de temperatura 0
 8005048:	706c      	strb	r4, [r5, #1]
      testbuf[2] = 0x64; //temperatura maxima
      testbuf[3] = 0x00; //temperatura minima
 800504a:	70ec      	strb	r4, [r5, #3]
      testbuf[4] = 0x1F; //configuración de 9 bits
      onewireWrite(&OWD1, testbuf, 5, 0);
 800504c:	f7fd fb50 	bl	80026f0 <onewireWrite>


      /* start temperature measurement on all connected devices at once */
      presence = onewireReset(&OWD1);
 8005050:	f241 2000 	movw	r0, #4608	; 0x1200
 8005054:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005058:	f7fd fa72 	bl	8002540 <onewireReset>
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      testbuf[1] = ONEWIRE_CMD_CONVERT_TEMP;
      onewireWrite(&OWD1, testbuf, 2, 0);
 800505c:	f241 2000 	movw	r0, #4608	; 0x1200
 8005060:	f641 0160 	movw	r1, #6240	; 0x1860

      /* start temperature measurement on all connected devices at once */
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      testbuf[1] = ONEWIRE_CMD_CONVERT_TEMP;
 8005064:	f04f 0e44 	mov.w	lr, #68	; 0x44
      onewireWrite(&OWD1, testbuf, 2, 0);
 8005068:	4623      	mov	r3, r4
 800506a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800506e:	2202      	movs	r2, #2
 8005070:	f2c2 0000 	movt	r0, #8192	; 0x2000

      /* start temperature measurement on all connected devices at once */
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
      testbuf[1] = ONEWIRE_CMD_CONVERT_TEMP;
 8005074:	f885 e001 	strb.w	lr, [r5, #1]


      /* start temperature measurement on all connected devices at once */
      presence = onewireReset(&OWD1);
      osalDbgCheck(true == presence);
      testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
 8005078:	702f      	strb	r7, [r5, #0]
      testbuf[1] = ONEWIRE_CMD_CONVERT_TEMP;
      onewireWrite(&OWD1, testbuf, 2, 0);
 800507a:	f7fd fb39 	bl	80026f0 <onewireWrite>

      ow_bus_idle(&OWD1);
 800507e:	f241 2000 	movw	r0, #4608	; 0x1200
 8005082:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005086:	f7fd fa03 	bl	8002490 <ow_bus_idle>
      chThdSleepMilliseconds(100);
 800508a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800508e:	f7fc fca7 	bl	80019e0 <chThdSleep>

#if ONEWIRE_USE_STRONG_PULLUP
      onewireWrite(&OWD1, testbuf, 2, MS2ST(750));
#else
      /* poll bus waiting ready signal from all connected devices */
      testbuf[0] = 0;
 8005092:	702c      	strb	r4, [r5, #0]
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 8005094:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
      while (testbuf[0] == 0){
        osalThreadSleepMilliseconds(50);
        onewireRead(&OWD1, testbuf, 1);
 8005098:	f641 0460 	movw	r4, #6240	; 0x1860
 800509c:	f7fc fca0 	bl	80019e0 <chThdSleep>
 80050a0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80050a4:	f241 2000 	movw	r0, #4608	; 0x1200
 80050a8:	4621      	mov	r1, r4
 80050aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80050ae:	2201      	movs	r2, #1
 80050b0:	f7fd fab6 	bl	8002620 <onewireRead>
#if ONEWIRE_USE_STRONG_PULLUP
      onewireWrite(&OWD1, testbuf, 2, MS2ST(750));
#else
      /* poll bus waiting ready signal from all connected devices */
      testbuf[0] = 0;
      while (testbuf[0] == 0){
 80050b4:	782b      	ldrb	r3, [r5, #0]
 80050b6:	2b00      	cmp	r3, #0
 80050b8:	d0ec      	beq.n	8005094 <onewireTest+0x134>
        onewireRead(&OWD1, testbuf, 1);
      }
#endif

        /* read temperature device by device from their scratchpads */
        presence = onewireReset(&OWD1);
 80050ba:	f241 2000 	movw	r0, #4608	; 0x1200
 80050be:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80050c2:	f7fd fa3d 	bl	8002540 <onewireReset>
        osalDbgCheck(true == presence);

        testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
        //memcpy(&testbuf[1], &rombuf[0], 8);
        onewireWrite(&OWD1, testbuf, 1, 0);
 80050c6:	f241 2000 	movw	r0, #4608	; 0x1200
 80050ca:	f2c2 0000 	movt	r0, #8192	; 0x2000

        /* read temperature device by device from their scratchpads */
        presence = onewireReset(&OWD1);
        osalDbgCheck(true == presence);

        testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
 80050ce:	25cc      	movs	r5, #204	; 0xcc
        //memcpy(&testbuf[1], &rombuf[0], 8);
        onewireWrite(&OWD1, testbuf, 1, 0);
 80050d0:	4621      	mov	r1, r4
 80050d2:	2201      	movs	r2, #1
 80050d4:	2300      	movs	r3, #0

        /* read temperature device by device from their scratchpads */
        presence = onewireReset(&OWD1);
        osalDbgCheck(true == presence);

        testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
 80050d6:	7025      	strb	r5, [r4, #0]
        //memcpy(&testbuf[1], &rombuf[0], 8);
        onewireWrite(&OWD1, testbuf, 1, 0);
 80050d8:	f7fd fb0a 	bl	80026f0 <onewireWrite>
        testbuf[0] = ONEWIRE_CMD_READ_SCRATCHPAD;
        onewireWrite(&OWD1, testbuf, 1, 0);
 80050dc:	f241 2000 	movw	r0, #4608	; 0x1200
 80050e0:	2300      	movs	r3, #0
 80050e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80050e6:	4621      	mov	r1, r4
 80050e8:	2201      	movs	r2, #1
        osalDbgCheck(true == presence);

        testbuf[0] = ONEWIRE_CMD_SKIP_ROM;
        //memcpy(&testbuf[1], &rombuf[0], 8);
        onewireWrite(&OWD1, testbuf, 1, 0);
        testbuf[0] = ONEWIRE_CMD_READ_SCRATCHPAD;
 80050ea:	25be      	movs	r5, #190	; 0xbe
 80050ec:	7025      	strb	r5, [r4, #0]
        onewireWrite(&OWD1, testbuf, 1, 0);
 80050ee:	f7fd faff 	bl	80026f0 <onewireWrite>
        onewireRead(&OWD1, rombuf, 9);
 80050f2:	f241 2000 	movw	r0, #4608	; 0x1200
 80050f6:	4669      	mov	r1, sp
 80050f8:	2209      	movs	r2, #9
 80050fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80050fe:	f7fd fa8f 	bl	8002620 <onewireRead>
        osalDbgCheck(rombuf[8] == onewireCRC(rombuf, 8));

        chThdSleepMilliseconds(100);
 8005102:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005106:	f7fc fc6b 	bl	80019e0 <chThdSleep>

        presence = onewireReset(&OWD1);
 800510a:	f241 2000 	movw	r0, #4608	; 0x1200
 800510e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005112:	f7fd fa15 	bl	8002540 <onewireReset>


        tmp = 0;
        //tmp |=  rombuf[3];
        //temperature = tmp ;
        tmp |= (rombuf[1] << 8) | rombuf[0];
 8005116:	f89d 2001 	ldrb.w	r2, [sp, #1]
 800511a:	f89d 3000 	ldrb.w	r3, [sp]
 800511e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        temperature = (tmp * 625) / 10;
 8005122:	b21b      	sxth	r3, r3
 8005124:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 8005128:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800512c:	f246 6267 	movw	r2, #26215	; 0x6667
 8005130:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8005134:	f2c6 6266 	movt	r2, #26214	; 0x6666
 8005138:	fb82 1203 	smull	r1, r2, r2, r3
 800513c:	17db      	asrs	r3, r3, #31
 800513e:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8005142:	6033      	str	r3, [r6, #0]
 8005144:	2001      	movs	r0, #1
 8005146:	f7fc fc4b 	bl	80019e0 <chThdSleep>

    osalThreadSleep(1); /* enforce ChibiOS's stack overflow check */
    x = 0;
  }

  onewireStop(&OWD1);
 800514a:	f241 2000 	movw	r0, #4608	; 0x1200
 800514e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005152:	f7fd f9dd 	bl	8002510 <onewireStop>
  return temperature;
}
 8005156:	6830      	ldr	r0, [r6, #0]
 8005158:	b007      	add	sp, #28
 800515a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800515c:	f645 0060 	movw	r0, #22624	; 0x5860
 8005160:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005164:	f7fc f844 	bl	80011f0 <chSysHalt>
 8005168:	e7ec      	b.n	8005144 <onewireTest+0x1e4>
      osalDbgCheck(devices_on_bus <= 3);
      osalDbgCheck(devices_on_bus  > 0);

      if (1 == devices_on_bus){
        /* test read rom command */
        presence = onewireReset(&OWD1);
 800516a:	f241 2000 	movw	r0, #4608	; 0x1200
 800516e:	f2c2 0000 	movt	r0, #8192	; 0x2000
        osalDbgCheck(true == presence);
        testbuf[0] = ONEWIRE_CMD_READ_ROM;
 8005172:	f641 0560 	movw	r5, #6240	; 0x1860
      osalDbgCheck(devices_on_bus <= 3);
      osalDbgCheck(devices_on_bus  > 0);

      if (1 == devices_on_bus){
        /* test read rom command */
        presence = onewireReset(&OWD1);
 8005176:	f7fd f9e3 	bl	8002540 <onewireReset>
        osalDbgCheck(true == presence);
        testbuf[0] = ONEWIRE_CMD_READ_ROM;
 800517a:	f2c2 0500 	movt	r5, #8192	; 0x2000
        onewireWrite(&OWD1, testbuf, 1, 0);
 800517e:	f241 2000 	movw	r0, #4608	; 0x1200
 8005182:	463a      	mov	r2, r7
 8005184:	4629      	mov	r1, r5

      if (1 == devices_on_bus){
        /* test read rom command */
        presence = onewireReset(&OWD1);
        osalDbgCheck(true == presence);
        testbuf[0] = ONEWIRE_CMD_READ_ROM;
 8005186:	2433      	movs	r4, #51	; 0x33
        onewireWrite(&OWD1, testbuf, 1, 0);
 8005188:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800518c:	2300      	movs	r3, #0

      if (1 == devices_on_bus){
        /* test read rom command */
        presence = onewireReset(&OWD1);
        osalDbgCheck(true == presence);
        testbuf[0] = ONEWIRE_CMD_READ_ROM;
 800518e:	702c      	strb	r4, [r5, #0]
        onewireWrite(&OWD1, testbuf, 1, 0);
 8005190:	f7fd faae 	bl	80026f0 <onewireWrite>
        onewireRead(&OWD1, testbuf, 8);
 8005194:	f241 2000 	movw	r0, #4608	; 0x1200
 8005198:	4629      	mov	r1, r5
 800519a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800519e:	2208      	movs	r2, #8
 80051a0:	f7fd fa3e 	bl	8002620 <onewireRead>
 80051a4:	e71b      	b.n	8004fde <onewireTest+0x7e>
 80051a6:	bf00      	nop
 80051a8:	f3af 8000 	nop.w
 80051ac:	f3af 8000 	nop.w

080051b0 <memset>:
 80051b0:	b4f0      	push	{r4, r5, r6, r7}
 80051b2:	0784      	lsls	r4, r0, #30
 80051b4:	d043      	beq.n	800523e <memset+0x8e>
 80051b6:	1e54      	subs	r4, r2, #1
 80051b8:	2a00      	cmp	r2, #0
 80051ba:	d03e      	beq.n	800523a <memset+0x8a>
 80051bc:	b2cd      	uxtb	r5, r1
 80051be:	4603      	mov	r3, r0
 80051c0:	e003      	b.n	80051ca <memset+0x1a>
 80051c2:	1e62      	subs	r2, r4, #1
 80051c4:	2c00      	cmp	r4, #0
 80051c6:	d038      	beq.n	800523a <memset+0x8a>
 80051c8:	4614      	mov	r4, r2
 80051ca:	f803 5b01 	strb.w	r5, [r3], #1
 80051ce:	079a      	lsls	r2, r3, #30
 80051d0:	d1f7      	bne.n	80051c2 <memset+0x12>
 80051d2:	2c03      	cmp	r4, #3
 80051d4:	d92a      	bls.n	800522c <memset+0x7c>
 80051d6:	b2cd      	uxtb	r5, r1
 80051d8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80051dc:	2c0f      	cmp	r4, #15
 80051de:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80051e2:	d915      	bls.n	8005210 <memset+0x60>
 80051e4:	f1a4 0710 	sub.w	r7, r4, #16
 80051e8:	093f      	lsrs	r7, r7, #4
 80051ea:	f103 0610 	add.w	r6, r3, #16
 80051ee:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80051f2:	461a      	mov	r2, r3
 80051f4:	6015      	str	r5, [r2, #0]
 80051f6:	6055      	str	r5, [r2, #4]
 80051f8:	6095      	str	r5, [r2, #8]
 80051fa:	60d5      	str	r5, [r2, #12]
 80051fc:	3210      	adds	r2, #16
 80051fe:	42b2      	cmp	r2, r6
 8005200:	d1f8      	bne.n	80051f4 <memset+0x44>
 8005202:	f004 040f 	and.w	r4, r4, #15
 8005206:	3701      	adds	r7, #1
 8005208:	2c03      	cmp	r4, #3
 800520a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 800520e:	d90d      	bls.n	800522c <memset+0x7c>
 8005210:	461e      	mov	r6, r3
 8005212:	4622      	mov	r2, r4
 8005214:	3a04      	subs	r2, #4
 8005216:	2a03      	cmp	r2, #3
 8005218:	f846 5b04 	str.w	r5, [r6], #4
 800521c:	d8fa      	bhi.n	8005214 <memset+0x64>
 800521e:	1f22      	subs	r2, r4, #4
 8005220:	f022 0203 	bic.w	r2, r2, #3
 8005224:	3204      	adds	r2, #4
 8005226:	4413      	add	r3, r2
 8005228:	f004 0403 	and.w	r4, r4, #3
 800522c:	b12c      	cbz	r4, 800523a <memset+0x8a>
 800522e:	b2c9      	uxtb	r1, r1
 8005230:	441c      	add	r4, r3
 8005232:	f803 1b01 	strb.w	r1, [r3], #1
 8005236:	42a3      	cmp	r3, r4
 8005238:	d1fb      	bne.n	8005232 <memset+0x82>
 800523a:	bcf0      	pop	{r4, r5, r6, r7}
 800523c:	4770      	bx	lr
 800523e:	4614      	mov	r4, r2
 8005240:	4603      	mov	r3, r0
 8005242:	e7c6      	b.n	80051d2 <memset+0x22>
	...

08005250 <strchr>:
 8005250:	b2c9      	uxtb	r1, r1
 8005252:	b4f0      	push	{r4, r5, r6, r7}
 8005254:	2900      	cmp	r1, #0
 8005256:	d047      	beq.n	80052e8 <strchr+0x98>
 8005258:	0785      	lsls	r5, r0, #30
 800525a:	d00f      	beq.n	800527c <strchr+0x2c>
 800525c:	7802      	ldrb	r2, [r0, #0]
 800525e:	2a00      	cmp	r2, #0
 8005260:	d03f      	beq.n	80052e2 <strchr+0x92>
 8005262:	4291      	cmp	r1, r2
 8005264:	d03e      	beq.n	80052e4 <strchr+0x94>
 8005266:	1c43      	adds	r3, r0, #1
 8005268:	e005      	b.n	8005276 <strchr+0x26>
 800526a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800526e:	2a00      	cmp	r2, #0
 8005270:	d037      	beq.n	80052e2 <strchr+0x92>
 8005272:	4291      	cmp	r1, r2
 8005274:	d036      	beq.n	80052e4 <strchr+0x94>
 8005276:	079a      	lsls	r2, r3, #30
 8005278:	4618      	mov	r0, r3
 800527a:	d1f6      	bne.n	800526a <strchr+0x1a>
 800527c:	6803      	ldr	r3, [r0, #0]
 800527e:	ea41 2701 	orr.w	r7, r1, r1, lsl #8
 8005282:	ea47 4707 	orr.w	r7, r7, r7, lsl #16
 8005286:	ea83 0207 	eor.w	r2, r3, r7
 800528a:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
 800528e:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 8005292:	ea25 0202 	bic.w	r2, r5, r2
 8005296:	ea24 0303 	bic.w	r3, r4, r3
 800529a:	4313      	orrs	r3, r2
 800529c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80052a0:	d111      	bne.n	80052c6 <strchr+0x76>
 80052a2:	1d02      	adds	r2, r0, #4
 80052a4:	4610      	mov	r0, r2
 80052a6:	f852 3b04 	ldr.w	r3, [r2], #4
 80052aa:	ea83 0407 	eor.w	r4, r3, r7
 80052ae:	f1a4 3601 	sub.w	r6, r4, #16843009	; 0x1010101
 80052b2:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 80052b6:	ea26 0404 	bic.w	r4, r6, r4
 80052ba:	ea25 0303 	bic.w	r3, r5, r3
 80052be:	4323      	orrs	r3, r4
 80052c0:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80052c4:	d0ee      	beq.n	80052a4 <strchr+0x54>
 80052c6:	7803      	ldrb	r3, [r0, #0]
 80052c8:	2b00      	cmp	r3, #0
 80052ca:	d039      	beq.n	8005340 <strchr+0xf0>
 80052cc:	4299      	cmp	r1, r3
 80052ce:	d009      	beq.n	80052e4 <strchr+0x94>
 80052d0:	1c43      	adds	r3, r0, #1
 80052d2:	e001      	b.n	80052d8 <strchr+0x88>
 80052d4:	4291      	cmp	r1, r2
 80052d6:	d005      	beq.n	80052e4 <strchr+0x94>
 80052d8:	4618      	mov	r0, r3
 80052da:	f813 2b01 	ldrb.w	r2, [r3], #1
 80052de:	2a00      	cmp	r2, #0
 80052e0:	d1f8      	bne.n	80052d4 <strchr+0x84>
 80052e2:	4610      	mov	r0, r2
 80052e4:	bcf0      	pop	{r4, r5, r6, r7}
 80052e6:	4770      	bx	lr
 80052e8:	0784      	lsls	r4, r0, #30
 80052ea:	d00b      	beq.n	8005304 <strchr+0xb4>
 80052ec:	7803      	ldrb	r3, [r0, #0]
 80052ee:	2b00      	cmp	r3, #0
 80052f0:	d0f8      	beq.n	80052e4 <strchr+0x94>
 80052f2:	1c43      	adds	r3, r0, #1
 80052f4:	e003      	b.n	80052fe <strchr+0xae>
 80052f6:	7802      	ldrb	r2, [r0, #0]
 80052f8:	3301      	adds	r3, #1
 80052fa:	2a00      	cmp	r2, #0
 80052fc:	d0f2      	beq.n	80052e4 <strchr+0x94>
 80052fe:	0799      	lsls	r1, r3, #30
 8005300:	4618      	mov	r0, r3
 8005302:	d1f8      	bne.n	80052f6 <strchr+0xa6>
 8005304:	6803      	ldr	r3, [r0, #0]
 8005306:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800530a:	ea22 0303 	bic.w	r3, r2, r3
 800530e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8005312:	d10a      	bne.n	800532a <strchr+0xda>
 8005314:	1d03      	adds	r3, r0, #4
 8005316:	4618      	mov	r0, r3
 8005318:	f853 2b04 	ldr.w	r2, [r3], #4
 800531c:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
 8005320:	ea21 0202 	bic.w	r2, r1, r2
 8005324:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8005328:	d0f5      	beq.n	8005316 <strchr+0xc6>
 800532a:	7803      	ldrb	r3, [r0, #0]
 800532c:	2b00      	cmp	r3, #0
 800532e:	d0d9      	beq.n	80052e4 <strchr+0x94>
 8005330:	1c43      	adds	r3, r0, #1
 8005332:	4618      	mov	r0, r3
 8005334:	3301      	adds	r3, #1
 8005336:	7802      	ldrb	r2, [r0, #0]
 8005338:	2a00      	cmp	r2, #0
 800533a:	d1fa      	bne.n	8005332 <strchr+0xe2>
 800533c:	bcf0      	pop	{r4, r5, r6, r7}
 800533e:	4770      	bx	lr
 8005340:	4618      	mov	r0, r3
 8005342:	e7cf      	b.n	80052e4 <strchr+0x94>
	...

08005350 <strcspn>:
 8005350:	b470      	push	{r4, r5, r6}
 8005352:	7804      	ldrb	r4, [r0, #0]
 8005354:	b19c      	cbz	r4, 800537e <strcspn+0x2e>
 8005356:	780e      	ldrb	r6, [r1, #0]
 8005358:	4605      	mov	r5, r0
 800535a:	b14e      	cbz	r6, 8005370 <strcspn+0x20>
 800535c:	42b4      	cmp	r4, r6
 800535e:	d00b      	beq.n	8005378 <strcspn+0x28>
 8005360:	460a      	mov	r2, r1
 8005362:	e001      	b.n	8005368 <strcspn+0x18>
 8005364:	429c      	cmp	r4, r3
 8005366:	d007      	beq.n	8005378 <strcspn+0x28>
 8005368:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800536c:	2b00      	cmp	r3, #0
 800536e:	d1f9      	bne.n	8005364 <strcspn+0x14>
 8005370:	786c      	ldrb	r4, [r5, #1]
 8005372:	3501      	adds	r5, #1
 8005374:	2c00      	cmp	r4, #0
 8005376:	d1f0      	bne.n	800535a <strcspn+0xa>
 8005378:	1a28      	subs	r0, r5, r0
 800537a:	bc70      	pop	{r4, r5, r6}
 800537c:	4770      	bx	lr
 800537e:	4620      	mov	r0, r4
 8005380:	e7fb      	b.n	800537a <strcspn+0x2a>
 8005382:	bf00      	nop
